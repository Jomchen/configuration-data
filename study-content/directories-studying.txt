* 学习大纲
   1. 英语
      - FINISHED
   2. 恋上数据结构
      1. 第一季 Finished
         - 63 约瑟夫问题
         - 65 ArrayList的优化思路重看
      2. 第二季
         - last 1:37:39
      3. 第三季
   3. 韩立刚 TCP/IP 协议
   4. JAVA NIO
   5. JVM
      - 54-55 建议重看；垃圾回收器建议重看
      - 进度：326 04:00
   6. nginx
   7. Wireshark 软件使用
      - P4 02:25
   8. 小码哥-汇编

* 复习
   2. 恋上数据结构
      - 04 快速排序的优化

* 笔记
   - Java 通过泛型数组
      - 当需要创建一个泛型的数组时，可以创建 E[] array = (E[]) new Object[number]
      - 注意这个数组放的都是对象的地址值
   - 大数据解决方案
      - https://www.cnblogs.com/owenma/p/8723339.html


## 一些要测试的代码
   ```
    static ReentrantLock lock = new ReentrantLock();
    static final Condition condition = lock.newCondition();
    
    public static void main(String[] args) throws InterruptedException {
    	Test tt1 = new Test(lock, condition, -1);
    	Test tt2 = new Test(lock, condition, 2);
    	Thread t1 = new Thread(tt1, "Thead-1");
    	Thread t2 = new Thread(tt2, "Thread-2");
    	t1.start();
    	Thread.sleep(2000);
    	t2.start();
    }
    
    static class Test implements Runnable {
    	ReentrantLock lock;
        Condition condition;
        int data;
        public Test(ReentrantLock lock, Condition condition, int data) {
        	this.lock = lock; this.condition = condition; this.data = data;
        }
        
        @Override
        public void run() {
	        try {
	        	myRun();
	        } catch( Exception e) {
	        	e.printStackTrace();
	        }
        }
        
            
	    public void myRun() throws InterruptedException {
	    	String threadName = Thread.currentThread().getName();
	    	System.out.println(threadName + " 准备抢锁");
	      	//lock.lockInterruptibly();
	    	lock.lock();
	    	
	    	try {
	    		System.out.println(threadName + " 进入了方法区");
	    		if (this.data > 0) {
	    			this.condition.signalAll();
	    			System.out.println(threadName + " 唤醒者，当前是否有锁：" + lock.isLocked());
	    			System.out.println(threadName + " 唤醒者执行线程结束");
	    			return;
	    		}
	    		
	      		//for (;;) {
	    			System.out.println(threadName + " 开始阻塞");
	    			condition.await();
	    			System.out.println(threadName + " 阻塞后，现在是否有锁：" + lock.isLocked());
	      		//}
	    	} finally {
	    		System.out.println(threadName + " finished 之前是否有锁：" + lock.isLocked());
	    		System.out.println(threadName + " FINISHED");
	    		lock.unlock();
	    		System.out.println(threadName + " 释放锁成功");
	    	}
	    }
    }
   ```



