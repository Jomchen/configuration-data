* 学习大纲
   1. 英语
      - FINISHED
   2. 恋上数据结构
      1. 第一季 Finished
         - 63 约瑟夫问题
         - 65 ArrayList的优化思路重看
      2. 第二季
         - last 1:37:39
      3. 第三季
   3. 韩立刚 TCP/IP 协议
   4. JAVA NIO
   5. JVM
      - 54-55 建议重看；垃圾回收器建议重看
      - 进度：326 04:00
   6. nginx
   7. Wireshark 软件使用
      - P4 02:25
   8. 小码哥-汇编

* 复习
   2. 恋上数据结构
      - 04 快速排序的优化

* 笔记
   - Java 通过泛型数组
      - 当需要创建一个泛型的数组时，可以创建 E[] array = (E[]) new Object[number]
      - 注意这个数组放的都是对象的地址值
   - 大数据解决方案
      - https://www.cnblogs.com/owenma/p/8723339.html

* 未搞清楚的知识点
   - Java 中 Unsafe 类的源码理解
      - https://blog.csdn.net/a7980718/article/details/83661613
   - 补码
      - https://www.zhihu.com/question/374450559/answer/1036793793
      - https://blog.csdn.net/modi000/article/details/113841959
      - https://zhidao.baidu.com/question/304039834642540444.html
   - Maven resource include exclude filtering 讲解 
      - https://blog.csdn.net/weixin_45881248/article/details/115257195?spm=1001.2101.3001.6650.2&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-2.no_search_link&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-2.no_search_link
      - 官网 http://maven.apache.org/plugins/maven-resources-plugin/examples/filter.html
   - 进程的解释
      - https://zhuanlan.zhihu.com/p/53527981
      - https://zhuanlan.zhihu.com/p/51194025
   - 英语Gitbook
      - https://byoungd.gitbook.io/english-level-up-tips/

## 一些要测试的代码
   ```
    static ReentrantLock lock = new ReentrantLock();
    static final Condition condition = lock.newCondition();
    
    public static void main(String[] args) throws InterruptedException {
    	Test tt1 = new Test(lock, condition, -1);
    	Test tt2 = new Test(lock, condition, 2);
    	Thread t1 = new Thread(tt1, "Thead-1");
    	Thread t2 = new Thread(tt2, "Thread-2");
    	t1.start();
    	Thread.sleep(2000);
    	t2.start();
    }
    
    static class Test implements Runnable {
    	ReentrantLock lock;
        Condition condition;
        int data;
        public Test(ReentrantLock lock, Condition condition, int data) {
        	this.lock = lock; this.condition = condition; this.data = data;
        }
        
        @Override
        public void run() {
	        try {
	        	myRun();
	        } catch( Exception e) {
	        	e.printStackTrace();
	        }
        }
        
            
	    public void myRun() throws InterruptedException {
	    	String threadName = Thread.currentThread().getName();
	    	System.out.println(threadName + " 准备抢锁");
	      	//lock.lockInterruptibly();
	    	lock.lock();
	    	
	    	try {
	    		System.out.println(threadName + " 进入了方法区");
	    		if (this.data > 0) {
	    			this.condition.signalAll();
	    			System.out.println(threadName + " 唤醒者，当前是否有锁：" + lock.isLocked());
	    			System.out.println(threadName + " 唤醒者执行线程结束");
	    			return;
	    		}
	    		
	      		//for (;;) {
	    			System.out.println(threadName + " 开始阻塞");
	    			condition.await();
	    			System.out.println(threadName + " 阻塞后，现在是否有锁：" + lock.isLocked());
	      		//}
	    	} finally {
	    		System.out.println(threadName + " finished 之前是否有锁：" + lock.isLocked());
	    		System.out.println(threadName + " FINISHED");
	    		lock.unlock();
	    		System.out.println(threadName + " 释放锁成功");
	    	}
	    }
    }
   ```



* 要做的事
   * ResultSet 结果集：数据敏感，可滚动，可更新
   * Mysql 事务/索引/锁原理
   * synchronized 和 ReentrantLock 原理
   * Mybatis 封装和源码
   * SpringCloud
   * Jvm
   * 数据结构与算法
   * HashMap扩容机制，防死循环处理方案
