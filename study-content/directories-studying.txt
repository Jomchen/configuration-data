* 学习平台
   - 腾讯课堂
   - 慕课网
   - 学堂在线
   - 尚硅谷
* 学习大纲
   1. 英语
      - FINISHED
   2. 恋上数据结构
      1. 第一季 Finished
         - 63 约瑟夫问题
         - 65 ArrayList的优化思路重看
      2. 第二季
         - last 1:37:39
      3. 第三季
   3. 韩立刚 TCP/IP 协议
   4. JAVA NIO
   5. JVM
      - 54-55 建议重看；垃圾回收器建议重看
      - 进度：326 04:00
   6. nginx
   7. Wireshark 软件使用
      - P4 02:25
   8. 小码哥-汇编
   9. 学习书籍和视频
      - 计算机组成原理
         - 视频：B站《计算机科学速成课》，老外教学
         - 视频：哈尔滨工业大学视频：《计算机组成原理》
         - 书籍：《计算机是怎样跑起来的》和《程序是怎样跑起来的》
      - 操作系统
         - 视频
            - 南大蒋炎老师的课程
         - 书籍
            - 《深入理解计算机系统》
            - 《现代操作系统》
      - 计算机网络
         - 视频
            - 计算机网络微课堂 
         - 书籍
            - 《计算机网络自顶向下方法》
      - 算法
         - 书籍
            - 《算法第4版》，《算法悖论》，《数学之美》，《编程珠玑》，《剑指offer》
      - 数据库
         - 视频
            - 《数据库系统概论》，中国人民大学开课
         - 书籍
            - 《MySQL必知必会》
   10. wireshark
      - 2. # 开始看
   11. 大话设计模式


* 复习
   2. 恋上数据结构
      - 04 快速排序的优化

* 笔记
   - Java 通过泛型数组
      - 当需要创建一个泛型的数组时，可以创建 E[] array = (E[]) new Object[number]
      - 注意这个数组放的都是对象的地址值
   - 大数据解决方案
      - https://www.cnblogs.com/owenma/p/8723339.html


## 一些要测试的代码
   ```
    static ReentrantLock lock = new ReentrantLock();
    static final Condition condition = lock.newCondition();
    
    public static void main(String[] args) throws InterruptedException {
    	Test tt1 = new Test(lock, condition, -1);
    	Test tt2 = new Test(lock, condition, 2);
    	Thread t1 = new Thread(tt1, "Thead-1");
    	Thread t2 = new Thread(tt2, "Thread-2");
    	t1.start();
    	Thread.sleep(2000);
    	t2.start();
    }
    
    static class Test implements Runnable {
    	ReentrantLock lock;
        Condition condition;
        int data;
        public Test(ReentrantLock lock, Condition condition, int data) {
        	this.lock = lock; this.condition = condition; this.data = data;
        }
        
        @Override
        public void run() {
	        try {
	        	myRun();
	        } catch( Exception e) {
	        	e.printStackTrace();
	        }
        }
        
            
	    public void myRun() throws InterruptedException {
	    	String threadName = Thread.currentThread().getName();
	    	System.out.println(threadName + " 准备抢锁");
	      	//lock.lockInterruptibly();
	    	lock.lock();
	    	
	    	try {
	    		System.out.println(threadName + " 进入了方法区");
	    		if (this.data > 0) {
	    			this.condition.signalAll();
	    			System.out.println(threadName + " 唤醒者，当前是否有锁：" + lock.isLocked());
	    			System.out.println(threadName + " 唤醒者执行线程结束");
	    			return;
	    		}
	    		
	      		//for (;;) {
	    			System.out.println(threadName + " 开始阻塞");
	    			condition.await();
	    			System.out.println(threadName + " 阻塞后，现在是否有锁：" + lock.isLocked());
	      		//}
	    	} finally {
	    		System.out.println(threadName + " finished 之前是否有锁：" + lock.isLocked());
	    		System.out.println(threadName + " FINISHED");
	    		lock.unlock();
	    		System.out.println(threadName + " 释放锁成功");
	    	}
	    }
    }
   ```



