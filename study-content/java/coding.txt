* 泛型相关 ---------------------------------------------------------------------------------
   ```
   ResultObj<String> resultObj = ResultObj.success("Linux");
           Class<?> cla = resultObj.getClass();
           String name = cla.getName();
           String simpleName = cla.getSimpleName();
           String canonicalName = cla.getCanonicalName();
           String typeName = cla.getTypeName();
           Type type = cla.getGenericSuperclass();
           Type[] types = cla.getGenericInterfaces();
   
   
           System.out.println("name: " + name);
           System.out.println("simpleName: " + simpleName);
           System.out.println("canonicalName: " + canonicalName);
           System.out.println("typeName: " + typeName);
   ```

* 锁相关 ---------------------------------------------------------------------------------
   ```
    static ReentrantLock lock = new ReentrantLock();
    static final Condition condition = lock.newCondition();
    
    public static void main(String[] args) throws InterruptedException {
    	Test tt1 = new Test(lock, condition, -1);
    	Test tt2 = new Test(lock, condition, 2);
    	Thread t1 = new Thread(tt1, "Thead-1");
    	Thread t2 = new Thread(tt2, "Thread-2");
    	t1.start();
    	Thread.sleep(2000);
    	t2.start();
    }
    
    static class Test implements Runnable {
    	ReentrantLock lock;
        Condition condition;
        int data;
        public Test(ReentrantLock lock, Condition condition, int data) {
        	this.lock = lock; this.condition = condition; this.data = data;
        }
        
        @Override
        public void run() {
	        try {
	        	myRun();
	        } catch( Exception e) {
	        	e.printStackTrace();
	        }
        }
        
            
	    public void myRun() throws InterruptedException {
	    	String threadName = Thread.currentThread().getName();
	    	System.out.println(threadName + " 准备抢锁");
	      	//lock.lockInterruptibly();
	    	lock.lock();
	    	
	    	try {
	    		System.out.println(threadName + " 进入了方法区");
	    		if (this.data > 0) {
	    			this.condition.signalAll();
	    			System.out.println(threadName + " 唤醒者，当前是否有锁：" + lock.isLocked());
	    			System.out.println(threadName + " 唤醒者执行线程结束");
	    			return;
	    		}
	    		
	      		//for (;;) {
	    			System.out.println(threadName + " 开始阻塞");
	    			condition.await();
	    			System.out.println(threadName + " 阻塞后，现在是否有锁：" + lock.isLocked());
	      		//}
	    	} finally {
	    		System.out.println(threadName + " finished 之前是否有锁：" + lock.isLocked());
	    		System.out.println(threadName + " FINISHED");
	    		lock.unlock();
	    		System.out.println(threadName + " 释放锁成功");
	    	}
	    }
    }
   ```

* 获取工程目录路径 ---------------------------------------------------------------------------------
   - String projectPath = System.getProperty("user.dir");
      - 如果这不是一个web工程，则获取的可能不是工程目录（比如在tomcat的工程里运行的工程）

* 生成随机数 ---------------------------------------------------------------------------------
   ```
   随机数范围
   // [min, max]
   Random random = new Random();
   int result = random.nextInt(max) % (max-min+1)+min;
   ```

   ```
   通过 Math 类
   public static String getRandom1(int len) {
       int rs = (int) ((Math.random() * 9 + 1) * Math.pow(10, len - 1));
       return String.valueOf(rs);
   }
   
   该方法是通过Math.random()获取[0.0, 1.0)的随机数，再乘以需要的位数。
   这里用乘9，再加1，而没有用乘10的方式，是为了防止生成的随机数比较小，导致乘以位数后小于指定位数。
   ```

   ```
   通过 Random 类，方式1
   public static String getRandom2(int len) {
       Random r = new Random();
       StringBuilder rs = new StringBuilder();
       for (int i = 0; i < len; i++) {
           rs.append(r.nextInt(10));
       }
       return rs.toString();
   }
   该方法是通过Random类的nextInt(9)方法可以直接获取一个[0,9]的随机整数，然后通过指定次数的循环，来拼接随机数。
   Random类其实还有一些的生成随机数的方法，有兴趣可以了解一下。
   ```

   ```
   通过 Random 类，方式2
   public static String getRandom3(int len) {
       int digit = (int) Math.pow(10, len - 1);
       int rs = new Random().nextInt(digit * 10);
       if (rs < digit) {
           rs += digit;
       }
       return String.valueOf(rs);
   }
   该方法也是通过Random类，不同的是，通过指定随机数的最大值，来生成指定位数的随机整数，因为有可能位数不足，所以当小于指定位数的时候需要加上指定位数的值。
   举例：要生成一个4位数的随机值，那么就是生成一个小于10000的随机整数，当随机数小于1000时，加上1000，来确保位数。
   ```

   ```
   通过指定数据源
   public static String getRandom4(int len) {
       String source = "0123456789";
       Random r = new Random();
       StringBuilder rs = new StringBuilder();
       for (int j = 0; j < len; j++) {
           rs.append(source.charAt(r.nextInt(10)));
       }
       return rs.toString();
   }
   该方法是预设一个数据源，然后通过Random类的nextInt方法获取到一个随机整数，将这个整数作为数据源数组的下标，再通过循环的方法来组成一个随机数。
   这里还可以在数据源中补充上字母，就相当于生成带字母的验证码。

   ```
   获取不重复的随机数
   public static List<String> getDistinctRandom(int len, int num) {
       Set<String> s = new HashSet<>();
       while (s.size() < num) {
           s.add(getRandom4(len));
       }
       return new ArrayList<>(s);
   }
   前面几种方法获取指定个数的随机数，其中是有可能有重复值的。如果想要获取不重复的随机值，也很简单，获取随机值的方式可以不变，
   只要把获取到的随机值都放进Set集合，直到达到需要的个数就ok了。
   ```




