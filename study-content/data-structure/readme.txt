* 数据结构可视化网站
   - https://visualgo.net/zh
* 数据结构算法题库
   - https://leetcode.com
      - 英文网站
   - https://leetcode-cn.com
      - 中文网站

* 银行家算法


* 复杂度
   - 说明
      - 复杂度通常用 O(n) 表示，但是注意 n 是数据规模，而不一定是参数
   - 类别
      - 最好情况复杂度
      - 最坏情况复杂度
      - 平均情况复杂度
         - (从最好的情况复杂度O(1) + O(2) + ... + 到最坏的复杂度 O(n) ) / n
      - 均摊复杂度
         - 经过连续的多次复杂度较低的情况后，出现个别复杂度比较高的情况，用均摊复杂度比较合理一些
         - 比如动态数组的添加操作的举例
            - 有一个数组容量为 4 的动态数组
            - 前四次时间复杂度都为 O(1)
            - 第五次需要扩容，然而第五次扩容的时间复杂度可以均摊到前四次
            - 即前四次每次的时间复杂度为 O(2)
            - 那么总的时间复杂度为 O(2n)，按大O算法结果为 O(1)
      - 复杂度震荡
         - 举例
            - 如果扩容数量和缩容时机不得当，可能会引起复杂度震荡
               - 如果元素数量大于容量的一半时会 触发扩容一倍
               - 如果元素数量等于容量的一半时会触发缩容一半（元素数量大于等于容量一半，小于默认容量时不缩容）
               - 假设此时容量大小为 n，那么元素个数也刚好为 n
               - 如果再加一个元素会造成扩容，复杂度变为 O(n)
               - 如果在加了个元素后再减一个元素，则会缩容，会触发缩容，复杂度也为 O(n)

* 算法优化
   - 用数组表现循环队列的索引计算
      ```
      0 1 2 3 4 5 6 7 # 为一个数组的各位置对应的索引
      条件：
         如果 数组总大小为 size（这里即8）
         如果 index 为指向某位置的索引（当作队头）
         如果 当前数组中有值的数量为 amount（amount 不会超过数组总大小size）
      结论公式：
         队头的前一个位置索引为：
            index - 1 < 0 ? size - (index - 1) : index - 1;
         队头的下一个位置索引为：
            index + 1 >= size ? (index + 1) % size : index + 1;
      
      ```
   - 取模
      ```
      // 尽量避免使用 乘*、除/、模%、浮点数运算，效率低下
      已知 n >= 0, m > 0
      n % m 等价于 n - (m > n ? 0 : m ) 的前提条件：n < 2m
      ```
