* 一些地址
   - 迪迦奥特曼超古代战争
      - https://tieba.baidu.com/p/4878797591
      - http://www.sohu.com/a/232101885_816780
      - https://tieba.baidu.com/p/5791363579?red_tag=1867640621
   - 戴拿奥特曼地址
      - https://tieba.baidu.com/p/3239015450?share=9105&red_tag=3512361102
   - 牙吠连者
      - https://baijiahao.baidu.com/s?id=1593523649326026411&wfr=spider&for=pc

* 技术相关
   - 杂
      - jenkins 部署java程序教程：https://www.cnblogs.com/python-cat/p/11364943.html
      - zookeeper 选举教程：https://www.douban.com/note/208430424/
      - zookeeper 选举教程2：https://www.cnblogs.com/raphael5200/p/5285583.html
      - redis红锁教程：https://www.cnblogs.com/rgcLOVEyaya/p/RGC_LOVE_YAYA_1003days.html
      - redis红锁教程2：https://yq.aliyun.com/articles/674394
      - 一致性哈希和哈希槽的对比：https://www.jianshu.com/p/4163916a2a8a
      - ConcurrentHashMap 的工作原理及代码实现：https://www.cnblogs.com/heqiyoujing/p/10928423.html
      - 布隆过滤器：https://www.cnblogs.com/cpselvis/p/6265825.html
   - java 线程的可见性关键字
      - https://www.cnblogs.com/kubidemanong/p/9505944.html
   - 数据库
      1. 数据库索引
         - https://www.cnblogs.com/zhangxufeng/p/8308558.html
         - https://blog.csdn.net/qq_32126633/article/details/81089573
      2. 数据库集群
         - https://blog.csdn.net/annotation_yang/article/details/80860988
         - http://www.51testing.com/html/84/n-4461684.html
      3. 集群的搭建
         - https://blog.csdn.net/qq_21153619/article/details/81529880
      4 mysql group by 的优化
         - https://www.cnblogs.com/wingsless/p/5040620.html
   - redis
      - https://blog.csdn.net/qq_35152037/article/details/84583573
      - https://www.cnblogs.com/zhenghongxin/p/8669913.html
      - redis 持久化 https://segmentfault.com/a/1190000015983518
      - 缓存 穿透/击穿/雪崩 https://blog.csdn.net/kongtiao5/article/details/82771694
      - 缓存击穿的应对方法 
         - https://blog.csdn.net/sanyaoxu_2/article/details/79472465
         - https://blog.csdn.net/kongtiao5/article/details/82771694
   - fastdfs 集群教程和 keepalive 的搭建
      - https://blog.csdn.net/u012453843/article/list/5
      - ConcurrentHashmap 加锁原理
      - Zookeeper 原理
      - Automic 原理
   - springSession 地址 https://blog.csdn.net/qq_43371556/article/details/100862785
      - https://blog.csdn.net/qq_43371556/article/details/100862785
      - https://zhuanlan.zhihu.com/p/85543763
      - https://www.zhihu.com/question/50954473
   - 锁相关
      - mysql死锁 https://blog.csdn.net/tr1912/article/details/81668423
      - ReentrantLock 的原理 https://blog.csdn.net/fuyuwei2015/article/details/83719444
   - 以下几个教程的地址：
      - 许多教程博客 https://blog.csdn.net/u012453843/article/list/5
      - FastDfs 相关
         - 手把手教你搭建 FastDFS 集群（上）：https://blog.csdn.net/u012453843/article/details/68957209
         - nginx 和 keepalived 实现 nginx 高可用性：https://blog.csdn.net/u012453843/article/details/69668663
         - keepalived 高可用性集群原理：https://www.cnblogs.com/ywrj/p/9483427.html

* 面试需要提问的东西
  1. 项目内容
  2. 人员比例
  3. 作息时间
  4. 加班调休
  5. 是否有公积金
  6. 试用期时间
  7. 直接领导是谁，防止外行领导内行


* 需要马上补充的东西
  1. 锁升级，轻量级锁和重量级锁
  2. mysql 索引查询 如果是 in(...) 和 like 'ksksk' 是否走索引
  3. mysql 的hash索引
  4. mysql 前缀索引查询
  5. jvm 的虚拟机模型，几种垃圾收集器
  6. 红黑树增删原理

* 需要马上补充的东西
  1. 锁升级，轻量级锁和重量级锁
  2. NIO 原理
  3. 红黑树的偏转
  4. 雪花算法长度固定吗
  5. 单机锁的运用场景（join,一些线程安全的集合）
  6. 数据库中，时间字段是否可加索引
  7. 1000 条数据在数据库中要查询多少次
  8. Mybatis 如何优化为一个类 Hibernate

  9. CAS 防止 ABA 问题（比较并交换时，不仅比较值，还比较版本号）
  10. HashMap 在什么时候会 由链表转为红黑树，什么时候会产生扩容（桶中元素小于等于6是链表，大于等于8是红黑树，桶超过64也会转变）
  11. B+树的删除操作过程
  12. Mysql 的锁和隔离级别的详细教程
  13. 如何查看 mysql 的死锁


* 面试还不熟的内容
   4. 轻量级，重量级锁，自旋锁
   8. ribbon 的生命周期
   9. zookeeper 和 eruka 区别
   10. 线程实现轮流打印
   11. 线程池的七个参数
      1. 核心线程数
      2. 最大线程数
      3. 空间线程存活时间
      4. 空间线程戚时间的单位
      5. 队列
         1. ArrayBlockingQueue 基于数组的有界阻塞队列，按FIFO排序，可以防止超过最大线程数，超过后根据拒绝策略处理
         2. LinkedBlockingQueue 基于链表的无界阻塞队列，按FIFO排序，可以一直增加线程，最大线程数不会起效
         3. SynchronousQueue 一个不缓存任务的阻塞队列，生产者放入一个任务必须等到消费者取出这个任务，也就是说新任务进来时，不会缓存，而是直接被调度执行，如果没有可用线程，则创建新的，超过最大根据拒绝策略
         4. PriorityBlockingQueue 具有优先级的无界阻塞队列，优先级通过参数 Coparator 实现
      6. 线程工厂
         - 创建一个新线程时使用的工厂，可以用来设定线程名，是否为 daemon 线程等
      7. 拒绝策略
         1. CallerRunsPolicy 调用者直接执行被拒绝任务的 run 方法，除非线程池已经 shutdown，则直接抛弃任务
         2. AbortPolicy 该策略下，直接丢弃任务，并抛出RejectedExecutionException 异常
         3. DiscardPolicy 直接丢弃任务，什么都不做
         4. DiscardOldestPolicy 抛弃进入队列最早的任务，然后尝试把这次拒绝的任务放入队列

   13. volatile 不能解决同步问题，使用场景是什么情况，和单例有什么样的关系 --> 指令重排，因为在懒汉式下，在判断的情况也许因为还没有初始化而只是因为分配了内存就使用会出现问题
   14. order by 导致索引失效的情况（没有索引覆盖）
   15. > < != 对于 整形和非整形的索引会不会起效
   16. 分布式事务的原理
   17. 对于 ELK 集群服务产生日志的问题 --> 用 Filebeat 进行文件的读取，再传入到 logstash 中就可以解决
   18. SpringSession 的配置原理，还用不用 session（即还用不用 session 的问题）
      - https://blog.csdn.net/qq_43371556/article/details/100862785
   19. Zookeeper 的几个角色的作用

   20. jdk 实现 生产者和消费者，并且有一个空间判断是否存储满了
   21. 分布式 session
   22. redis 缓存穿透
   23. redis 分布式锁
   24. ELK 的存储由 string 到 k-v


* 知识点
   0. 几种锁的分类：https://blog.csdn.net/weixin_38481963/article/details/88384493
   1. Java SE 1.6为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”：锁一共有4种状态，级别从低到高依次是：无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态。锁可以升级但不能降级。
   2. 重量级锁：Synchronized的重量级锁是通过对象内部的一个叫做监视器锁（monitor）来实现的，监视器锁本质又是依赖于底层的操作系统的Mutex Lock（互斥锁）来实现的。而操作系统实现线程之间的切换需要从用户态转换到核心态，这个成本非常高，状态之间的转换需要相对比较长的时间，这就是为什么Synchronized效率低的原因。




* 面试相关的信息
   1. 需要学习的地方
      1. redis 缓存穿透，缓存击穿，缓存雪崩的解决方案
      2. Spring Bean 的生命周期
   2. 面试后需要问的问题
      1. 加班处理
      2. 开发流程
      3. 后台写不写前端代码
      4. 使用jdk版本
      5. 有没有产品
      6. 产品如何上线
      7. 测试团队
      8. 前端
      9. 运维
      10. 开发之前技术设计
      11. 数据库模型
      12. 接口风格，代码规范
      13. codeReviwe
   3. 简历要突出的重点
      1. 高性能，高可用，可扩展，伸缩性，分布式，重构，优化，性能调优
      2. 项目的业务架构图，技术架构图
      3. 系统分析能力，设计能力
      4. 垂构服务化，业务化，业务拆分，jar包拆分，代码分层，具体代码重构
      5. 性能调优，集群，缓存，消息中间件，线程池，多线程，指处理，数据库等
      6. 核心功能，突出难点，流程复杂等特点
      7. 举例
         - 负责为客户提供java ee的企业级架构和实施的解决方案，基于spring平台实现OAuth第三方登录集成，为满足高并发及海量数据，采用分布式程序，基于二次节点数据同步和备份机制满足高度可用性

   4. 面试出现比较薄弱的问题
      1. 熔断降级原理，熔断超时和tcp超时区别（zuul,融断,超时
         - https://blog.csdn.net/zzzgd_666/article/details/83314833
      2. spring 的单例为什么是安全的                                    # spring 以变量副本附给 ThreadLocal 保证线程安全，即以空间换时间
      3. 反射获取父级                                                   # 已解决
      4. 类加载器有几个，以及特性                                       # 已解决
         1. Bootstrap class Loader 启动加载器，一般加载的是一些类库，系统级别
         2. extension class Loader 扩展加载器
         3. application class Loader 应用加载器
         4. java.lang.classloader 自定义加载器
      5. sql 执行顺序                                # FROM -> ON -> JOIN -> WHERE -> GROUP BY -> HAVING -> SELECT -> DISTINCT -> ORDER BY -> LIMIT
      6. excutorService 的 submit 和 execute 的区别  # 一个有返回值一个没有
      7. excutorService 的 拒绝策略                  # 1. 抛异常 2. 直接丢弃 3. 丢弃队列最旧的 4. 归入主线程执行
      8. 不适合作索引的情况                          # 已解决
         - 索引字段经常变动
         - 数据表过大时，通常大于 5w，有些字段长度超过 40，不适合作索引
         - 唯一性差的字段，无法准确找到数据，所以查完索引后依然还需要过一启蒙数据，这样反而增加了查询量
      9. 重看融断的视频（融断的相关默认时间）                           # 完成
         - 注解的使用
            - @EnableCircuitBreaker 是对服务端进行融断，@EnableHystrix 是对客户端进行融断（通常融断使用是在客户端方便提前发现问题）
               - 这两个注解都可以用 @Hystrixcommand 进行方法的灵活配置
            - 如果是用 @FeignClient 的 fallback，它是只能验证宕机，不能验证服务报错，这是fallbackFactory 的问题
               - 配置文件里要开启 hyxtrix 的相关开关
               - 启动类上需要加上 @EnableHyxtrix
            - 当检测到节点微服务调用响应正常后，恢复调用链路，熔断监控会默认认为 5 秒内20次调用失败会触发熔断，熔断机制的注解是 @HystrixCommand
         - 涉及到断路器的三个重要参数：快照时间窗，请求总数阀值，错误百分比阀值
            - 快照时间窗：断路器确定是否打开需要统计一些请求和错误数据，而统计的时间范围就是快照时间窗，默认为最近的 10 秒
            - 请求总数阀值：在快照时间窗内，必须满足请求总数阀值才有资格熔断，默认为 20，意味着在 10 秒内，如果该 hystrix 命令的调用次数不足 20 次，即使所有的请求都超时了或其它原因失败，断路器也不会打开
            - 错误百分比阀值：在请求总数在快照时间窗内超过了阀值，比如发生了 30 次调用，如果在这 30 次调用中，有 15 次发生了超时异常，也就是超过 50% 的错误百分比，在默认设定 50% 阀值情况下，这时候就会将断路器打开
         - 恢复
            - 在断路器打开后，会在一段时间后（默认是5秒），这时断路器会让其中一个请求进行转发，如果成功，断路器会关闭，若失败， 继续开启
      11. redis 集群搭建                                                 # 已解决
      12. 复合索引和单索引的选择
      13. ribbon 的负载有几种
         1. BestAvaiableRule 选择一个最小的并发请求的server
         2. AvailabilityFilteringRule 过滤掉那些因为一直连接失败的被标记为circuittripped的后端server，并过滤掉那些高并发的后端server（active connections 超过配置的阈值）
         3. WeightedResponseTimeRule 根据响应时间分配一个 weight，响应时间越长，weight越小，被选中的可能性越低
         4. RetryRule 对选定的负载均衡策略机上重试机制
         5. RoundRobinRule 轮询选择server
         6. RandomRule 随机选择一个server
         7. ZoneAvoidanceRule 复合判断server所在区域的性能和server的可用性选择server
      14. zuul 的作用和功能
         - https://blog.csdn.net/zzzgd_666/article/details/83314833
         - 路由：是网关的基本模块：它由id，目标uri，一系列的断言和过滤器组成，如果断言为 true 则匹配该路由
            - after,before,between,cookie,header,host,method,path,query 等（after, before,between 是指的时间）
         - 断言：匹配 http 中的所有信息，匹配则通过
         - 过滤：可以在请求被路由前和后进行修改
      15. 缓存：穿透，击穿，雪崩
      16. Eureka 和 zookeeper 区别
         - zookeeper 选举原理（选举如果是偶数会出现什么情况）            # ?????
         - Eureka 是实现 AP，而 zookeeper 是实现 CP。eureka 同步会在以以最新时间的数据进行同步；zookeeper 是把数据下发到 slover，期间会阻塞
      17. volatile 关键字原理
      18. 布隆过滤器和缓存穿透，击穿，崩溃 解决方案
      19. 数据库的索引检索学习 和 redis集群的搭建原理                    # 已解决
      21. Red Lock 解决 redis 集群写分布式锁的问题
         - 在不对锁续命的情况下，任务执行完毕马上调用 DEL 删除锁，此时由于key的生命周期到了提前被系统删了，另一个线程来获取锁，刚好在任务删除锁之前获取到了锁，然而任务删除锁会把刚刚获取锁的那个锁给误删掉
         1. 准备几台独立非集群的redis服务（假设5台）
         2. 向5台服务拿锁，使用相同的key和具有唯一性的value（例如UUID），获取锁，当获取锁时应该设一个超时时间（超时时间应该小于存储锁的过期时间，超时时间是请求5个服务得到结果的总的时间）
         3. 在没有超时情况下，至少获取到3台服务的锁才可以进一步处理；如果整个获取时间为 t2，锁的过期时间为 t1，只有 t2 < t1 才能进一步处理
            - 如果在获取锁中途，获取到锁的个数没有 3 台 或 获取锁的总时间超时，都应该作解锁操作（防止某个节点获取到了锁，但是请求获取锁的客户端总的获取锁时间超时，而引起的一段时间不能重新获取锁）
         4. 注意！！注意！！在解锁的情况，解锁代码需要有判断如果这把锁是当前机器加的才能解锁，否则解锁失败（需要写 lua 脚本）
      22. hash 和 一致性 hash 的区别

* 面试学习大纲
   - 大纲
      - redis 了解，集群，宕机，redis快照，选举
      - synchnonized 和 Lock 的区别
      - 悲观锁和乐观锁 (O)
      - sql索引和优化
      - spring 五大组件
      - zookeeper 原理
      - mybatis 原理了解
      - db 原理了解
      - spring Cloud 教程了解
      - elasticsearch 原理了解
   - 内容详解
      1. [  ] Spring Bean 注入过程
      2. [完成] Java8 新特性：Stream，数据结构优化，函数式表达
         1. Stream 原理
      3. [完成] Syncrhonized 和 Lock 的区别
         1. sync 是 jvm 层面的，会自动释放；Lock 是代码层面的，需要手动释放
         2. sync 默认是非公平的，公平指当一个线程释放锁后，其它的排队线程会根据等待时间最长的去获取锁，那么就叫公平锁（毕竟等待时间最长的肯定是最先等待的）
         3. ReentrantLock 获致锁的三种方法
            1. lock() 如果获取了锁立即返回，否则休眠等待直到获取到锁为止
            2. tryLock() 如果获取了锁立即返回 true，如果别的线程持有锁则返回 false
            3. tryLock(long timeout, TimeUnit unit) 如果获取了锁立即返回 true，如果别的线程正持有锁，会等待指定的时长，等待过程中获取了锁返回 true，超时则返回 false
      4. [  ] CAS 比较并交换
      5. [  ] 乐观锁应用
         1. 自旋，取锁慢，效率低，锁更新到成功为止
      6. [  ] 线程池
         1. 超max策略：丢弃新线程，抛弃常，丢弃队列里等待时间最长的任务，由调用者在调用者线程执行
      7. [  ] JVM调优
         1. OOM异常判断堆还是元空间里发生的异常，jump分析
      8. [完成] mysql 索引类型：Hash，B，B+
      9. [完成] 幂等性
         1. 通过消息队列保证可靠性，并以乐观锁保持幂等性（计数号）
      10. [  ] MySAM 与 InnoDB区别
         1. MySAM 是聚簇索引，直接指向数据，只有表锁
         2. InnoDB 是追溯索引，指向主主键索引，事务，行锁，redo log
      11. [完成] 一张表最多可以建16个索引
      12. [  ] redis
         1. redis 是异步非阻塞式的
         2. rewrite 和 初始化
         3. 持久化机制，RDB恢复到一个点，再由AOF追加命令
      13. [集群] 集群原理
      14. [完成] 缓存击穿和缓存穿透和缓存雪崩
         1. 缓存穿透：访问一个不存在的key，缓存不起作用而请求会直达DB
            1. 采用布隆过滤器或使用一个足够大的bitmap，用于存储可能访问的key，不存在的key直接被过滤
            2. 拦截器，id<=0的直接拦截
            3. 从cache和db都取不到，可以将key-value写为key-null，设置较短时间，如30秒（设置太长会导致正常情况也没法使用）
         2. 缓存击穿：一个存在的key，在缓存过期的一刻，同时有大量的请求，这些请求都会击穿到DB
            1. 设置热点数据永不过期
            2. 加互斥锁
         3. 缓存雪崩：大量的key设置了相同的过期时间，导致在缓存在同一时刻全部失效，造成瞬时DB请求量大，压力骤增，引起雪崩
            1. 和缓存击穿的区别是，击穿是查同一条数据查不到而直接查数据库，雪崩是多种不同的数据同时过期造成查询不同数据而直接请求数据库
            2. 缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生
            3. 如果缓存数据库是分布式部署，将热点数据均匀分布在不同搞得缓存数据库中
            4. 设置热点数据永远不过期
      15. [完成] Spring 的好处
         1. 是非侵入式的
      16. [  ] dubbo链路
      
      17. [完成] 几个概念
         1. 幂等性：重复消费多次结果都一样即不重样
         2. 一致性：a b 成功了，c必须成功，但 c 未成功，那么就没有了一致性
         3. 可用性：系统引入的外部组件越多越容易挂，为了保证正常的使用而需要可用性
         4. 可靠性传输：消息不丢失消费


--------------------------------------------------------------------------------------------------------------

* 主从节点的模式
   - 指定主节点模式
      - 该模式要求所有子节点指定自己的主节点，本身搭建的时候就老大就已经确认，所有的小弟只要承认老大的角色就可以成为一个集群。新节点加入，只需要承认集群中的老大即可。典型软件包括：elasticsearch，storm等。
   - 穷举子节点模式
      - 该模式在搭建集群之初，老大节点已经确认，同时需要列出集群中的所有小弟节点。在没有配置中心的情况下，新增小弟节点需要修改所有节点的配置，添加的新的小弟，扩展性较差。典型软件为hadoop的集群。
   - 集群自选举模式
      - 该模式搭建集群的时候节点具有对等性，由集群自己根据特定的共识算法（paxos，raft，bully），选举出集群的老大节点。集群搭建比较简单，但是老大节点宕机之后需要一定的时间选举出新的老大。典型软件包括：zookeeper，redis5，canssandra等。

* zookeeper 教程
   - https://www.cnblogs.com/51life/p/10265864.html


--------------------------------------------------------------------------------------------------------------


* 详解

   1. 悲观锁和乐观锁
      - 乐观锁
         - 定义
            - 认为修改的情况很少而读取多，所以只有在更新时才加以认证，用一个自增号表示，更新时进行比较自增号确认是否可以更新
      - 悲观锁
         - 定义
            - 认为修改的情况很多，所以在每次进入逻辑时都要加锁
         - 例子
            - 共享锁
               - 只有读取时才加锁，加锁后其它线程只有读取线程才可以进入逻辑，增删改都不能获取锁
            - 互斥锁
               - 进入逻辑就加锁，其它线程的增删改都不能获取锁

   2. redis 集群模式
      1. 主从模式：
         - 运行逻辑
            - 从服务器连接主服务器，发送sync命令；主服务器接收到命令后，开始执行bgsave命令生成rdb文件并使用缓冲区记录此后执行的所有写命令；
            - 主服务器bgsave执行执行完后，向所有从服务器发送快照文件，并在发送期间继续记录被执行的写命令
            - 从服务器收到快照文件后丢弃所有旧数据，载入收到的快照
            - 主服务器快照发送完毕后开始向从服务器发送缓冲区中的写命令
            - 从服务器完成对快照的载入，开始接收命令请求，并执行来自主服务器缓冲区的写命令（从服务器初始化完成）
            - 主服务器每执行一个写命令就会向从服务器发送相同写命令，从服务器接收并执行收到的写命令（从服务器初始化完成后的操作）
         - 优点
            - 支持主从复制，主机会自动将数据同步到从机，可以进行读写分离
            - 为了分载master的读操作压力，slave服务器可以为客户端提供只读操作的服务，写服务仍然必须由master来完成
            - slave同样可以接受其它slaves的连接和同步请求，这样可以有效的分载master的同步压力
            - master Server是以非阻塞的方式为slaves提供服务，所以在master-slave同步期间，客户端仍然可以提交查询或修改请求
            - slave Server同样是以非阻塞的方式完成数据同步，在同步期间，如果有客户端提交查询请求，redis则返回同步之前的数据
         - 缺点
            - redis 不具备自动容错和恢复功能，主机从机的宕机都会导致前端部分读写请求失败，需要等待机器重启或者手动切换前端的ip才能恢复
            - 主机宕机，宕机前有部分数据未能及时同步到从机，切换ip后还会引入数据不一致的问题，降低了系统的可用性
            - redis较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂

      2. 哨兵模式
         - 当主服务器中断服务后，可以将一个从服务器升级为主服务器，以便继续提供服务，但是这个过程需要人工手动来操作。为此，redis2.8中提供了哨兵工具实现自动化的系统监控和故障恢复功能
         - 哨兵的作用就是监控redis系统的运行状况，它的功能包括以下两个：
            1. 监控主服务器和从服务器是否正常运行
            2. 主服务器出现故障时自动将从服务器转换为主服务器
         - 工作方式：
            - 每个Sentinel（哨兵）进程以每秒钟一次的频率向整个集群中的master主服务器，slave从服务器以及其它sentinel进程发送一个ping命令
            - 如果一个实例距离最后一次有效回复ping命令的时间超过down-after-milliseconds选项所指定的值，则这个实例会被 sentinel 进程标记为主观下线（sdown）
            - 如果一个master主服务器被标记为主观下线（sdown），则正在监视这个master主服务器的所有sentinel 进程要以每秒一次的频率确认master主服务器的的确进入了主观下线状态
            - 当有足够数量的 sentinel 进程（大于等于配置文件指定的值）在指定的时间范围内确认 master 主服务器进入了主观下线状态，则 master 主服务器会被标记为客观下线（odown）
            - 在一般情况下，每个 sentinel 进程会以每 10 秒一次的频率向集群中的所有 master 主服务器，slave从服务器发送 info 命令
            - 当 master 主服务器被 sentinel 进程标记为客观下线时， sentinel 进程向下线的 master 主服务器的所有 slave 从服务器发送 info 命令的频率会从 10 秒一次改为每秒一次
            - 若没有足够数量的 sentnel 进程同意 master 主服务器下线，master主服务器的客观下线状态就会被移除，若master主服务器重新向 sentinel 进程发送 ping 命令返回有效回复，master主服务器的主观下线就会被移除
         - 优点：
            - 哨兵模式是基于主从模式，所有主从的优点，哨兵模式都具有
            - 主从可以自动切换，系统更健壮，可用性更高
         - 缺点：
            - redis较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂

      3. Redis-Cluster集群
         - redis的哨兵模式基本已经可以实现高可用，读写分离，但是在这种模式下每台redis服务器存储相同的数据，很浪费内存，所以在redis3.0上加入了cluster模块，实现的redis的分布式存储，也就是说每台redis节点上存储不同的内容
         - redis-cluster采用无中心结构，它的特点如下：
            1. 所有的redis节点彼此互联（ping-pong机制），内部使用二进制协议优化传输速度和带宽
            2. 节点的fail是通过集群中超过半数节点检测失效时才生效
            3. 客户端与redis节点直连，不需要中间代理层，客户端不需要连接集群所有节点，连接集群中任何一个可用节点即可
         - 工作方式：
            - 在redis的每一个节点上，都有这么两个东西，一个是插槽（slot），它的取值范围是：0-16383，还有一个就是cluster，可以理解为一个集群管理的插件
            - 当我们的存取的key到达的时候，redis会根据crc16的算法得出一个结果，然后把结果对 16384 求余数，这样每个key都会对应一个编号在0-16383之间的哈希槽，通过这个值，去找对应的插槽所对应的节点，然后直接自动中转到这个对应的节点上进行存取操作
            - 为了保证高可用，redis-cluster集群引入了主从模式，一个主节点对应一个或者多个从节点，当主节点宕机的时候，就会启用从节点。当其它主节点ping一个主节点A时，如果半数以上的主节点与A通信超时，那么认为主节点A宕机了，如果主节点A和它的从节点A1都宕机了，那么该集群就无法再提供服务了

      3.1. Redis-Cluster集群
         - 每个结点两两之间都有联系，每个节点至少有一个从节点，并且每个结点都存得有所有主节点和所有从节点的信息
         - 每个节点会两两ping信息保证通信，如果一半以上的节点确认某一个节点ping不通则认为那个节点宕机了，那么会连接它的从节点
         - 如果一个节点和它的所有从节点都挂了那么认为这个集群fail了，如果一半以上的主节点宕机了那么也认为这个集群fail了

   3. mysql 集群
      1. 主从
      2. 分区多活集群
         - 非共享数据的多活
            - 该情况下集群节点不能共享数据，每个节点负责不同的数据，比如将数据库表以主键ID进行划分，不同节点负责不同的区域，目前这种可以通过中间件实现，比如开源的Mycat
         - 共享存储多活集群

   4. zookeeper
      - 客户端要写数据，提交的申请如果不是 leader 则会转发到 leader，由 leader 广播到 follower，follower 写完后向 leader 汇报，如果肝半数写成功了则宣告成功
      - 选择过程（5台机器）
         - 服务器1启动，发起一次选举，服务器1投自己一票，此时服务器1票数1票，不够半数3票，选举无法完成，状态为 looking
         - 服务器2启动，再发起一次选举，与上面过程一样，服务器1和2先投自己一票，此时服务器1发现服务器2的id大，更改选票投给服务器2
            - 此时服务器1票数0票，服务器2票数2票，不够半数3票，选举失败，服务器1,2状态为 looking
         - 服务器3启动，发起一次选举，与上面过程一样 ，服务器1和2先投自己一票，然后因为服务器3的id最大，两者更改选票投给为服务器3
            - 此次投票结果：服务器1为0票，服务器2为0票，服务器3为3票。此时服务器3的票数已经超过半数3票，服务器3当选 Leader
            - 服务器1,2更改状态为 following，服务器3更改状态为 leading
         - 服务器4启动，发起一次选举，此时服务器1,2,3已经不是looking状态，不会更改选票信息，交换选票信息结果：
            - 服务器3为3票，服务器4为1票
            - 此时服务器4服从多数，更改选票信息为服务器3
            - 服务器4并更改状态为 following
         - 服务器5启动，同4一样投票给3,此时服务器3一共5票，服务器5为0票，服务器5并更改状态为 following
         - 最终 Leader 服务器3,状态为 leading，其余服务器是 follower，状态为 following





