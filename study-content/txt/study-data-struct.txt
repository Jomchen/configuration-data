数据结构
   - https://www.bilibili.com/video/BV1Ey4y1k7NS?p=245
   - 一开始 245 集
   - 实际学习 集

* 二叉树的教程
   - 讲师——陈越、何钦铭
   - 转自：中国大学MOOC——浙江大学频道
   - 大标题在评论区注意查看
   - 大家可以去中国大学MOOC里面去进行学习喔，有课件、也能和大家一起讨论学习。
   - 不过中国大学MOOC后面有些习题所在的章节的位置应该是不太对的，所以我自行调整了下视频顺序，使得习题对应章节，希望不影响大家的观看，当然如果存在问题请评论区留言让我修改回来。
   - 如果视频存在问题请在留言区回复我。

* 尚硅谷 韩顺平数据结构

* 一些地址
   - B树 和 B+树的插入和删除
      - https://blog.csdn.net/weixin_30314793/article/details/95778533?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.add_param_isCf&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.add_param_isCf
   - 红黑树
      - https://www.cnblogs.com/nullzx/p/6111175.html
   - 数据结构的在线生成过程
      - http://520it.com/binarytrees/
      - https://www.cs.usfca.edu/~galles/visualization/Algorithms.html
      - https://www.cnblogs.com/mjios/p/10627814.html#toc_title_1

* 树
   - 顺序存储二叉树的概念
      - 从数据存储来看, 数组存储方式和树的存储方式可以互转换, 即数组可以转换成树, 树也可以转换万民数组
      - 二叉树的公式
         - 对于一个满二叉树第 n 层的元素个数为 1*(2^n-1) => 2^n-1
         - 所以前 n 层的元素个数总计为：1 + 2^1 + 2^2 + 2^3 + ... + 2^n-1
         - 通过等比数列公式 a1(1 - q^n)/(1-q) => (1 - 2^n)/(1 - 2) => (1 - 2^n)/-1 => 2^n - 1
      - 顺序存储只考虑完全二叉树的情况
         - 第n个元素的左子节点为 2n+1
         - 第n个元素的右子节点为 2(n+1)=2n+2
         - 第n个元素的父节点为 (n-1)/2
         - 这里的 n 指节点的索引(从0开始计算)
      - 并且这个数组的存值必须是按层从左到右地存储起来的
      - 例子
         ```
                  1
                 / \
                2   3
               / \ / \
              4  5 6  7

         array数组为:              {1,2,3,4,5,6,7}
         array对应的索引n对应是:    0,1,2,3,4,5,6
         要求传入一个数组, 对这个数组进行 先中后序的遍历
            - 由于可以得到根
            - 那么可以根据根的索引号, 得到左, 右节点的索引号(注意不要索引越界)
            - 依此类推地递归进行打印输出
         ```
   - 线索化二叉树
      - n个结点的二叉链表中含有 n+1 [公式: 2n-(n-1)] 个空指针域, 利用这些空指针域用来指向某种遍历方式在本节点的前驱或后继节点, 这种附加的指针叫“线索”
         - 这种加上了线索的二叉鍡称为线索链表, 这样的二叉树可以分为: 前序线索线索, 中序线索二叉树, 后序线索二叉树

   - 二叉树
      - 一些通用公式
         - 在二叉树的第N层上最少有 2^(N-1) 个结点, 最多 2^N-1 个结点个数
         - 满二叉树: 假设树的深度为 M, 其有 2^M-1 个节点的二叉树
         - 二叉树的高度:
            ```
            public int height() {
                return Math.max(left == null ? 0 : this.left.height(), right == null ? 0 : this.right.height()) + 1;
            }
            ```
   
      - 二叉树的一些类别
         - 一般二叉树
         - 二叉查找树
         - 真二叉树（所有节点的度要么为0要么为2,即有左子节点和右子节点）
         - 满二叉树
         - 完全二叉树
         - 平衡二叉树（AVL）
         - 红黑树
         - 哈夫曼树/霍夫曼树/最优二叉树
   
      - 一般树 和 二叉树 之间的转换
         - ?
      - 一般二叉树
         - 每个节点最多有两个子节点
      - 满二叉树
         - 每个非叶子节点有两个子节点，且同层节点已经满了
         ```
              A
             / \
            B   C
           / \ / \
          D  E F  G
         ```
      - 完满二叉树
         - 非叶子节点的节点一定有两个子树????
      - 完全二叉树
         - 如果只是删除了满二叉树最底层最右边的连续若干个节点，这样形成二叉树就是完全二叉树
         - 例子
            - 删除只能是从 G -> F -> E -> D -> C -> B -> A 的顺序删除，即满足最底层最右边的连续若干个节点删除
            ```
                 A
                /\
               B  C
              /\ /\
             D E F G
            ```
      - 平衡二叉树
      - 红黑树
         - 时间复杂度为 logN
         - 定义
            1. 每个节点非黑即红
            2. 根节点和叶子节点一定是黑色(这里的叶子节点是指左右指针都为空的那个 左和右的指针)
            4. 红色节点的子节点一定是黑色节点
            5. 从节点到任意的后代节点路径中所包含的黑色数一定相等
         - 当插入了一个节点后, 要旋转和变色规则
            1. 变颜色: 当前结点的父亲是红色, 且它的祖父结点的另一个结点也是红色(叔叔节点)
               1. 把父亲节点设为黑色
               2. 把叔叔也设成黑色
               3. 把祖父也就是父亲的父亲设为红色
               4. 把指针定义到祖父结点, 表示当前要操作的节点, 再从操作节点往上调整
            2. 左旋: 当前父结点是红色, 叔叔是黑色的时候, 且当前的结点是右子树(是父元素的右子树), 左旋以父结点作为左旋
            3. 右旋: 当前父结点是红色, 叔叔是黑色的时候, 且当前的结点是左子树(是父元素的左子树), 右旋
               1. 把父结点变为黑色
               2. 把祖父结点变为红色(爷爷)
               3. 以祖父结点旋转(爷爷)TreeMap JDK1.8
            4. 例子
            ```
               * 表示黑色节点, o 表示红色节点
                     *19                           *19    
                     / \                           /  \
                   o5   *30                      o5   *30 
                   /\    \                       / \    \ 
                 *1  *12  o35                  *1           
                     /\                               
                    o7 o13                               
                   /                               
                  o6                               
            ```
   
      - 哈夫曼树(最优二叉树)
   
      - 最大堆，最小堆
         - 是用完全二叉树来表示的一种情况，而且，
         - 任意一个节点是其子树中的最大值（最大堆）
         - 任意一个节点是其子树中的最小值（最小堆）

   - B树(多路查找树): 
      - 概念
         - 一个 m 阶的 B 树具有如下属性
            - ?每一个非根的分支结点都有 k-1 个元素（关键字）和 k 个孩子，其中 k 满足：Ceil(m/2) <= k <= m?

            - 概念1
               - 树中每个节点最多含有 m 个孩子节点
               - 如果是根节点且不是叶子节点则至少 2 个孩子
               - 如果是非根非叶子节点至少 Ceil(m/2) 个子节点
               - 有 n(Ceil(m/2)<=n<=m) 个分支的结点有 n-1 个关键字，它们按递增顺序排列 k=2（根节点）或 Ceil(m/2)（非根节点）
               - 所有叶子结点都位于同一层次
               - 每个非叶子节点包含 n 个关键字信息（n,p0,p1,...pn,k1,k2,...kn）
                     - 其中 k 为关键字，且 关键字升序
                     - p 为指向子节点的指针
                     - 有 n 个关键字的父节点，拥有 n+1 个子节点（类似于 n 个数划分成了 n+1 个数据范围）
            - 概念2
               - 非根节点关键字个数范围 n 为：Ceil(m/2) - 1 <= n <= m-1
               - 根节点关键字个数范围 n 为：1 <= n <= m-1
               - 非叶子节点，要么指针全都为 NULL，要么指针都是满的
         - 对阶的认识
            - 往往一个阶被定为计算机的磁盘页码, 比如4k(4k对其)
            - B树的阶: 节点的最多子节点个数, 比如 2-3 树的阶是3, 2-3-4 的阶是 4
            - 阶的公式
               1. 假若一个 B树的阶为 m(m必须是 m>=2), 则一个节点最多有 m 颗子树, 且数据域最多 m-1 个(也称为关键字)
               2. 除根节点和叶子结点外, 其它每个结点至少有 ceil(m/2)个节点, 即若 m=5, Ceil(5/2)=3
         - 2-3 树特性
            1. 2-3 树的所有叶子节点都在同一层(只要是B树都满足这个条件)
            2. 有两个子节点的节点叫二节点, 二节点要么没有子节点, 要么有两个子节点
            3. 有三个子节点的节点叫三节点, 三邼要么没有子节点, 要么有三个子节点
            4. 2-3树是由二节点和三节点构成的树
            5. 2-3-4树同理推论

         - B树的属性
            - B树的关键字往往可以拿来作为索引
            - 如果根结点不是叶结点, 则其至少有两棵子树, 每一个非根的分支结点都有 K-1 个元素(关键字, 或数据域)和K个孩子, 其中K 满足 Ceil(m/2) <= K <= m 
               - 例如 Ceil(5/2) = 3
            - 所有叶子结点都位于同一层次
            - 每一个分支结点包含下列信息数据:
               - n, P0,K1,P1,P2,A2,P3,A3,...
               - n 表示当前这个节点有多少个关键字
               - 其中 K 为关键字, 且 Ki < Ki+1
               - pi 为指向子树根结点的指针

      - 类型
         1. B-Tree(B-树)
         2. B+Tree(B+树)
         3. B*Tree(B*树)
      - B-Tree
         - 说明
            1. 结点最多含有 m 颗子树(指针), m-1 个关键字(存的数据, 空间) (m >=2 )
            2. m 也即“阶” 除根节点和叶子结点外, 其它每个结点至少有 ceil(m/2) 个节点, ceil为向上取整
               - 例: 一个5阶(一个磁盘空间最多5个指针, 4个关键字) B-Tree Ceil(5/2)=(2.5)3 即等于3; Ceil(3/2)=(1.5)2 即等于2
            3. 若根节点不是节点, 则至少有两颗子树
         - 例子
            ```
            创建一个 5 阶的 Btree, 插入的数据有 3 14 7 1 8 5 11 17 13 6 23 12 20 26 4 16 18 24 25 19
            根据 Btree 特性, 5阶则一个磁盘空间最多有五个指针(存的查找路径), 4 个关键字(mysql存的数据) 那么具体的插入如下所示
            ```

      - B+Tree
         - 概念
            1. B+树 是 B树 的变体
            2. 每个节点最多有 m 个子节点
            3. 除根节点外, 每个节点至少有 m/2 个子节点
            4. 根节点要么是空, 要么是独根, 否则至少有2个子节点
            5. 有 k 个子节点的指针必有 k 个关键码(注意)
            6. 叶子节点的高度一致
            7. 按关键字个数等于子节点数的形式算的话
               - 非根节点关键字个数 n 的范围为 Ceil(m/2) <= n <= m
               - 根节点关键字个数 n 的范围为 2 <= n <= m
         - 概念2
            1. B+树的搜索与B树也基本相同, 区别是B+树只有达到叶子结点才命中(B树可以在非叶子结点命中), 其性能也等价于在关键字全集做一次无恶不作好查找
            2. 所有关键字都出现在叶子结点的链表中(即数据只能在叶子节点[也叫稠密索引]), 且链表中的关键字(数据)恰好是有序的
            3. 不可能在非叶子节点命中
            4. 非叶子结点相当于是叶子结点的索引(稀疏索引), 叶子结点相当于是存储(关键字)数据的数据层
            5. 更适合文件索引系统
            6. B树和B+树各有自己的应用场景, 不能说B+树完全比B树好, 反之亦然 

      - B*Tree
         - 概念
            1. B*树 是 B+树 的变体, 在B+树的非根结点 和非叶子结点再增加指向兄弟的指针
            2. B*树定义了非叶子结点关键字个数至少为(2/3)*m, 即块的最低使用率为2/3, 而B+树的块的最低使用率为B+树的1/2
            3. 从第1个特点我们可以看出, B*树分配新结点的概率比B+树要低, 空间使用率更高



************** 进度 58 集

* 图
   - 一些概念和关键名词
      - 一些概念
         - G(V,E) 图
         - V(Vertex)顶点
         - E(Edge)边
      - 图 G=(V,E), 如果边 (v1,v2) 属于 E, 则称顶点V1和V2互为邻接点, 即v1和v2相邻接
      - 边/弧: 两个顶点之间的邻接连线
         - 边: 如果 v1 和 v2 之间的邻接线是无向的则可以记为 (v1,v2) 或 (v2,v1)
         - 弧: 如果由 v1 指向 v2 则记为 <v1,v2>, v1是弧尾, v2是弧头, 不能写为 <v2,v1>
      - 无向图/有向图: 顶点和弧组成的图称为有向图, 顶点和边组成的图称为无向图, 边和弧不能同时存在
      - 度(Dgree): 某个顶点相关的邻接线条数表示某个顶点的度 TD
         - 入度: 以某个顶点作为弧头的条数
         - 出度: 以某个顶点作为弧尾的条数
         - 某个顶点的度 = 某个顶点的入度 + 某个顶点的出度
         - TD(V) = ID(V) + OD(V)
      - 权(Weight): 由一条边或弧表示的一个值表示这条边或弧的业务意义
      - 网络: 带得有权的图可以称为网络

   - 一些名词

      - 连通: 从v 到 w 存在一条(无向)路径, 则称 v 和 w 是连通的(注意有没有方向)
      - 路径: v到w的路径是一系列顶点{v,v1,v2,v3,...vn,w}的集合, 其中任一对相邻的顶点间都有图中的边;
         - 路径长度: 是路径中的边数(如果带权, 则是所有边的权重值之和)
         - 则称简单路径: 如果v到w之间的所有顶点都不同
         - 不简单路径: 如果v到w之间有超过一个顶点重复
         - 回路: 起点等于终点的路径
         - 连通图: 图中任意两顶点均连通

      - 连通分量: 无向图的极大连通子图
         - 极大顶点数: 再加1个顶点就不连通了
         - 极大边数: 包含子图中所有顶点相连的所有边

      - 对于有向图
         - 强连通: 有向图中顶点v和w之间存在双向路径, 则称v和w是强连通的
         - 强连通图: 有向图中任意两顶点均强连通
         - 弱连通的: 把方向去掉变成无向图, 只保留线而没有箭头, 可以达到连通的情况称为弱连通
         - 强连通分量: 有向图的极大强连通子图
      - 其它
         - 所谓的一个连通图的生成树是一个极小的连通子图, 它含有图中全部的n个顶点, 但只有足以构成一棵树的n-1条边
         - 如果一个有向图恰有一个顶点入度为0, 其余顶点的入度均为1, 则是一棵有向树

   - 存储和算法
      1. 邻接矩阵
         - 用一个集合存储所有的顶点, 一个二维数组存放弧或边
         - 例子
            ```
            *********************
            |   | A | B | C | D |
            *********************
            | A | 0 | 1 | 0 | 1 |
            *********************
            | B | 1 | 0 | 0 | 1 |
            *********************
            | C | 0 | 0 | 0 | 1 |
            *********************
            | D | 1 | 1 | 1 | 0 |
            *********************
            ```
      2. 邻接表/逆邻接表
         - 适用于无序图
         - 一个数组或单链表存储顶点A, 每一个元素指向一个链表的第一个元素, 这个链表表示A的所有入度或出度
         - 如果是一个无向图, 则可以存储与A相关的边
         - 如果是一个有向图, 
            - 存储的全是以A为弧尾的顶点(邻接表)
            - 存储的全是以A为弧头的顶点(逆邻接表)
            - 如果弧是带权值的情况, 则在链表的每个元素可以有一个数据域用以存储权值
         - 例子
            ```
            下例的 N 表示 NULL, I 表示一个指针
            由两部分数据组成
                1. 下标, data, index 分别表示:顶点的主键, 顶点的值, 顶点相关的 入度/出度 构成链表的第一个元素的指针
                2. 顶点的主键, 指向下一个元素的指针
            下标    data    index
            0       v0          I------->(3 N)
            1       v1          I------->(0 I)-->(2 N)
            2       v2          I------->(0 I)-->(1 N)
            3       v3          N
        
            ```
      3. 十字链表(对边表结构的优化)
         - 适用于有序图
         - 作用其实和邻接表是一样的, 只不过对于节点来说, 有两个字段(一个表示入度的链表, 一个表示出度的链表)
         - 在有向图中, 十字链表是非常好的存储方式, 但是这对于关心顶点有优势, 如果是对边或弧的操作则不适用
         - 例子
            ```
            - 下例的 N 表示 NULL, 下例的 x 表示线的转折, 下例的 I 表示一个指针
            - 由两部分数据组成
               1. 主键, data, 入度链表指针, 出度链表指针
               2. (tailVex, headVex, headLink, tailLink) 的模式: X节点相关弧尾节点主键, X节点相关弧头节点主键, 下一个X节点作为弧尾的弧的指针, 下一个X节点作为弧头的弧的指针(这四个数据为一条弧)
                  1. 最后两个值为指针，指向的是另一个根弧的节点
               下标    data    headLink    tailLink    |************************
                                                       v                       |
               0       v0            I*      I-------->(0 3 N N)               |
                                       \                                       |
                                        *********************                  |
                                                            *                  |
                                                            v                  |
               1       v1            I       I-------->(1 0 I I----->(1 2 N N) |
                                      \                     |        ^         |
                                       \                    |        |         |
                                        *******************\|/********         |
                                                            x                  |
                                                           /|\                 |
                                        ******************* | ********         |
                                       /                |****        |         |
                                      /                 v            v         |
               2       v2            I       I-------->(2 0 N I----->(2 1 N N) |
                                                                               |
                                      /*****************************************
               3       v3            I       N                            
                                                                     
            ```
         - 决窍
            - headLink 是以 headVex 为弧头的指针, 一直指向headVex为弧头 且headLink不为空, 直到指向唯一一个headVex为弧头 且 headLink 为空的弧节点
            - tailLink 是以 tailVex 为弧尾的指针, 一直指向tailVex为弧尾 且tailLink不为空, 直到指向唯一一个tailVex为弧尾 且 tailLink 为空的弧节点

      4. 邻接多重表(对边表结构的优化)
         - 适用无序图
         - 例子
            ```
            iVex    iLink    jVex    jLink
            iVex 和 iLink 是某条边的依附的两个顶点在顶点表中的下标
            iLink 指向依附顶点 iVex 的下一条边, jLink 指向依附顶点 jVex 的下一条边
            ```
      5. 边集数组
         - 边集数组是由两个一维数组构成, 一个是存储顶点的信息, 另一个是存储边的信息, 这个边数组每个数据元素由 一条边的起点下标, 终点下标, 权组成
         - 即有多少条边那么记录边的数组的元素个数就有有多长(边包含: begin, end, weght)

   - 骑士周游
      - 对于  n*n 的棋盘上, 当 n >= 5 并且为偶数时, 任意一点以国际象棋的“马”的走法可以走完图中的所有点
      - 例子
         ```
         如果一起点是“O”, 那么可以走的位置有: B D K W 2 Z S G
         ABCDEF
         GHIJKL
         MNOPQR
         STUVWX
         YZ1234
        
         ```
      - 哈密尔顿路径
         - 图G中的哈密尔顿路径指的是经过图G中每个顶点, 且只经过一次的一条轨迹. 如果这条轨迹是一条闭合的路径(从起点
         - 出发不重复地遍历所有点后仍能回到起始点), 那么这条路径称为哈密尔顿回路

   - 最小生成树
      - 给定一个无向图
      - 生成树中任加一条边都一定构成回路
      - 最小生成树存在的话, 那么图一定连通的; 图如果是连通的, 那么一定可以找到一颗最小生成树
      - 什么是一颗树
         - 无回路
         - |v| 个顶点一定有 |v| - 1 条边
      - 什么是生成树
         - 包含全部顶点
         - |v| - 1 条边都在图里
      - 最小生成树的约束
         1. 只能用在图里有的边
         2. 只能最多用掉 v - 1 条边
         3. 不能有回路
      - 算法
         - 普里姆算法
         - 克鲁斯卡尔算法
            - 终点是指 已经加入最小生成树的顶点按业务情况决定顶点从大到小的最小顶点或按从小到大的最大顶点
            - 把权值按从大到小或从大到小进行排序
            - 加入的两个顶点在已经加入的最小生成树中的终点不能是同一个终点, 否则会形成回路
   - 最小路径
      - 迪杰斯特拉算法

* 贪心算法
   - 概念
      - 有几组分组数据{A,B,C,D..Z}, 每一组数据包含几个元素, 用算法算出能够包含所有元素的 分组组合
      - 贪心算法算出的可能不一定是最优的, 但是一定能够完成结果
   - 实现例子
      ```
      要求算出包含所有地区的 分组组合

      分组        元素
      A           北京, 上海, 天津
      B           广州, 天津, 深圳
      C           成都, 上海, 杭州
      D           天津, 上海
      E           杭州, 大连

      1. 找出所有元素形成二个集合 allList={北京,上海,天津,广州,深圳,成都,杭州,大连}, resultList={}
      2. 有两个指针 maxKey, key
      3. 以下所有的逻辑都是从 A~E 的遍历
      4. maxKey 指针遍历 A~E
         1. 找出数量最多的组放入结果集 resultList={A}
         2. 并且这个组中的元素在allList中删除 allList={广州,深圳,成都,杭州,大连}
      5. key 遍历指针遍历 A~E
         1. 找出组中元素在 allList 中包含数量最多的组(如果数量一样则选位置靠前的组), 直到 allList 为空为止
         2. 把这个组放入 resultList 中
         3. 把这个组的元素在 allList 中删除

      
      实现过程
         一 选B => allList={成都,杭州,大连}, resultList={A,B}
            分组-不包含个数
            A-0, B-2, C-2g, D-0g, E-2g         
         二 选C => allList={大连}, resultList={A,B,C}
            分组-不包含个数
            A-0, B-0, C-2, D-0, E-2 
         三 选E => allList={}, resultList={A,B,C,E}
            分组-不包含个数
            A-0, B-0, C-0, D-0, E-1
      ```

* 背包问题
   - 有几个物品, 每个物品有一定的价值重量, 有一个背包有最大的承重量, 要求怎么背可以让背包装满最大的价值且不会超重
      - 01背包(不允许放重复的物品)
      - 重复背包(允许放重复的物品)


* 未解决的问题
   - 八皇后问题
   - 魔术师发牌问题
   - 背包问题
   - 图的最小生成树的两种算法,最短路径的算法
   - B树 和 B+树的 删除节点算法


* 未解决的问题
   - 删除关键字 key
      - key 所在节点是 叶子节点
         1. 删除之前，当前节点关键字数量 大于 Ceil(m/2) - 1，直接删除关键字，不会破坏 B 树结构
         2. 删除之前，当前节点关键字数量 等于 Ceil(m/2) - 1，左右兄弟节点中如果有关键字数量大于 Ceil(m/2) - 1 的
            - 如果有满足条件的，找满足条件的一个兄弟节点进行处理（注意当前节点和兄弟节点之前的关键字假设为 KEY）
            - 选中的兄弟节点是 KEY 所在节点的左子树，则取兄弟节点的最大值关键字 key2
            - 选中的兄弟节点是 KEY 所在节点的右子树，则取兄弟节点的最小值关键字 key2
            - KEY 放在 key 所在位置，key2 复制到原来 KEY 位置，删除 key2 原来位置的关键字
         3. 删除之前，当前节点关键字数量 等于 Ceil(m/2) - 1，左右兄弟节点不存在关键字数量大于 Ceil(m/2) - 1 的节点
            - 删除关键字key，兄弟节点的关键字和夹在中间的 KEY 合并
      - key 所在节点是 非叶子节点
         - 找出 key 关键字所在结点的左后继或右后继关键字，即相邻指针递归找关键字（左边递归找左子树的最大值关键字，右边则找最小的），找到了 key2
         - key2 复制到 key 位置，删除 key2 原来的位置的关键字 key2
         - 注意！！由找出的关键字替换掉要删除的关键字的位置，然后删除后继关键字原来位置的关键字，相当于触发了叶子节点的删除情况




红黑树错误资料
https://segmentfault.com/a/1190000012728513
https://blog.csdn.net/ChinaLeeSunnyBoy/article/details/79525456
https://www.cnblogs.com/CarpenterLee/p/5525688.html
