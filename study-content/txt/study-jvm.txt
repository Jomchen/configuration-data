* 源码安装
  - 46 ~ 58 页讲源码安装所需要的组件
  - 93 附近的垃圾回收算法

* 概念
  - JDK：java 程序设计语言，java 虚拟机，java API 类库 这三部分统称为 JDK（Java Development Kit），JDK 是用于支持 Java 程序开发的最小环境
  - JRE：Java API 类库中的 Java SE API 子集 和 Java 虚拟机 这两部分统称为 JRE（Java Runtime Environment），JRE 是支持 Java 程序运行的标准环境

* jvm学习工具
   - JDK 命令行
   - Eclipse Memory Analyzer # 内存映像分析工具
   - Jconsole 调试工具，可以看到许多线程在运行，但是不包括 public static void main 和 它所创建的线程
   - Jprofiler
      - IDEA 可插件安装
   - Java Flight Recorder
   - JClassLib # Java 反编译工具
      - IDEA 可插件安装
   - Java 日志分析工具
      - GC Easy
      - GCViewer
      - GCHisto
      - GCLogViewer
      - Hpjmeter
      - garbagecat

* 性能监控与故障处理工具
   - jps # JVM Process Status Tool 显示指定系统内所有的 HotSpot 虚拟机进程
      - q 只输出 LVMID，省略主类的名称
      - -m 输出虚拟机进程启动时传递给主类 main() 函数的参数
      - -l 输出主类的全名，如果是进程执行的是 jar 包，输出 jar 路径
      - -v 输出虚拟机进程启动时 JVM 参数
   - jstat # JVM Statistics Monitoring Tool，用于收集HotSpot 虚拟机各方面的运行数据
      - jstat -gc java进程号 # 查看内存使用情况
   - jinfo # Configuration Info for Java 显示虚拟机配置信息
      - jinfo -flag 配置参数 进程号 # 显示相应进程是否使用了相应的参数设置
      - jinfo -flag SurvivorRatio 进程号 # 显示相应进程的幸存者配置
   - jmap # Memory Map for Java，生成虚拟机的内存转储快照（heapdump 文件）
   - jhat # JVM Heap Dump Browser，用于分析 heapdump 文件，它会建立一个 HTTP/HTML 服务器，让用户可以在浏览器上查看分析结果
   - jstack Stack Trace for Java，显示虚拟机的线程快照
* 代码和参数细节
   - -Xmx 堆最大值
   - -Xms 堆最小值
   - -Xoss 本地方法栈大小
   - -Xss 每个线程分配的内存大小
   - -XX:HeapDumpOnOutOfMemoryError 可以让虚拟机在出现内存溢出异常时Dump 出当前的内存堆转储快照以便事后进行分析
   - -XX:PermSize 和 -XX:MaxPermSize 限制方法区大小
   - -XX:+PrintGCDetails      # 可以把程序运行的堆信息打印出来





* 运行时数据区域
  - 运行时数据区
     - 方法区(*)，堆(*)，虚拟机栈，本地方法栈，程序计数器
     - 执行引擎(*)，本地库接口(*)
     - 注意，有“*” 的是由所有线程共享的数据区，没有“*”的是线程隔离的数据区

  - 区域解释
     1. 程序计数器：是一块较小的内存空间，看作是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条要执行的字节码指令，分支，循环，跳转，异常处理，线程恢复基础功能等
        - 线程私有，由于任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）都只会执行一条线程，因为每个线程应该有自己的独立计数器互不影响，我们称这类内存区域为“线程私有”的内存
        - 如果正在执行 Native 方法，这个计数器值则为空（Undefined），此内在区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError的情况的区域

     2. Java虚拟机栈：也是私有的，Java 内存区分为 堆内存和栈内存 的说法是比较粗糙的
        - 线程私有，虚拟机栈是局部变量表部分，存放了基本数据类型，指针地址，一个代表对象的句柄或其他与此对象相关的位置
        - 在 Java 虚拟机规范中，对这个区域规定了两种异常状况
           - 如果线程请求的栈深度大于虚拟机所允许的深度，将抛出 StackOverflowError 异常
           - 如果虚拟机栈可以动态扩展（大部分虚拟机都可以扩展），只不过Java虚拟机规范中也允许固定长度的虚拟机栈，如果扩展无法申请到足够内存，就会抛出 OutOfMemoryError
     3. 本地方法栈
        - 线程私有，与虚拟机栈的作用相似，但是区别不过是虚拟机栈为虚拟机执行 java 方法服务（也就是字节码），而本地方法栈则为虚拟机使用到的 Native 方法服务
        - 本地方法栈也会抛出 StackOverflowError 和 OutOfMemoryError 异常
     4. Java 堆
        - 线程共享，是Java虚拟机所管理的内存中最大的一块，被所有线程共享的一块的内存区域，目的是存放对象实例，几乎所有的对象实例都在这里
        - java堆是垃圾收集器管理的主要区域，因此很多时候也被称做 GC堆(Garbage Collected Heap)
        - java堆中可以细分为：新生代和老年代
        - 可以是固定大小也可以是可扩展的，一般主流虚拟机都可以扩展，通过 -Xmx 和 -Xms 控制，如果堆中没有内存完成实例分配，并且堆也无法再扩展时，抛出 OutOfMemoryError
     5. 方法区（java8 里改为了 metaSpace）
        - 线程共享，与java堆一样，是各个线程共享的内存区域，用于存储被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据。
        - 虽然它它被java虚拟机规范把方法区描述为堆一个逻辑部分，但是它有一个别名叫做 Non-Heap（非堆），目的是与java堆区分开来
        - 虽然开发团队把GC分代收集扩展至方法区，但是方法区并不是永久代，只是为了方便管理，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常
     6. 特殊区域
        - 运行时常量池（在 方法区/metaSpace 里）
           - 是方法区的一部分，Class文件中除了有类的版本，字段，方法，接口等描述信息外，还有一项信息是常量池(Constant Pool Table)，用于存放编译期生成的各种字面量和符号引用，这部分内在将在类加载后进入方法区的运行时常量池中存放
           - 并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新掋常量放入池中，这种特性被开发人员利用得比较多的便是String类的intern()方法
           - 当常量池无法再申请到内存时会抛出OutOfMemoryError
           - jdk6及之前是在方法区中；jdk7，jdk8是在堆中
        - 直接内存
           - 并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError
           - NIO引入也一种通道与缓总目区的I/O方式，可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作，可以避免在Java堆和Native堆中来回复制数据
           - 显然，本机直接内存的分配不会受到java堆大小限制，但是，既然是内存，肯定还是会受到总内存大小以及处理器寻址空间的限制

  - 区别和注意
     - 对象
        - 在创建对象时，会在堆中分配空闲内存
           - 如果空闲内存和非空闲内存是规整的，空闲在一边，非空闲在另一边，指针在中间，分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离，这称为 “指针碰撞”
              - Serial,ParNew 等带 Compact 过程的收集器时，系统采用分配算法是指针碰撞
           - 如果空闲内存和非空闲内存不是规整的，那么虚拟机必须维护一张列表，记录哪些内存空闲，分配时更新记录
              - 而使用 CMS 这种基于 Mark-Sweep 算法的收集器时，通常采用空闲列表
           - 分配内存时可能受线程安全影响，解决方案一般是：1. CAS 朽上失败重试保证原子性；2. 预先为线程分配一块小的内存，称为本地线程分配缓冲（Thread Local Allocation Buffer,TLAB)
        - 对象的内存布局：对象在内存中存储的布局可以分为3块区域：对象头，实例数据，对齐填充（对固定内存要求不足补其）
           - 对象头中存放：对象哈希码，对象分代年龄，指向锁记录的指针，指向重级锁的指针，空，不需要记录信息，偏向线程id，偏向时间戳，对象分代年龄
        - 内存泄露和内存溢出
           - 内存泄露是指垃圾收集器无法自动回收它们，可以查看泄露对象到GC Roots的引用链，就能找到泄露对象是通过怎样的路径与GC Roots相关联并导致垃圾收集器无法自动回收它们
           - 内存溢出是指内存中的对象都确实还活着，只是堆不能再申请和扩展内存了，可以从代码中检查是否存在某些对象生命周期过长，持有状态时间过长的情况，应当检查虚拟机的堆参数（-Xmx与-Xms），与机器物理内存对比看是否可以调大
     - 虚拟机栈和本地方法栈
        - java 虚拟机不区分虚拟机栈和本地方法栈，对于 HotSpot来说，虽然-Xoss参数存在，实际无效，栈容量只由 -Xss参数设定
        - 如果线程请求的栈尝试大于虚拟机所允许的最大深度，将抛出StackOverflowError
        - 如果虚拟机在扩展栈时无法申请足够的内存空间，则抛出 OutOfMemoryError
        - 引起两种异常皆由于内存不够所引起的不同情况
     - 方法区和运行时常量池溢出
     - 本机直接内存溢出
        - DirectMemory 容量可以通过-XX:MaxDirectMemorySize指定，如果不指定，则默认与java堆最大值(-Xmx指定)一样
        - DirectMemory 导致的内存溢出，一个明显的特征是在 Heap Dump 文件中不会看见明显的异常，如果发现OOM之后Dump文件很小，而程序中又直接或间接使用了NIO，那就可以考虑检查一下是不是这方面的原因
     
* 垃圾收集区与内存分配
   - 判断对象是否已死
      1. 引用计数算法：给对象添加一个计数器，有一个地方引用它时，计数器值加1,当引用失效时，计数器值减1，任何计数器为0的对象就是不可能再被使用的
         - 很难解决对象之间相互循环引用的问题，假如 A 有属性 b，B 有属性 a，相互引用，即使在主线程中把 a 和 b 都置为空，但因为互相引用了，所以计数器两者都不为0，无法回收
      2. 可达性分析算法
         - 通过一系列称为 GC Roots 的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连（就是从 GC Roots到这个对象不可达）时，证明此对象不可用
            ```
                object5,6,7 是不可达，都可回收
                GC Roots
                   |
                   v
                object1                   object5
               /       \                  /     \
             object2 object3         object6   object7
                        |
                        v
                     object4
            ```
         - 可作为 GC Roots的对象包括下面几种
            1. 虚拟机栈
            2. 方法区中静态属性引用的对象
            3. 方法区中常量引用的对象
            4. 本地方法栈中 JNI（即一般说的Native方法）引用的对象
      3. 引用
         1. 强引用：有强引用不会被回收，类似 Object obj = new Object();
         2. 软引用：描述一些还有用但并非必需的对象，对于软引用关联的对象，在系统要发生内存溢出异常之前，将会把这些对象列为垃圾回收范围之中进行第二次回收，如果回收后还不够分配内存则抛出内存溢出
         3. 弱引用：也是非必需对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会收掉只被弱引用关联的对象
         4. 虚引用：也称为幽灵引用或者幻影引用，是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法用虚引用来取得一个对象实例，为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知
      4. 回收方法区
         - 在大量使用反射，动态代理，CGLib等ByteCode框架，动态生成JSP以及OSGi这类频繁自定义ClassLoader的场景都需要虚拟机具备类卸载的功能，以保证永久代不会溢出

   - 垃圾收集算法
      1. 标记-清除算法（一般用于老年代）
         - 标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。标记和清除两个过程的次第都不高，另一个空间问题，标记清除之后会产生大量不连续的内存碎片
      2. 复制收集算法（一般用于年轻代）
         - 把可用内存划分为大小相等的两块，每次只使用其中一块，当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉，不用考虑内存碎片等复杂情况
         - 运行效率高，但是内存缩小为原来的一半
      3. 标记-整理算法
         - 复制收集算法在对象存活率较高时就要进行较多的复制操作，效率将会变低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种算法
         - 标记过程和 标记-清除算法 一样，但是在回收时并不是直接回收，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存
      4. 分代收集算法
         - 根据对象存活周期进行划分不同的内存块，一般是把java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适合的收集算法
         - 新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集
         - 老年代中，因为对象存活率高，没有额外空间对它进行分配担保，就必须使用“标记-清理”或者“标记-整理”算法来进行回收


   - 垃圾收集器
      - Serial 收集器：把所有用户线程停掉，直到它回收完为止
         - 一个单线程收集器
         - 新生代采用复制算法暂停所有用户线程；老年代采用标记-整理算法暂停所有用户线程
      - ParNew 收集器：是 Serial 的多线程版本
      - Parallel Scavenge 收集器
         - 是新生代收集器，它也是使用复制算法的收集器，又是并行的多线程收集器
         - 注重于吞吐量，吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间）
      - Serial Old 收集器
         - 是 Serial 收集器的老年代版本，它同样是一个单线程收集器，使用“标记-整理”算法
      - CMS 收集器
         - 以获取最短回收停顿时间为目标的收集器，希望系统停顿时间最短，以给用户带来较好的体验
         - 基于标记清除法实现
            - 初始标记 -> 并发标记 -> 重新标记 -> 并发清除
      - G1 收集器
         - 充分利用多cpu，多核环境下掋 硬件优势
         - 分代收集
         - 基于 标记-整理 的不会产生内存空间碎片的算法
         - 可预测的停顿
















***************************************************************************************************************************************

* 疑难集数
   - 15
   - 77
   - 双亲委派原则中 类全名完全一致的类 会报错，比如没有 main 方法
   - 虚方法，早/晚绑定
   - 虚引用
   - G1 垃圾回收的流程
* 常用参数
   - javac -g xxx.java        # 编译文件生成字节码，如果加上 -g 会生成局部变量表到字节码中
   - javap -v -p 字节码文件   # 反编译，-p 是因为可以反编译出私有方法和字段
   - jps                      # 查看java进程
   - jstat -gc 进程号         # 查看 gc 时内存的使用情况
   - jinfo -flag NewRatio 进程号 # 可以查看新生代和老年代的比例
   - jvisualvm                # 查看堆空间信息（视图化工具）
   - jconsole                 # （视图化工具）
* 常用工具
   - Java Flight Recorder
   - GCViewer
   - GC Easy
   - MAT(Memory Analyzer Tool)，是一款基于 Eclipse 开发的，是一款免费的性能分析工具
   - Jconsole
   - VisualVM
   - Jprofiler
   - Binary Viewer # 可以查看文件的进制信息
* 常用参数设置
   - -X 是 JVM 的运行参数
   - -Xss数字M                # 设定栈大小多少 MB，也可以是 B,K,G，没有单位则默认是 B
   - -Xms数字M                # 堆区的起始内存，等价于 -XX:InitialHeapSize，默认为 物理内存大小 / 64
   - -Xmx数字M                # 堆区的最大内存，等价于 -XX:MaxHeapSize，默认为 物理内存大小 / 4
      - 一旦堆超过这个的大小会报出 OutOfMemoryError
      - 通常 -Xms 和 -Xmx 设置成同样的大小，为了能够在 Java 垃圾回收 清理完堆后不需要重新分隔计算堆区大小，从而提高性能
   - -XX:+PrintGCDetails      # 可以把程序运行的堆信息打印出来

* 区域
   1. 方法区（线程共享）
   2. 堆（线程共享）
   3. Java虚拟机栈
   4. 本地方法栈
   5. 程序计数器
* 虚拟机的启动
   - 虚拟机的启动是通过引导类加载器（bootstrap class loader）创建一个 初始化类来完成的，这个类是由虚拟机的具体实现指定的
* 各个虚拟机
   - Classic VM 
      - 在 1.4 就淘汰了，只提供了解释器，没有提供即时编译器，如果使用 JIT 编译器，就需要进行外挂，但是一旦使用了 JIT 编译器，
      - 就会接管虚拟机执行系统，解释器就不再工作。解释器和编译器不能配合工作
   - Exact VM
      - 可以判断一个地址的内存是对象还是一个值
      - 热点探测
   - HotSpot VM
      - 有计数器找到最具编译价值代码，触发即时编译或栈上替换
      - 内置了JIT编译器，可以编译器和解释器协同工作，在最优化的程序响应时间与最佳执行性能中取得平衡
   - JRockit
      - 不关注程序启动速度，不包含解析器，全部都靠即时编译器编译后执行
      - 专注于服务器端
      - 号称 最快的 Java 虚拟机
   - IBM J9 VM
      - 号称 最快的 Java 虚拟机
   - KVM 和 CDC/CLDC
      - KVM 目前移动领域地位尴尬，被安卓和IOS二分天下
      - 主要面向功耗低的功能机，和智能控制器和传感器
   - Azul VM，Liquid VM
      - Azul VM 与特定硬件平台锁定，软硬件配合啲 专有虚拟机
      - Liquid VM 不需要操作系统的支持，本身实现了一个专用操作系统
   - Apache Harmony
      - 是 IBM 和 Intel 联合开发的开源 JVM，受到同样开源的 OpenJDK 的压制
   - Microsoft JVM
      - 为了在 IE3 浏览器上支持 Java Applets 而开发的，只能在 Windows 平台下运行，但确是当时 Windows 下性能最好的 Java VM
   - TaobaoJVM
      - 基于 OpenJDK 深度定制的国内虚拟机
   - Dalvik VM
      - 谷歌开发，不是 Java 虚拟机的虚拟机
   - Graal VM
      - 谷歌新年开发的虚拟机
* 加载过程
   - 概述
      1. 加载
      2. 链接
         - 验证（对语法和内容的正确性检查）
         - 准备
         - 解析（符号引用转为直接引用）
      3. 初始化
   - 过程
      - class file 加载到 JVM 中，被称为 DNA 元数据模板，在方法区（.class文件 -> JVM -> 最终成为元数据模板，这个过程需要 Class Loader）
* 类加载器的类别
   - 大致分类
      - 引导加载器（这是由非 Java 语言编写的）
         - Java 核心库的加载器就是引导加载器，比如 java.lang.String
      - 自定义加载器
         - 扩展于 ClassLoader 抽象的派生加载器都可以称为自定义加载器
         - ExtClassLoader 和 AppClassLoader 都是间接或直接派生于它的
   - 详细分类
      - 引导加载器（BootstrapClassLoader）
      - 扩展加载器（ExtClassLoader）
         - 主要加载 jre/lib/ext 子目录下加载类库
      - 系统加载器（AppClassLoader）
         - 用 Java 语言编写
         - 负责加载环境变量 classpath 或系统属性 java.class.path 路径下的类库，是程序中默认的类加载器
      - 用户自定义加载器
         - 隔离加载类
         - 修改类加载的方式
         - 扩展加载源
         - 防止源码泄漏
   - 类加载器的获取方式
      - ClassLoader.forName(".....").getClassLoader(); // 获取指定类的加载器
      - Thread.currentThread().getContextClassLoader(); // 获取当前线程环境的类加载器
      - ClassLoader.getSystemClassLoader(); // 获取系统加载器
   - 双亲委派原则
      - 概念
         - 一个类加载器加载一个类的时候，它不会自己先加载，而是把这个请求委托给父类加载器去执行，如果父类加载器还存在其它父类则进一步向上传递，最终达到顶层
         - 如果父类加载器可以完成类加载任务，就成功返回，若父类加载器无法完成此加载，子加载器才会尝试自己去加载，这就是双亲委派原则
      - 所以你自己定义一个 java.lang.String 在加载的时候还是加载的系统的 String，而不是你自己定义的 String，尽管类路径全名一致，因为引导加载器有管辖的 java.lang.String
   - 类的主动使用与被动使用
      - JVM 必须知道一个类型是由启动加载器加载的还是由用户加载器加载的。如果一个类型是由用户类加载器加载的，那么 JVM 会将这个类加载器的一个引用作为类型信息的一部分保存在方法区中
      - 当解析一个类型到另一个类型的引用的时候，JVM需要保证这两个类型的加载器是相同的
   - 运行时数据区
      - Runtime 即运行时数据区
      - 程序计数器（PC 寄存器）（线程私有）
         - 可以存储指向下一条字节码程序指令号的值，空间很小，但是是运行速度最快的存储区域，程序控制流的指示器，分支，循环，中转，异常处理，线程等基础功能都需要依赖这个计数器
         - 记录当前线程的运行的 JVM 指令，如果是本地方法栈则记录的是 undefiened，因为 JVM 需要不断切换线程，为了记录执行到了哪里，所以需要有程序计数器
         - 也是唯一一个在 Java 虚拟机规范中没有规定任何 OutOfMemoryError 的区域
      - java虚拟机栈
         - 保存的栈帧，一个帧就对应一个 java 方法
         - 每个线程都有自己的栈，栈中的数据都是以栈帧的格式存在，在这个线程中正在执行的每个方法都有各自对应的一个栈帧
         - 栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息
         - 在编译后才决定，一个栈帧的大小，并且在运行期间不会改变
         - 不存在 GC
         - -Xss 可以设置栈的最大值

* 字节码中的结构
   - 虚拟机栈
      - 一个栈帧所占的内容（3,4,5 统称为：帧数据区）
         1. 局部变量表
         2. 操作数栈
         3. 方法返回地址
         4. 动态链接
         5. 一些附加信息
      - 解析
         - 局部变量表
            - 概念
               - 局部变量表定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量
               - 局部变量表的大小是在编译时就确定了的
               - 局部变量表的变量的 start ~ length 表示这个变量在字节码中的有效范围
               - 局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收
            - Slot
               - 局部变量表最基本的存储单元是 Slot（变量槽），一个 Slot 占用 4 个字节
               - 局部变量表中存放编译期可知的各种基本数据类型，引用类型，returnAddress类型的变量
               - 32 位以内的类型只占用一个 slot（包括 returnAddress 类型），64位的类型占用两个 slot，这和计算 指令地址 号有密切关系
                  - 例如 boolean, byte 占用一个 slot；long 和 double 占两个 slot
               - slot 是可以重复利用的，当一个变量使用后，但是这个变量之后不需要了，那么系统判断会把这个变量的槽给其它变量使用
               - 非静态的代码块会有个 this 的局部变量，而且位置是在 index 为 0 的位置，注意方法返回值也会存在于局部变量表中
         - 操作数栈
            - 栈中任何一个元素都是可以任意的 Java 数据类型
            - 32 bit 的类型占用一个栈单位深度
            - 64 bit 的类型占用两个栈单位深度
            - 栈主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间
            - 当一个方法刚开始执行的时候一个新的栈帧也会随之被创建出来，这个方法的操作数栈是空的
            - 如果被调用的方法带有返回值的话，其返回值将会被压入 调用者的java虚拟机栈的栈帧的操作数栈中，并更新pc寄存器中下一条需要执行的字节码指令
            - 局部变量中，所有 小于等于 32 bit 的都按 32 bit 存放到 操作数栈中准备出栈（即 boolean,byte,char,short）
         - 动态链接
            - 大部分字节码执行都需要访问常量池
            - 在字节码中有可能会看到 #数字，这个 #数字 就是动态链接，在 反编译 的结果中有 Constant pool 中可以找到这个链接对应的内容
            - 在 Java 源文件被编译时，所有的变量方法引用都作为符号引用，保存在 class 文件的常量池里，（因为只是编译为了.class文件，但是没有载入内存不知道地址，所以先用引用符号代替）
               - 比如：描述一个方法调用了另外的其它方法时，就是通过常量池中指向方法的符号引用来表示的，那么动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用
               - 而动态链接指向相应的数据或方法等内容
         - 方法返回地址
            - 正常退出，则 调用者的pc计数器的值就作为返回地址，即调用该方法的指令的下一条指令的地址
            - 异常退出，返回地址是要通过异常表来确定，栈帧中一般不会保存这部分信息（即不会给上层返回任何值）
            - 异常记录表中从字节码 from -> to 行按照 tartget 行进行处理
         - 一些附加信息
   - 方法调用
      - 一些情况
         - 静态链接
            - 当一个字节码文件被装载进 jvm 内部时，如果被调用的目标方法在编译期可知，且运行期保持不变时，这种情况下将调用方法的符号引用转换为直接引用
         - 动态链接
            - 如果被调用的方法在编译期无法被确定下来，也就是说，只能够在程序运行期将调用访求的符号引用转换为直接引用，由于这种引用转换过程具备动态性，因此也称为动态链接
         - 早期绑定
            - 比如一个构造器调用父类没有重写和重载的方法
         - 晚期绑定
            - 比如一个构造器调用父类被自己重写的方法
         - 非虚方法
            - 方法在编译期就确定了具体的调用版本，这个版本在运行时是不可变的，这样的方法称为非虚方法
            - 静态方法，私有方法，final方法，实例构造器，父类方法都是非虚方法
               - 这几种之外的都是虚方法
         - 虚方法
      - 虚拟机中方法调用指令
         - 普通调用指令
            - invokestatic: 调用静态方法，解析阶段确定唯一方法版本（非虚方法）
            - invokespecial: 调用<init>方法，私有及父类方法，解析阶段确定唯一方法版本（非虚方法）
            - invokevirtual: 调用所有虚方法（虚方法）
               - 注意如果 B extend A，A 中有 public final YY xxx() 的方法，在B的一个方法中调用它。
                  - 不同情况编译后，B的那个调用方法结果是不一样的，虚方法和非虚方法是取决于编译器，而非程序员
                     - B 的方法中调用写法是 xxx()
                        - 编译后是 invokevirtual 方法
                     - B 的方法中调用写法是 super.xxx()
                        - 编译后是 invokespecial 方法
                     - 这里 invokevirtual 不是取决于是否是final，而是取决于 private 还是 public
                        - 这是 java 遗留问题，《Java语言规范》规定 final 是非虚方法
               - 父类有个没有被重写的方法，在 B 中有个方法以没有 super关键字的形式调用它，B的这个调用方法编译后是 invokevirtual
               - B 中有个非 final 的普通方法，在 B 中有另一个方法了它，那么这个另一个方法编译后调用方法也为 invokevirtual
            - invokeinterface: 调用接口方法（虚方法）
         - 动态调用指令
            - invokedynamic: 动态解析出需要调用换方法，然后执行，lambda 表达式会造成这种情况
         - 注意
            - 用 super 调用父类方法是 非虚形式调用，不用 super 调用父类方法是 虚形式调用
            - 调用自己定义的一个没有被重载的方法，也是虚方法，因为可能被自己重载
      - 方法重写和虚方法
         - 在执行操作数栈顶的对象 C，在 C 中找到与常量中描述符合简单名称都相符的方法则进行访问权限校验，如果通过则返回这个方法的直接引用，否则递归找父级
         - 因为寻找太烦琐，所以 方法区/元空间 存有虚方法表（非虚方法是直接可以确定的，所以不需要存储）
         - 在类加载的链接阶段就保存虚方法表

* 本地方法接口
   - Native Method 是非 Java 实现的方法
   - 直接调用系统物理的资源，不受 JVM 管理

* 堆
   - 概念
      - 在创建的时候就确定了大小了，也是 JVM 管理的最大的一块内存空间 （堆是线程共享的）
      - 在物理上可以是不连续的，但是在逻辑上应该是连续的
      - 在对象没有引用后不会马上销毁掉，会等到垃圾回收才会被清除
      - 堆初始大小和最大大小建议一致，否则堆大小小了不够会扩容，多了会清理扫描过多空间，这个过程会影响正常的程序执行
   - 细分分析
      - 划分
         - java7 及之前堆内存逻辑上分为：新生区 + 养老区 + 永久区
         - java8 及之后堆内存逻辑上分为：新生区 + 养老区 + 元空间
         - 新生区（Young Generation Space）
         - 养老区（Tenure  generation Space）
         - 永久区（Permanent Space）/ 元空间（Meta Space）
      - java 方法结果注意
         - Runtime.getRuntime().totalMemory() # 可以获取初始堆大小
         - Runtime.getRuntime().maxMemory() # 可以获取最大堆大小
         - 这两个方法获取到的可能和参数分配的大小不一样，比参数分配的要小一些
            - 因为 JVM 的堆的 survivor 有两个，分别是 s0 和 s1区，在实际情况中总有一个是空闲的
            - 而方法获取到的实际有一个空闲的 survivor 空间没有计算。所以和参数分配的比较会小一些
            - 结论是两个方法计算的是实际使用的内存空间
      - 默认堆情况下
         - 初始内存大小：物理电脑内存大小 / 64
         - 最大内存大小：物理电脑内存大小 / 4
   - 新生代和老年代参数设置
      - 存在 java 中对象可分为两类
         - 1. 一类是生命周期较短的瞬时对象，这类对象的创建和消亡都非常迅速
         - 2. 另一类对象的生命周期很长，在某些极端情况下还能够与 JVM 的生命周期保持一致
      - Java 堆区进一步细分的话，可以划分为年轻代和老年代
         - 年轻代又可以分为三部分
            - Eden 空间
               - 有的对象死亡了那么从 Eden 中回收，如果存活那么放到 Survivor0/Survivor1 中，如果 Survivor0/1 中还存活了一段时间那么就转换到老年代中
            - Survivor0
            - Survivor1
         - 分配 新生代和老年代的比例
            - -XX:NewRatio=2 表示新生代占1,老年代占2,新生代占整个数堆的 1/3（默认）
               - 这个数字表示 新生代占数:老年代占为数 => 1:2
            - -XX:NewRatio=4 表示新生代占1,老年代占4,新生代占整个数堆的 1/5
               - 这个数字表示 新生代占数:老年代占为数 => 1:4
         - -Xmn 设置新生代最大内存大小，这个参数一般默认就好了（这个优先级会大于 -XX:NewRatio）
         - 在HotSpot 中，Eden 空间和另外两个 Survivor 空间缺省所占的比例是 8:1:1
            - 可以 -XX:SurvivorRatio 调整这个空间比例
            - 几乎所有的 java 对象都是在 Eden 区被 new 出来的
            - 绝大部分对象销毁都是在新生代中进行的
            - 很多情况，实际查询出来不是 8:1:1，因为有默认有自适应的设定（-XX:+UseAdaptiveSizePolicy），关闭是 -XX:-UseAdaptiveSizePolicy
               - 所以需要显式指定 -XX:SurvivorRatio=8 才会有效果
   - 对象分配过程
      - 一般概念
         - 新生代的回收叫 YGC / Minor GC，老年代的回收是 Major GC / Old GC
         - new 对象先放在 Eden 区
         - Survivor0 或 Survivor1 简称 s0 或 s1
         - 在内存回收过程中，对象经过Eden -> s0/1, s0 -> s1, s1 -> s0 
            - 放入 s0/s1 的过程中，对象的阈值会增加，对象的阈值默认是 15，15之后会 Promotion 到老年代
            - 额外也有没到 15 就升为老年代的情况
         - Eden 满会触发 GC，但是 S0,s1 满的时候不会触发，Eden 触发的时候会同时判断 s0和s1 是否满了
         - 垃圾回收：频繁在新生区回收，很少在老年代回收，几乎不在永久区/元空间回收
         - 针对幸存者 s0,s1区的总结，复制之后有交换，谁空谁是 to，因为 from to 是一个 从 from 复制到 to 的位置的过程
      - 特殊情况
         - 分配一个对象 Eden 放不下，则直接放到 老年代中，
            - 老年代也放不下，进行 FGC 回收，再判断放不放得下
            - FGC 过后还放不下，直接 OOM 错误

   - 对象回收
      - 分类
         - Minor GC / Young GC          # 相当于 新生代回收
         - Major GC / Old GC            # 会回收 老年代
         - Full GC                      # 会回收 整个堆空间，包括老年代和永久代
      - 在 GC 时，并非每次都对三个内存进行一起回收（新生代，老年代，方法区/永久代）
         - 部分收集（Partial GC）
            - 新生代收集（Minor GC）：只是新生代 Eden,s0,s1 的垃圾回收
            - 老年代收集（Major GC）：只是老年代的垃圾收集
               - 目前，只有 CMS GC 会有单独收集老年代的行为
               - 注意，很多时候 Major GC 会和 Full GC 混淆使用，需要具体分辨是老年代回收还是整堆回收
            - 混合收集（Mix GC）：收集整个新生代以及部分老年代的垃圾收集
               - 目前，只有 G1 GC 会有这种行为
         - 整堆收集（Full GC）：收集整个 java 堆和方法区的垃圾收集
      - 年轻代 GC 触发时机
         - Eden 空间不足时触发，就会触发 Minor GC，这里的年轻代满指的
         - 是 Eden 代满，Survivor 满不会引发 GC，每次 Minor GC会清理年轻代的内存
         - 因为 Java 对象大多都具备朝生夕灭的特性，所以 Minor GC非常频繁，一般回收速度也比较快。这一定义既清晰又易于理解
         - 会引发 STW，暂停其它用户的线程，等垃圾回收完后才会恢复
      - 老年代 GC
         - 指发生在老年代的GC，对象从老年代消失时，我们说“Major GC”或“Full GC”发生了
         - 出现了 Major GC，经常会伴随至少一次的Minor GC（但非绝对的，在Parallel Scavenge收集器的收集策略里就有直接进行 Major GC的策略选择过程）
            - 也就是在老年代空间不足时，会先尝试触发Minor GC，如果之后空间还不足，则触发Major GC
         - 速度比 Minor GC 慢10倍以上，STM时间更长
         - 如果 Major GC后，内存还不足，就报OOM了
      - Full GC 触发条件
         1. 调用 System.gc() 时，系统建议执行 Full GC，但是不必然执行
         2. 方法区空间不足时（此时会触发 Full GC 进行 Class, Method 元信息的卸载
         3. 老年代空间不足
         3. 通过 Minor GC 后进入老年代对象的平均大小大于老年代的可用内存
         4. 由 Eden 区和s0,s0 中 的 from space 复制到 to space 时 ，复制的对象大小大于 To Space 可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小时

   - 内存分配策略
      - 优先分配到 Eden
      - 大对象直接分配到老年代（当 Eden 装不下时）
      - 长期存活的对象（阈值超过指定的 阈值，默认是15）
      - 动态对象年龄判断
         - 如果 Survivor 区中相同年龄的所有对象大小的总和大于 Survivor 空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代，无须等到 MaxTenuringThreshold 中要求的年龄 
      - 分配担保
         - -XX:HandlePrmotionFailure
         - 在发生 MIinor GC 之前，虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象的总空间
            - 如果大于，则此次 Minor GC 是安全的
            - 如果小于，则虚拟机会查看 -XX:HandlePromotionFailure 设置值是否允许担保失败
               - 如果这个值为 true，那么会继续检查老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小
                  - 如果大于，则尝试进行一次 Minor GC，但这次Minor GC依然是有风险的
                  - 如果小于，则改为进行一次 Full GC
               - 如果这个值为 false 则改为进行一次 Full GC
         - jdk7 及之后这个参数不再影响虚拟机内存分配担保策略，默认是 true
            - 这及之后，HandlePromotionFailure 参数将不会再影响到虚拟机的空间分配担保策略
            - 只要老年代连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行 Minor GC，否则将进行 Full GC
      - 堆空间初始值和最大值
         - 两者最好设置为一致，
            - 避免生产环境中由于 heap 内存扩大和缩小导致应用停顿，也避免每次垃圾回收完成后JVM重新分配内存
               - 避免jvm在运行过程中向OS申请内存
               - 启动后首次GC的发生时机可以延后
               - 减少启动初期的gc次数
               - 避免使用 swap space
         - 当然如果生产系统上线有一段时间预热时间的话，也可以不设置

   - 堆空间为每个线程分别分配了 TLAB(Thread Local Allocation Buffer)
      - 概念
         - 堆区是线程共享区域，任何线程都可以访问到堆区中共享数据
         - 由于对象实例的创建在 JVM 中非常频繁，因此在并发环境下从堆中划分内存空间是线程不安全的
         - 为避免多个线程操作同一地址，需要使用加锁等机制
         - 所以为了防止并发锁引起的性能问题每个线程有自己的 TLAB 在Eden中，
         - 如果TLAB不够用则加全局锁进行分配 Eden 剩余空间进行使用
      - 什么是 TLAB
         - JVM 为每个线程分配独立的线程区域，避免多线程分配同一个内存地址的问题（快速分配策略），一个 TLAB 仅占 Eden 空间的 %1
         - -XX:TLABWasteTargetPercent 数字 # 进行设定每个 TLAB 所占 Eden 的比例

   - 堆空间的参数设置总结
      - -XX:+PrintFlagsInitial:     # 查看所有的参数的默认初始值
      - -XX:+PrintFlagsFinal:       # 查看所有的参数的最终值（可能会有修改，不再是初始值）
         - 具体查看某个参数的指令：jps:     # 查看当前运行中的进程
         - jinfo -flag SurvivorRatio 进程号 # 查看 SurvivorRatio 这个的具体值是多少
      - -Xms:                       # 堆总大小初始大小（默认物理内存的 1/64）
      - -Xmx:                       # 堆大小最大大小（默认物理内存的 1/4）
      - -Xmn:                       # 设置新生代最大内存大小（初始值和最大值），一般默认就好了（这个优先级会大于 -XX:NewRatio）
      - -XX:NewRatio:               # 配置新生代与老年代在堆结构的占比
      - -XX:SurvivorRatio           # 设置新生代中 Eden 和 s0/s1 空间的比例
      - -XX:MaxTenuringThreshold:   # 设置新生代垃圾的最大年龄
      - -XX:PrintGCDetails:         # 输出详细的 GC 处理日志
      - -XX:HandlePromotionFailure: # 是否设置空间分配担保

   - 堆是对象存储的唯一选择吗
      - 概念
         - 栈上分配，标量替换优化技术将会导致一些微妙的变化，在堆上分配也渐渐变得不那么“绝对”了
         - “逃逸分析”，经过逃逸分析后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配，这样就无需在堆上分配，也不需要进行垃圾回收
            - JIT 编译器在编译期间根据逃逸分析结果，如果一个对象没有逃逸，可能被优化为栈上分配，即方法栈出栈后，自动回收，这样就避免了垃圾回收
            - 当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸
               - 理论上应该在栈上分配内存，但是目前此技术还并不成熟，加上 Oracle 的 HotSpot 并未采用栈上分配，其实是由标量替换缓解了堆的压力）
            - 当一个对象在方法中被定义后，对象不仅在方法内部使用，则认为发生逃逸（因为如果不仅在方法内部使用，其它方法使用，栈帧出栈相当于自动销毁了，所以不需要GC）
         - 如何判断逃逸，就看 new 的对象实体是否有可能在方法外被调用
         - JDK 6u23 之后，HotSpot 默认开启了逃逸分析
         - 开发中能使用局部变量就不要使用在方法外来定义
         - -XX:+DoEscapeAnalysis # 开启逃逸分析（默认是打开的）
         - -XX:-DoEscapeAnalysis # 不开启逃逸分析
         - 开始逃逸分析后，判断未逃逸的在栈中创建分配（基本不会发生GC，因为出栈即销毁），逃逸了就在堆里面分配
         - 注意
            - 逃逸分析还是基于标量替换（标量替换才算是逃逸分析的实现）
            - 有些观点认为通过逃逸分析，jvm会在栈上分配那些不会逃逸的对象，这在理论上是可行的，但是取决于jvm设计者的选择，据我所知，Oracle Hotspot 的 jvm 中并未这么做
               - 这一点在逃逸分析相关的文档里已经说明，所以可以明确所有的对象实例都是创建在堆上
            - 目前很多书籍还是基于jdk7以前的版本，jdk已经发生了很大变化，intern字符串的缓存和静态变量曾经都被分配在永久代中，而永久代已经被元数据区取代，但是，intern字符串
               - 缓存和静态变量并不是被转移在元数据区，而是直接在堆上分配，所以这一点同样符合前面的一点结论：对象实例都是分配在堆上
      - 代码优化
         - 只有一个线程访问的资源没有必要加锁
         - 加锁的代码块如果确实只有一个线程访问则会在编译时被编译为不加锁
         - 标量替换
            - 是指一个无法再分解成更小的数据的数据，java中的原始数据类型就是标量，还可以分解的数据叫做 聚合量
            - 如果经过逃逸分析，发现一个对象不会被外界访问，那么经过优化，就把这个对象拆解成若干个其中包含的若干个成员变量来代替，这个过程叫标量替换
               ```
               这里的 alloc 里面的 Point 对象没有逃逸，所以解析成 int x 和 int y 在 alloc() 方法栈中的局部变量（交量替换）
               private static void alloc() {
                 Point p = new Point(1,2); // 因为标量替换等价于：int x=1; int y=2;
                 System.out.println(p.x + "<-->" + p.y);
               }
               class Point {
                 private int x,y;
                 public Point(int x, int y) { this.x = x; this.y = y; }
               }
               ```
         - -XX:+EliminateAllocations 开启标量替换（默认是开启的）
         - -XX:-EliminateAllocations 关闭标量替换

* 方法区/永久代（JDK8 用元空间替代）
   - 形式举例
      ```
      Person p = new Person();
      Person: 在方法区
      p: 在方法栈
      new Person(): 在堆
      ```
   - 大致结构
      - 类信息
         - 有效字节码中除了包含类的版本信息，字段，方法以及接口等描述信息
         - 常量池表，包括各种字面量和对类型，域和方法的符号引用（jdk7,8 及之后，字符串常量池和静态变量放在堆中）
      - 运行时常量池
         - 字节码中的常量池放到JVM后就是运行时常量池，这时符号引用就变为了真实的地址引用
   - jdk7 习惯上称方法区为永久代，jdk8开始用元空间取代了永久代，从物理上 jdk6的永久代和之后的元空间并不在堆中
      - 方法区和永久代不等价，仅是 hotspot 而言的，可以看作 永久代 和 元空间 实现 方法区
      - 元空间是以本地物理内存进行存储的
      - JRockit/ IBM J9 中号水存在永久代的概念
      - 在 JVM 启动的时候被创建，方法区大小决定了可以保存多少个类，如果系统定义了太多的类会导致 OutOfMemoryError，关闭 JVM 时会释放这个内存
   - 永久代为什么要被元空间替换
      - 运行过程中，要不断地动态加载很多类，经常出现致命错误
      - 永久代进行调优是很困难的，因为类型的制裁条件相当苛刻，但是方法区的回收又是必要的
   - 设置方法区大小与OOM
      - jdk7及以前
         - -XX:PermSize=100M # 举例 100M
         - -XX:PermSize 设置永久代初始分配空间，默认 20.75M
         - -XX:MaxPermSize 设置永久代最大可分配空间，32位机器默认是64M，64位机器模式是82M
      - jdk8及之后
         - -XX:MetaspaceSize=100M # 举例 100M
         - -XX:MetaspaceSize 设置元空间初始分配空间
         - -XX:MaxMetaspaceSize 设置元空间最大可分配空间
      - 注意如果 jinfo -flag PermSize/MetaspaceSize 进程号 # 查询出来的结果是 -1 表示没有限制
   - 方法区内部结构
      - 不同jdk版本的方法区演进
         - jdk1.6及之前：有永久代，静态变量存放在永久代上；
         - jdk1.7：有永久代，但已经逐步“去永久代”，字符串常量池，静态变量移除，保存在堆上
         - jdk1.8及之后：无永久代，用以元空间代替；类型信息，字段，方法，常量保存在本地内存的元空间，但字符串常量池，静态变量仍在堆
      - 方法区存储了：类型信息，常量，静态变量，即时编译器编译后的代码缓存等（jdk8及之后 字符串常量池和静态变量存在堆中）
         - 方法区的主要结构是：类信息，运行时常量池
         - static 和 static final 常量的区别
            - static 是在加载后的 Linking 中准备阶段分配内存；然后在 初始化阶段赋值（如果有显式赋值的情况下）
            - static final 是在编译时就为它赋值了
   - StringTable 为什么要调整
      - jdk7中将 StringTable 放到了堆空间中，因为永久代的回收效率很低，在 full gc 的时候才会触发。而 full gc 是老年代不足时，永久代不足时才会触发
      - 这就导致 StringTable 回收效率不高。而我们开发中会有大量的字符串被创建，回收效率低，导致永久代内存不足，放到堆中，能及时回收内存

* 对象的实例化内存布局与访问定位
   - java 创建对象的方式
      1. new 对象
      2. Class 的 newInstance() // 只能调用空参的构造器，权限必须是 public 
      3. Constructor 的 newInstance(Xxx) // 可以调用无参或有参的构造方法，权限可以任意
      4. 使用 clone() // 当前的类需要去实现克隆 Cloneable 接口
      5. 使用反序列化 // 从文件或网络中获取二进制流
      6. 第三方库 Objenesis // 第三方类库
   - 创建对象的步骤
      1. 判断对象对应的类是否加载，链接，初始化
         - 虚拟机查看类在 Metaspace 常量池中是否有符号引用，没有则靠双亲委派机制用当前ClassLoader加载，如果未找到则抛出异常
      2. 为对象分配内存
         - 计算对象战胜空间大小，分配内存
      - 如果内存较规整 （标记整理法）
         - 指针碰撞（就是一块内存，从左往右存，开辟一个空间后，指针就移到第一个可用空间，即指针区隔开了可用和不可用的内存）
      - 如果内存不规整的（标记清除法）
         - 虚拟机需要维护一个列表
         - 空闲列表分配
      3. 处理并发安全问题
         - 采用 CAS 失败重试，区域回销保证更新换原子性
         - 每个线程预告分配一块 TLAB -> 通过 -XX:+/-UseTLAB 参数来设定
      4. 初始化分配到的空间
         - 所有属性设置默认值，保证对象实例字段在不赋值时可以直接使用
      5. 设置对象的对象头
      6. 执行 init方法 进行初始化
   - 创建对象的执行流程
      1. 加载类元信息
      2. 为对象分配内存
      3. 处理并发问题
      4. 属性的默认初始化（零值初始化）
      5. 设置对象头的信息
      6. 属性的显式初始化
      7. 代码块中初始化，构造器中初始化
   - 对象总局
      1. 对象头
         - 运行时元数据
            - 哈希值
            - GC 分代年龄
            - 锁状态标志
            - 线程持有的锁
            - 偏向线程id
            - 偏向 时间戳
         - 类型指针
            - 指向类元信息，确定该对象所属类型（指向元空间）
         - 如果是数组，则还要记录数组的长度
      2. 实例数据
         - 它是对象真正存储的有效信息，包括程序代码中定义的各种类型的字段（包括从父类继承下来的和本身拥有的字段）
            - 相同宽度的字段总是被分配到一起（编译重排？）
            - 父类中定义的变量会出现在子类之前
            - 如果 CompactFields 参数为 true（默认为true）：子类的窄变量可能插入到父类变量的空隙
      3. 对齐填充
         - 不是必须的，也没有特别含义，仅仅起到占位符的作用（字节对齐？）
   - 对象访问
      - 方式
         - 句柄访问（句柄包含两个指针）
            - 到对象实例数据的指针
            - 到对象类型数据的指针
         - 直接指针（HotSpot采用）
            - 直接指向对象实体
               - 对象类型数据
      - 两种方式的比较
         - 直接指针效率高，比句柄访问少指针那部分的内存
         - 因为句柄是由 句柄指向对象，所以对象地址变化了，本地变量表的引用的地址不用改变，而直接指针却影响本地变量的引用地址变更

* 直接内存
   - 直接内存来源于 NIO，但是不受堆内存管理，直接内存大小可以通过 MaxDirectMemorySize 设置
   - 如果不指定，默认与堆的最大值 -Xmx 参数一致

* 执行引擎的工作原理和过程
   - 两种引擎的描述（HotSpot 是集成了两种的）
      - 解释器：虚拟机将字节码采用逐行解释的方式执行，将每条字节码文件中的内容“翻译”为对应平台的本地机器指令执行，边解析边执行不会产生文件
      - JIT编译器（即时编译器）：就是将源代码直接编译成和本地机器平台相关的机器语言，会捕捉热点代码
      - 注意，解释器和JIT编译器都是把 字节码 翻译为 机器指令
   - JIT 编译器比 解释器 速度快
      - 解释器：程序在启动时可以马上发挥作用，省去编译时间，一边解释一边执行
      - JIT：编译器要想发挥作用，把代码编译成本地代码，需要一定执行时间。但编译为本地代码后，执行效率高
      - 所以还是保留了 解释器
   - HotSpot JVM 的执行方式
      - 当虚拟机启动的时候，解释器可以首先发挥作用，而不必等待即时编译器全部编译完成再执行，这样可以省去许多不必要的编译时间，并
      - 且随着程序运行时间的失衡，即时编译逐渐发挥作用，根据热点探测功能，将有价值的字节码编译为本地机器指令，以换取更高的程序执行效率
   - 热点代码
      - 一个被多次调用的方法，或者是一个方法体内循环次数较多的循环体都可以称为“热点代码”，因为都可以通过JIT编译器编译为本地机器指令
         - 由于这种编译方式发生在方法的执行过程中，因此也被称为栈上替换，或者简称为 OSR
         - 目前 HotSpot 所采用的热点探测方式是基于计数器的热点探测（一个方法调用计数器，一个回边计数器）
            - 计数器
               - 方法调用计数器用于统计方法的调用次数
               - 回边计数器用于统计循环体执行的循环次数
            - 触发 JIT 的情况
               - 在 client 模式上是 1500 次，在 server 模式下是 1000 次，超过这个阈值，触发 JIT 编译（-XX:CompileThreshold 来人为设定）
               - 当一个方法被调用时，会先检查该方法是否在被 JIT 编译过的版本，如果存在，则优先使用编译后的本地代码来执行。如果不存在
               - 则将此方法的调用计数器值加1,然后判断方法调用计数器与回边计数器值之和是否超过方法调用计数器的阈值，如果已超过，
               - 那么将会向即时编译器(JIT)提交一个该方法的代码编译请求，请求结果再执行。否则用解释器解释执行
      - 如果不做任何设置，方法调用计数器统计的并不是方法被调用的绝对次数，而是一个相对的执行频率，即一段时间之内方法被调用的次数，当
         - 超过一定的时间限度，如果方法的调用次数仍然不足以让它提交给即时编译器编译，那这个方法的调用计数器就会被减半。这个过程称为方法调用计数器热度“衰减”
         - 而这段时间就称为此方法统计的“半衰周期）
         - -XX:-UseCounterDecay 来关闭热度衰减
         - -XX:CounterHalfLifeTime 参数设置半衰周期的时间，单位是秒
   - HotSpot 设置程序执行方式
      - -Xint: 完全采用解释器的模式执行程序
      - -Xcomp: 完全采用即时编译器执行，如果即时编译器出现问题，解释器会介入执行
      - -Xmixed: 采用解释器+即时编译器的混合模式共同执行程序
   - HotSpot 内嵌两个 JIT 编译器
      - client 模式下，用的 C1 编译器，对字节码进行简单和可靠的优化，耗时短，以达到更快的编译速度
      - server 模式下，用的 C2 编译器，耗时较长的优化，以及激进优化，但优化的代码执行效率更高
   - 分层编译
      - 不开启性能监控则用 C1 编译器，用了性能监控则用 C2 进行优化处理
   - JDK11 后有个 Graal 编译器，短短几年就追平 C2 编译器，未来可期
   - AOT 编译器是在程序运行之前便将所有字节码转换为机器码，而 JIT 和 解释器是在运行过程中编译处理的
      - 好处是可以直接使用系统可以执行的机器指令
      - 坏处
         - 是破坏了 一次编译，到处运行的 原则
         - 坏处是降低了java 链接的动态性，加载的代码在编译期就必须全部已知
         - 还需要继续优化，最初只支持 Linux x64 java base

* String 的原理
   - 概念
      - String 在 jdk8 及之前是用的 char[] value 存储的，jdk9 及之后就改为了 byte[] value 和 字符编码 存储
      - String 的常量池是不可能存在完全相同的两个字符串字面量的
      - string 的 String Pool 是一个固定大小的 Hashtable，默认值大小长度是 1009，如果放进 String Pool 的 String 非常多，就会造成 Hash 冲突
         - 从而导致链表会很长，而链表长了后直接会造成的影响就是当调用 String.intern 时性能会大幅下降
         - 其原理则是 HashTable，而 HashTable 是一直用hash+链表的形式存放的
      - 使用 -XX:StringTableSize=数字 可设置 StringTable 的长度
      - JDK6中StringTable长度是固定的，JDK7 中，StringTable长度默认为60013，JDK8开始，1009是可设置的最小值
      - intern() 使用总结
         - String 的 intern() 方法的使用
         - JDK6中
            - 将这个字符串对象尝试放到字符串常量池中
            - 如果池中有，则并不放入，返回已有的串池中的对象的地址
            - 如果池中没有，堆中有，会在常量池中从堆中copy一份数，并返回串池中的对象地址
         - JDK7中
            - 将这个字符串对象尝试放到字符串常量池中
            - 如果池中有，则并不会放入，返回已有的串池中的对象的地址
            - 如果池中没有，堆中有，则会把对象的引用地址复制一份，放入串池，并返回串池中的引用地址（这里就相当于，串池的地址引用的是堆中的地址）

      - 字符串拼接
         - 注意字符串常量池和静态数据 在 jdk7 和 jdk8 都是在 堆里的，但是是和 堆的其它部分是隔离开的，jdk6是放在方法区中的
         - 字面量与字面量的拼接，结果是存在常量池中，原理是编译期优化；如果拼接中一个值是变量，则变量拼接的原理是 StringBuilder 调用append方法拼接最后toString后的结果存在堆中
            -（在 jdk5.0 之前是用的 StringBuffer）
            - 创建的对象会返回堆的对象，然后会把这个对象在常量池中再创建一份，方便下次直接引用
            - 注意如果是 final 常量属性则放在常量池中，所以即使常量拼接也拿的是常量池中的值
            - toString 底层其实还是 创建了一个对象
         - 举例
           ```
           String s1 = "ab"; // 如果 字符串常量池中没有 "ab" 则会创建 "ab" 放到字符串常量池中
           String s2 = "cd"; 
           String s3 = "ab" + "cd"; // 这是编译优化存在字符串常量池中
           String s4 = "abcd"; // 在字符串常量池中有值，所以 s3 == s4
           s3 == s4; // true
           s1 + s2 == s4; // false
           s1 + "cd" == s4; // false
           ```
           ```
           final String s1 = "a";
           final String s2 = "b";
           String s3 = "ab";
           final String s4 = s1 + s2; // 因为 s1 和 s2 都是 final，编译期仍然优化在了字符串常量池
           String s5 = s1 + "b"; // 原理还是 常量和字面量拼接，会在编译期优化到字符串常量池
           s3 == s4 // true
           s5 == s3 // true
           ```
         - 疑难注意
           - new String("ab"); // "ab" 在字符串常量池中没有，所以创建了一个"ab"放在字符串常量池中，然后 new String 又创建了一个对象，所以一共创建了两个对象
           - String s2 = new String("a") + new String("b); // 共创建了 6 个对象，注意！！在字符串常量池中没有 "ab"，因为"ab"是堆中创建出来的
              - 个数
                 1. new StringBuilder
                 2. new String("a")
                 3. 常量池中创建的 "a"
                 4. new String("b")
                 5. 常量池中创建的 "b"
                 6. 最后 StringBuilder 添加两个对象后调用 toString，toString 里面会有 创建一个 String 对象，所以一共六个对象
         - 疑难注意2
            ```
            String s = new String("1"); // 字符串常量池中创建 "1"，然后堆中创建了 new String("1")
            s.intern(); // 调用此方法之前，字符串常量池中已经有 "1"，所以此次调用并无实质作用
            String s2 = "1"; // 拿的字符串常量池中的 "1"
            s == s2 // jdk6/7: false    jdk8: false
            
            String s3 = new String("1") + new String("1"); // 执行完后 字符串常量池中没有 "11"
            s3.intern(); // 在字符串常量池中创建 "11"，如何理解：jdk6：创建了一个新的对象"11"；
                         // jdk7/8 中往常量池中放 "11"，为了节省内存，直接把堆中的"11"地址给了常量池中的引用（实际就是常量池中指向了堆中的"11"）
                         // 这么看常量池放的 又可以是地址 也可以是对象
            String s4 = "11"; // 使用的就是上一行代码执行产生在字符串常量池中的 "11"
            s3 == s4 // jdk6: false jdk7/8: true 
            ```
            ```
            String s3 = new String("1") + new String("1"); // 执行完后 字符串常量池中没有 "11"
            String s4 = "11"; // 这里会在常量池中创建一个"11"
            s3.intern(); // 这里实际上没有效果，因为常量池中已经有"11"了，所以这里没有任何处理
            s3 == s4 // false
            ```
   - String 的使用方式有两种
      - String info = "abcd"; 
      - String info = new String("abcd"); 


* 垃圾回收算法
   - 垃圾的定义
      - 在运行程序中没有任何指针指向的对象，这个对象就是需要被回收的垃圾
   - 判断对象是否存活的一般方法有两种
      1. 引用计数算法
         - 记录对象被引用的情况，对于一个对象有被一个地方引用就引用计数器加1，引用失效时，引用计数器就减1，到0为止就回收
         - 优点高，没有延迟性
         - 需要单独的字段存储计数器，这样的做法增加了空间的开销
         - 每次赋值都需要更新计数器，伴随着加法和减法操作，这增加了时间开销
         - 无法处理循环引用，这是致使缺陷，导致在 jvm 中垃圾回收器没有利用这种算法
            - A -> B -> C -> A 造成内存泄漏（这三个的 引用计数器都是1,但是这三个都已经决定不用了，一直占用空间却又回收不了，造成内存泄漏）
      2. 可达性分析算法/根搜索算法/追踪性垃圾算法
         - 防止循环引用引起的内存泄漏问题
         - 以根对象为起点，按照从上至下的方式搜索被根对象集合所连接的目标对象是否可达
         - GC Roots 包括以下几类元素
            1. 虚拟机栈中引用的对象
               - 比如各个线程被调用的方法中使用到的参数，局部变量等
            2. 本地方法栈内 JNI（通常说的本地方法）引用的对象
            3. 方法区中类静态属性引用的对象
               - 比如Java类的引用类型表态变量
            4. 方法区中常量引用的对象
               - 比如字符串常量池（String Table）里的引用
            5. 所有被同步锁 synchronized 持有的对象
            6. java 虚拟机内部的引用
               - 基本数据类型对应的Class对象，一些常驻的异常对象，如NullPointerException, OutOfMemoryError，系统类加载器
            7. 反映java虚拟机内部情况的JMXBean, JVMTI中注册的回调，本地代码缓存等 
            8. 除了以上几种固定的 GC Roots 夜校合外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象“临时性”地加入，共同构成完整GC Roots集合
               - 比如：分代收集和局部回收
         - 小技巧：由于 Root 采用栈方式存放变量和指针，所以如果一个指针，它保存了堆内存里面的对象，但是自己又不存放在堆内存里面，那它就是一个 Root
   - finalization 机制
      - 当 GC 发现对象没有被引用之后，在回收之前会先调用 fialize() 方法
         - 可以重写，一般用于在对象被回收时进行资源释放，比如关闭文件，套接字和数据库连接等
      - 永远还要主动调用 fialize 方法，应该交给垃圾回收机制调用，理由包括三点
         - 在 finalize() 时可能会导致对象复活
         - 执行时间没有保障的，它完全由 GC 线程决定，极端情况下若不发生 GC，则 finalize() 方法将没有执行机会
         - 一个糟糕的 finalize() 会严重影响 gc 的性能
      - 由于 finalize 方法的存在，java 中对象的状态可能有三种
         - 可触及的：从根节点开始，可以到达这个对象
         - 可复活的：对象的所有引用都被释放，但是对象有可能在 finalize() 中复活
         - 对象的 finalize() 被调用，并且没有复活，那么就会进入不可触及状态。不可触及的对象不可能被，因为 finalize() 只会被调用一次

   - 垃圾的清除
      - 当成功区分出内存中戚对象和死亡对象后，gc 接下来的任务就是执行垃圾回收，释放掉无用对象所占用的内存空间，以便有足够的可用内存空间为新对象分配内存
      - JVM 中比较常见的三种算法
         1. 标记-清除算法(Mark-Sweep)
            - 当堆中有效内存空间被耗尽的时候，就会停止整个程序，然后进行两项工作，第一项则是标记，第二项则是清除
               - 标记：Collector 从引用根节点开始遍历，标记所有被引用的对象，一般是在对象的 Header 中记录为可达对象（标记的是存活的）
               - 清除：Collector 对堆内存从头到尾进行线性的遍历，如果发现某个对象在其 Header 中没有标记为可达对象，则将其回收
            - 缺点
               - 效率不高
               - 在进行 GC 的时候，需要停止整个应用程序，导致用户线程阻塞
               - 这种方式清理出来的空闲内存是零散的，产生内存碎片，需要维护一个空闲列表
         2. 复制算法(Copying)
            - 新生代使用的就是这个算法
            - 概念
               - 为了解决标记-清除算法在垃圾收集效率方面的缺陷，使用双存储区的垃圾收集器
               - 将活着的内存空间分为平均的两块，在垃圾回收时将正在使用的内存中的戚对象复制到未被使用的内存块中，之后清除正在使用的内存块中的所有对象
               - 交换两个内存的角色，最后完成垃圾回收
            - 缺点
               - 损失一半的存储空间
               - 对于 G1 这种分拆成为大量 region 的 GC，复制而不是移动，意味着 GC 需要维护 region 之间对象引用关系，不管是内存占用或者时间开销也不小
               - 注意，如果收集存活的对象太多，那么复制会花销太多的性能，所以对于存活的对象很多时不适用，所以新生代的朝生夕死的就用了 幸存者的两个空间弥补缺点
         3. 标记-压缩（整理）算法(Mark-Compact)(Mark-Sweep-Compact)
            - 背景
               - 复制算法的高效性是建立在存活对象少，垃圾对象多的前提下。这种情况在新生代经常发生，但是在老年代，更常用的情况是大部分对象都是存活对象。如果依然使用复制算法
               - 由于存活对象较多，复制的成本也将很高。因此，基于老年代垃圾回收的特性，需要使用其他的算法
               - 标记-清除算法的确可以应用在老年代中，但是该算法不仅执行效率低下，而且在执行完内存回收后还会产生内存碎片，所以 JVM 的设计者需要在此基础上进行改进
               - 标记-压缩(Mark-Compact)算法由此而生
            - 概念
               - 第一阶段和标记清除算法一样，从根节点开始标记所有被引用对象
               - 第二阶段将所有的存活对象压缩到内存的一端，按顺序排放之后，清理边界外所有的空间
            - 优点
               - 清除了标记-清除算法当中，内存区域分散的缺点，我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可
               - 消除了复制算法当中，内存减半的高额代价
            - 缺点
               - 从效率上来说，标记-整理算法要低于复制算法
               - 移动对象的同时，如果对象被其他对象引用，则还需要调整引用的地址
               - 移动过程中，需要全程暂停用户应用程序，即：STW
      - 分代收集算法
         - 不同的对象的生命周期是不一样的，目前所有的 GC 都是采用的分代收集算法进行垃圾回收的
         - 年轻代，生命周期短，存活率低，回收频繁，复制算法是最快的，而复制算法内存利用率不高的问题，通过 hotspot中的两个 survivor 设计得到缓解
         - 老年代，区域较大，对象生命周期长，存活率高，回收不及年轻代频繁，标记-清除或者是标记-整理的混合实现
            - Mark 阶段的开销与存活对象的数量成正比
            - Sweep 阶段的开销与所管理区域的大小成正比
            - Compact 阶段的开销与存活对象的数据成正比
         - 以 HotSpot 占的 CMS 回收器为例，CMS 是基于 Mark-Sweep实现的，对于对象的回收效率很高。而对于碎片问题，CMS采用基于Mark-Compact算法的 Serial Old
            - 回收器作为补偿措施：当内存回收不佳（碎片导致的Concurrent Mode Failure时），将采用 Serial Old 执行 Full GC 以达到对老年代内存的整理
      - 增量收集算法 和 分区算法
         - 增量收集算法
            - 垃圾回收时会进行 STW，这样会阻塞用户线程，如果垃圾回收时间过长会影响业务，所以实时垃圾收集算法的研究直接导致了增量收集算法(Incremental Collection)的诞生
            - 如果一次性将所有的垃圾进行处理，需要造成系统长时间的停顿，那么就可以让垃圾收集线程和应用程序线程交替执行。每次。垃圾收集线程只收集一小片区域的内存空间
            - 接送切换到应用程序线程。依次反复，直到垃圾收集完成
            - 总的来说，增量收集算法的基础仍是传统的标记-清除和复制算法。增量收集算法通过对线程间冲突的妥善处理，允许垃圾收集线程以分阶段的方式完成标记，清理或复制工作
            - 缺点
               - 因为线程切换和上下文转换的消耗，会使得垃圾回收的总体成本上升，造成系统吞量的下降
         - 分区收集算法
            - 一般来说，在相同条件下，堆空间越大，一次GC时所需要的时间就越长，有关GC产生的停顿也越长。为了更好地控制GC产生的停顿时间，将一块大的内存区域分割成多个小块
            - 根据目标的停顿时间，每次合理地回收若干个小区间，而不是整个堆空间，从而减少一次GC所产生的停顿
            - 分代算法将按照对象的生命周期长短划分成两个部分，分区算法将整个堆空间划分成连续的不同小区间
            - 每一个小区间都独立使用，独立回收。这种算法的好处是可以控制一次回收多少个区间


- 垃圾回收的补充
   - System.gc()
      - 默认情况下 System.gc() 或者 Runtime.getRuntime().gc() 的调用，会显式触发 Full GC，同时对老年代和新生代进行回收，
      - 尝试释放被丢弃对象占用的内存
      - 然而 System.gc() 调用附带一个免责声明，无法保证对垃圾收集器的调用
      - 使用了只是显示式尝试，并不意味着一定会执行垃圾回收，但是 System.runFinalization() 是强制调用使用引用的对象的 finalize() 方法
   - 手动 gc 理解不可达对象的回收行为
      ```
      public class LocalVarGc {
        
        public void localvarGc1() {
          byte[] buffer = new byte[10*1024*1024];
          System.gc(); // 回收不了 buffer，会发现移到了老年代
        }
        public void localvarGc2() {
          byte[] buffer = new byte[10*1024*1024];
          buffer = null;
          System.gc(); // 回收了 buffer
        }
        public void localvarGc3() {
          {
            byte[] buffer = new byte[10*1024*1024];
          }
          System.gc(); // buffer 不会被回收，会发生移到了老年代
        }
        public void localvarGc4() {
          {
            byte[] buffer = new byte[10*1024*1024];
          }
          int value = 10;
          System.gc(); // buffer 会被回收，因为 value 占据 buffer 所在的操作数栈空间的槽，以致没有地方引用 字节数组对象了（空间复用）
                       // buffer 的作用域只在 代码段，但是也占据了方法的栈空间，
                       // value 所在位置已经过了 代码段，buffer 引用其实已经不强了，所以为了空间复用就 value 占据了buffer位置，然后buffer待回收
        }
        public void localvarGc5() {
          localvarGc1(); // 这里没有回收掉 buffer
          System.gc(); // 这里才回收掉 buffer，因为 第一行代码执行完相当于 方法出栈了，即没有引用了，所以回收
        }
      ```
   - 内存溢出的分析
      - 没有空闲内存，并且垃圾收集器也无法提供更多内存就造成 OutOfMemoryError 的错误
      - 造成的原因
         1. Java 虚拟机的堆内存设置不够，可以通过 -Xms 和 -Xmx 调整
         2. 代码中创建了大量对象，并且长时间不能被垃圾收集器收集（存在被引用）
      - 在 OOM 之前，通常垃圾回收器会触发 gc 了的
      - 但是如果分配了一个超大的对象（这个对象超过堆的最大值），此时不会触发 gc
   - 内存泄漏的分析
      - 也称作“存储渗漏”，只有对象不会再被程序用到了，但是gc又不能回收它们的情况，才叫内存泄漏
      - 尽管内存泄漏并不会立刻引起程序崩溃，但是一旦发生内存泄漏，程序中可用内存就会被逐步蚕食，直至耗尽所有内存，最终出现 OutOfMemory异常
      - 举例
         - 单例生命周期和应用程序一样长，但是这个单例又引用了另一个对象，外部对象用了会儿就不再用了，那么这个外部对象是不能被回收的，则会导致内存泄漏
         - 一些close的资源未关闭连接：数据库连接(dataSource.getconnection())，网络连接(socket)和io连接必须手动 close，否则是不能被回收的
   - StopTheWorld事件的理解
      - 整个应用程序在执行中，在回收内存时需要停止应用程序的线程，没有任何响应，有点像卡死的感觉，这个停顿称为 STW
      - 可达性分析算法中枚举根节点（GC Roots）会导致所有 Java 执行线程停顿
         - 分析工作必须在一个能确保一致性的快照中进行
         - 一致性指整个分析期间整个执行系统看起来像被冻结在某个时间点上
         - 如果出现分析过程中对象引用关系还在不断变化，则分析结果的准确性无法保证
   - 程序的并行与并发
      - 在一个时间段中，几个程序都处理已启动运行到运行完毕之间，且这几个程序都是在同一个处理器上运行叫并发（在一个时间段同时发生）
      - 当系统有一个以上的cpu时，当一个cpu执行一个进程时，另一个cpu可以执行另一个进程，两个进程互不抢占同一个cpu资源，可以同时进行，我们称之为并行（在同一个时间点同时发生）
   - 垃圾回收的并行与并发
      - 此处省略
   - 安全点与安全区域
      - 安全点
         - 概念
            - 程序执行时并非在所有地方都能能停顿下来开始 gc，只有在特定的位置才能停顿下来开始 gc，这些位置称为 安全点
            - 安全点如果太少可能导致 GC 等待的时间太长，如果太频繁可能导致运行时的性能问题，大部分指令的执行时间都非常短暂，通常会根据是否具有
            - 让程序长时间执行的特征为标准，比如：选择一些执行时间较长的指令作为安全点，如方法调用，循跳转和异常跳转等
         - 如何在 GC 发生时，检查所有线程都跑到最近的安全点停顿下来呢
            - 抢先式中断（目前没有虚拟机采用）
               - 首先中断所有线程，如果还有线程不在安全点，就恢复线程，让线程跑到安全点
            - 主动式中断
               - 设置一个中断标志，各个线程运行到 安全点 的时候主动轮询这个标志。如果中断标志为真，则将自己进行中断挂起
      - 安全区域
         - 概念
            - 安全机制保证了程序执行时，在不太长的时间内就会遇到可进入 GC 的安全点，但是，程序“不执行”的时候呢？例如线程处于
            - Sleep 状态或 Blocked 状态，这时候线程无法响应 JVM 的中断请求，“走”到安全点云敁断挂起，JVM也不太可能等待线程被唤醒
            - 对于这种情况，就需要安全区域来解决
            - 安全区域是指在一段代码片段中，对象的引用关系不会发生变化，在这个区域中的任何位置开始 GC 都是安全的，我们也可以把 安全区域 看做是被扩展了的 安全点
         - 如何执行
            1. 当线程运行到 安全点 的代码时，首先标识已经进入了 安全区域，如果这段时间内发生 gc，jvm 会忽略标识为 安全区域 状态的线程
            2. 当线程即将离开 安全区域 时，会检查 jvm 是否已经完成 gc，如果完成了，则继续运行，否则线程必须等待直到收到可以安全离开 安全区域 的信号为止
      - 几种不同的引用概述
         - 我们希望能描述这样一些类对象：当内存空间足够时，能够保存在内存中；如果内存空间不足，在进行垃圾收集后还是很紧张，则可以抛弃这些对象
         - 除了强引用，其它三种都可以在 java.lang.ref 包下找到，都是继承了 Reference 抽象类的子类
         - 四种引用
            - 强引用（Strong Reference）
               - 最传统的引用的定义，是指在代码之中普通存在的引用赋值，即类似 Object obj = new Object() 这种引用关系，任何情况下，强引用只要存在就不会被回收，即使 OOM 也不回收
               - 总结：不回收
            - 软引用（Soft Reference）
               - 在系统将要发生内在溢出之前，将把这些对象列入回收范围之中进行第二次回收，如果这次回收之后还没有足够的内存，才会抛出内存溢出异常
               - 一般作用于缓存
               - 总结：内存不足即回收
            - 弱引用（Weak Reference）
               - 被弱引用关联的对象只能生存到下一次垃圾收集之前，当垃圾收集器工作时，无论内存空间是否足够，都会回收掉弱引用对象
               - 总结：发现即回收
            - 虚引用（Phantom Reference）
               - 一个对象是否有虚引用的，完全不会对其生存时间构成影响，也无法通过虚引用来获得一个对象的实例，
               - 为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知
               - 总结：对象回收跟踪
         - 引用举例
            ```
            强引用
            public void method() {
              StringBuffer str = new StringBuffer("Hello"); // str 是强引用
              StringBuffer str1 = str; // str1 是强引用
              str = null; 
              system.gc();
              try {
                Thread.sleep(3000); // 为了留时间触发 gc
              } catch (Exception e) {
                ...
              }
              System.out.println(str1); // 仍然可以打印证明 str1 是强引用
            }
            ```

            ```
            软引用
            /* **
            Object obj = new Object(); // 声明强引用
            SoftReference<Object> sf = new SoftReference<Object>(obj); // 创建了对 obj 的软引用
            obj = null; // 销毁强引用
            **/

            SoftReference<Object> sf = new SoftReference<Object>(new User("id","name")); // 创建了对 obj 的软引用，等价于上面注释部分
            System.out.println(sf.get()); // 从软引用中重新获取强引用
            System.gc(); // 触发 gc
            System.out.println(sf.get()); // 由于堆内存足够，没有回收这个软引用的可达对象

            try {
              // 让系统认为内存资源紧张，不够（测试这里需要指定堆大小为能容下 这个数组但是容不下 Object 对象）
              byte[] b = new byte[1024*1024*10] // 如果放开这里可能引起 回收软引用
            } catch (Throwable e) {
               ... 
            } finally {
              System.out.println(sf.get()); // 在报 OOM 之前，垃圾回收器会回收软引用的可达对象
            }
            ```

            ```
            弱引用
            /* **
            Object obj = new Object(); // 声明强引用
            WeakReference<Object> wr = new WeakReference<Object>(obj);
            obj = null; // 销毁强引用
            **/

            User u = new User("id","name");
            WeakReference<User> uwr = new WeakReference<>(u); // 构造弱引用
            System.out.println(uwr.get()); // 从弱引用中重新获取对象

            System.out.println("after"); 
            System.gc();
            System.out.println(uwr.get()); // 重新尝试从弱引用中获取对象，将会是 null，被回收
            ```

            ```
            虚引用
            /* **
            Object o = new Object();
            ReferenceQueue rq = new ReferenceQueue();
            PhantomReference pr = new PhantomReference(o, rq);
            o = null;
            ** /

            // *********************** 代码省略 ************************/
            ```
      - 终结器引用的介绍
         - FinalReference 实现 finalize() 方法，也可以称为终结器引用
         - 在 GC 时，终结器引用入队，由 Finalizer 线程终结器引用找到被引用对象并调用它的 finalize() 方法，第二次 GC 时才能回收被引用对象

- 垃圾回收器
   - 并发 Concurrent；并行 Parallel
   - 平衡垃圾回收器的性能指标
      - 吞吐量：运行用户代码的时间占总运行时间的比例
      - 暂停时间：执行垃圾收集时，程序的工作线程被暂停的时间
      - 内存占用：Java 堆区所占的内存大小
   - 吞吐量和暂停时间和内存占用
      - 内存占用
         - 随着硬件的提高逐渐能够忍受
      - 吞量吐
         - 就是 cpu 用于运行用户代码的时间与cpu总消耗时间的比值，即吞吐量 = 运行用户代码时间 / （运行用户代码时间+垃圾收集时间）
      - 暂停时间
         - 指一个时间段内应用程序线程暂停，让GC线程回收垃圾的时间
      - 讨论
         - 高吞吐量因为会让用户程序的最终用户感觉只有应用程序线程在做生产性工作，直觉上，吞吐量越高程序运行越快
         - 低暂停时间（低延迟）较好因为从最终用户的角度看不管是gc还是其他原因导致一个应用被挂起始终是不好的，这取决于应用程序的类型
            - 有时候甚至短暂的 200 毫秒暂停都可能打断终端用户体验，因此，具有低的较大暂停时间是非常重要的，特别是对于一个交互式应用程序
         - 高吞吐量 和 低延迟时间 是一对相互竞争的目标（矛盾）
            - 如果选择以吞吐量优先，那么必然需要降低内存回收的执行频率，但是这样会导致gc需要更长的时间执行内存回收
            - 如果选择以低延迟优先，那么为了降低每次执行内存回收时的暂停时间，也只能频繁地执行内存回收，但这又引起了年轻代内存的缩减和导致程序吞吐量下降
   - 7款经典垃圾回收器大致分类
      - 按并行和并发分类
         - 串行回收器：Serial,Serial Old
         - 并行回收器：ParNew,Parallel Scavenge,Parallel Old
         - 并发回收器：CMS(Concurrent Mark Sweep),G1
      - 按分代收集分类
         - 新生代：Serial,ParNew,Parallel Scavenge
         - 老年代：CMS,Serial Old(MSC),Parallel Old
         - 两者皆可：G1
            - jdk9中 G1 变成默认的垃圾回收器代替 CMS
   - 垃圾回收器的组合(jdk8 之前）
      - Serial GC ---> Serial Old GC
      - Serial GC 断开-> CMS GC // jdk8 中取消这个组合，但还可以用，但是jdk9中已经完全移除
      - ParNew GC ---> CMS GC
      - ParNew GC 断开-> Serial Old GC // jdk8 中取消这个组合，但还可以用，但是jdk9中已经完全移除
      - CMS GC 与 Serial Old GC 共同处理老年代// CMS 在用户线程开辟空间速度大于回收速度时可能回收失败，此时需要 Serial Old GC 停掉所有线程再回收，即这是备份方案
      - Parallel Scavenge GC ---> Parallel Old GC
      - Parallel Scavenge GC 特殊-> Serial Old GC // jdk14中弃用这个组合
      - --------------------------- CMS GC 在 jdk14 中删除了 ---------------------------

      - 如何查看默认的垃圾收集器
         - -XX:+PrintCommandLineFlags # 查看命令行相关的参数（包含使用的垃圾收集器）
         - 使用命令行指令：jinfo -flag 相关垃圾回收器参数 进程ID
            - 例如：jinfo -flag UseG1GC 进程号 # 如果输出有+号则是使用的G1GC
   - 经典垃圾回收器组合的分别介绍
      1. Seria
         - 是基本，历史最悠久的垃圾收集器，JDK1.3之前回收新生代唯一的选择，作为 HotSpot 中 Client 模式下默认新生代垃圾收集器
         - 收集器采用复制算法，串行回收和 STW 机制的方式内存回收，
         - 老年代选择
            - 提供了 Serial Old GC 处理老年代，同样也采用了串行回收和 STW 机制，只不过内存回收算法使用的是标记-压缩算法
         - 优劣
            - 简单高效（与其他收集器的单线程比），对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然获得最高单线程收集效率
            - 运行在 client 模式下的虚拟机是不错的选择
            - 在用户的桌面应用场景中，可用内存不大（几十mb至一两百mb)，可以在较短时间内完成垃圾收集（几十ms至一百多ms），只要不频繁发生，使用串行回收器是可以接受的
            - HotSpot 虚拟机中，使用 -XX:+UseSerialGC 参数可以指定年轻代和老年代使用串行收集器
               - 等价于 新生代用 Serial GC，且老年代用 Serial Old GC
      2. ParNew
         - 如果说 Serial GC 是年轻代中单线程垃圾收集器，那么 ParNew 收集器则是 Serial 收集器的多线程版本
         - Par 是 Parallel 的缩写，New：只能处理的是新生代
         - ParNew 收集器除了采用并行回收的方式执行内存回收外，两款垃圾收集器之间几乎没有任何区别。ParNew收集器在年轻代中同样也是采用复制算法 STW 机制
         - ParNew 是很多 JVM运行在Server模式下新生代的默认垃圾收集器
         - 老年代选择（选择其一）
            - CMS GC(-XX:+UseConcMarkSweepGC 显式使用)
            - Serial Old GC
         - 优劣
            - 运行在多cpu环境下，由于可以充分利用多cpu多核心等物理硬件资源优势，可以更快地完成垃圾收集，提升程序的吞量
            - 但是在单个cpu环境下，比不过 Serial 收集器，虽然 Serial 收集器是基于串行回收，但是由于 cpu不需要频繁地做任务切换，因此可以有效避免多线程交互过程中产生的额外开销
         - 比较
            - 对于新生代，回收次数频繁，使用并行方式高效
            - 对于老年代，回收次数少，使用串行方式节省资源（cpu并行需要切换线程，串行可以省去切换线程的资源）
         - 配置
            - -XX:+UseParNewGC 手动指定使用 ParNew 收集器执行内存回收任务，它表示年轻代使用并行收集器，不影响老年代
            - -XX:ParallelGCThreads 限制线程数量，默认开启和cpu数量相同的线程数
      3. Parallel Scavenge 回收器
         - 吞吐量优先，
         - HotSpot 的年轻代中除了拥有 ParNew 收集器是基于并行回收的以外，Parallel Scavenge 收集器也同样也采用了复制算法，并行回收和 STW 机制
         - 和 ParNew 收集器不同，Parallel Scavenge 收集器的目标是达到一个可控制的吞吐量，它也被称为吞吐量优先的垃圾收集器
         - 自适应调节策略也是 Parallel Scavenge 与 ParNew 一个重要区别
         - 采用了 标记-压缩算法，但同样也是基于并行回收和 STW 机制
         - 老年代选择
            - Parallel Old GC
         - 优劣
            - 高吞吐量则可以高效率利用 cpu 时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务，因此，常见在服务器环境中
            - 使用。例如，那些执行批处理，订单处理，工资支付，科学计算的应用程序
         - 老年代选择
            - 在 JDK1.6 时提供了用于执行老年代垃圾收集器的 Parallel Old 收集器，用来代替老年代的 Serial Old 收集器
            - Serial Old
            - 注意没有选择 CMS，是因为两者的实现框架不一致，所以无法共用
         - 对比
            - 在程序吞吐量优先的应用场景中，Parallel 收集器和 Parallel Old 收集器的组合，在 Server 模式下的内存回收性能很不错
            - 在 Java8 中，默认是此垃圾收集器
         - 参数设置
            - -XX:+UseParallelGC 手动指定年轻代使用 Parallel 并行收集器执行内存回收任务
            - -XX:+UseParallelOldGC 手动指定老年代都是使用并行回收收集器
               - 分别适用于新生代和老年代，默认jdk8是开启的
               - 上面两个参数，默认开启一个，另一个也会被开启（互相激活）
            - -XX:ParallelGCThreads 设置年轻代并行收集器的线程数，一般地最好与cpu数量相等，以避免过多的线程数影响垃圾收集性能
               - 在默认情况下，当 cpu 数量小于8个，ParallelGCThreads 的值等于 cpu 数量
               - 当 cpu数量大于 8 个，ParallelGCThreads 的值等于 3+[(5*cpu_count)/8]
            - -XX:MaxGCPauseMillis 设置垃圾收集器最大停顿时间（即stw时间，单位是毫秒）
               - 为了尽可能地把停顿时间控制在 MaxGCPauseMills 以内，收集器在工作去调整 java 堆大小或者其他一些参数
               - 对于用户来讲，停顿时间越短体验越好，但是在服务器端。我们注重高并发，整体的吞量，所以服务器端适合Parallel进行控制
               - 该参数需谨慎
            - -XX:GCTimeRatio 垃圾收集时间占总时间的比例（=1/(N+1))用于衡量吞吐的大小
               - 取值范围(0,100)。默认值 99，也就是垃圾回收时间不超过 1%
               - 与前一个 -XX:MaxGCPauseMillis 参数有一定矛盾性，暂停时间越长，Radio参数就容易超过设定的比例
            - -XX:+UseAdaptiveSizePolicy 设置 Parallel Scavenge 收集器具有自适应调节策略
               - 在这种模式下，年轻代的大小，Eden和Survivor的比例，晋升老年代对象年龄等参数会被自动调整，已达到在堆大小，吞吐量和停顿时间之间的平衡点
               - 在手动调优比较困难的场合，可以直接使用这种自适应的方式，仅指定虚拟机的最大堆，目标的吞吐量和停顿时间，让虚拟机自己完成调优工作
      4. CMS 回收器：低延迟，并发收集
         - 概念
            - Concurrent-Mark-Sweep，是 HotSpot 虚拟机中第一款真正意义上的并发收集器，第一次实现了让垃圾收集线程与用户线程同时工作
            - 尽可能地缩短垃圾收集时用户线程的停顿时间，停顿时间越短，就越适合用户交互的程序。良好的响应速度能提升用户体验
            - 很大一部分 java 应用集中在互联网或者 B/S 系统的服务器上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短。给用户带来较好的体验
            - 采用 标记-清除算法，并且也有 STW 机制
            - 不幸的是 CMS 作为老年代收集器，却无法与 jdk1.4.0 中已经存在的新生代收集器 Parallel Scavenge 配合工作，
            - 所以在 jdk1.5 中使用 CMS 来收集老年代时，新生代只能选择 ParNew 或者 Serial 收集器中一个
            - G1 出现之前，CMS 使用还是非常广泛的，一直到今天，仍然有很多系统使用 CMS GC
         - 标记过程，比之前的收集器要复杂，整个过程分为4个主要阶段
            - 初始标记
               - 初始标记(STW)
                  - 程序中所有的工作线程都 STW 而出现短暂暂停，这个阶段的主要任务仅仅只是标记出 GC Roots 能直接关联的对象，一旦标记完成就恢复之前所有用户线程
                  - 由于直接关联对象比较小，所以这里的速度非常快
               - 并发标记
                  - 从 GC Roots 的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长，但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行
               - 重新标记(STW)
                  - 由于并发标记阶段中，用户线程会和垃圾收集同时运行或交叉运行，因此修正并发标标记期间因用户线程继续运作而导致标记产生变动的那一部分
                  - 这阶段的停顿时间通常会比初始标记阶段稍长，但也远比并发标记阶段时间短
               - 并发清除
                  - 清理删除掉标记阶段判断的已经死亡的对象，释放内存空间，由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的
               - 重置线程
                  - 恢复正常的用户线程执行
         - 利弊分析
            - 优点
               - 并发收集
               - 低延迟
            - 弊端
               - 产生内存碎片
               - 对cpu资源非常敏感
               - 无法处理浮动垃圾
            - 分析
               - 由于 垃圾收集阶段用户线程没有中断，所以回收时应试保证用户线程有足够的内存可用。CMS 不能像其他收集器那样等到老年代不够用再进行收集，而是当堆内存使用率
               - 到达一定 阈值 时，便开始进行回收以确保应用程序在 CMS 工作中有足够空间支持应用程序，要是 CMS 运行期间内存无法满足程序需要，就会出现一次 Concurrent Mode Failure
               - 失败，这个时候虚拟机将启动后备方案，临时启用 Serial Old 收集器重新进行老年代垃圾收集。这样停顿时间就很长
                  - 采用的标记-清除算法，意味着每次执行完内存回收后，由于会产生碎片，那么 CMS 在为新对象分配内存空间时，将无法使用指针碰撞技术，而只能够选择空闲列表执行分配
                  - 因为垃圾收集时，用户线程在执行，所以无法使用标记整理法，因为标记整理法会移动用户线程存活的对象
               - 因为垃圾收集和用户线程在同时运行，所以没法使用 标记-压缩 算法，只能是 标记-清除 算法
         - 参数设定
            - -XX:+UseConcMarkSweepGC 手动指定使用 CMS 收集器执行内存回收任务
               - 开启该参数后会自动将 -XX:+UseParNewGC 打开，即：ParNew(Young区用）+CMS(Old区用)+Serial Old 备用老年代
            - -XX:CMSSlnitialingOccupanyFraction
               - 设置堆内存使用率的阈值，到达了阈值，便开始回收
               - jdk5及之前版本默认为 68，即当老年代空间使用率达到68%时，会执行一次 CMS 回收，JDK6及以上版本默认为 92%
               - 如果内存增长缓慢，则可以设置一个稍大的值，大的阈值可以有效降低 CMS 换触发频率，减少老年代回收次数可以较为明显发送应用程序性能。
               - 反之，如果应用程序内存使用率增长很快，则应该降低这个阈值，以避免频繁触发老年代串行收集器，因此通过该选项便可以有效降低 full gc 的次数
            - -XX:+UseCMSCompactAtFullCollection 指定在执行完 full gc 后对内存空间进行压缩整理，避免内存碎片的产生，不过由于内存压缩整理过程无法并发执行，所带来的问题就是停顿时间更长
            - -XX:CMSFullGCsBeforeCompaction 设置在执行多少次 Full GC 后对内存空间进行压缩整理
            - -XX:ParallelCMSThreads 设置 CMS 的线程数量，CMS 默认启动的线程数是 (ParallelGCThreads+3)/4
               - ParallelGCThreads 是年轻代并行收集器的线程数。当 CPU 资源比较紧张时，受到 CMS 收集器线程的影响，应用程序的性能在垃圾回收阶段可能会非常糟糕
         - 总结
            - 最小化使用内存和并行开销首选：Serial GC
            - 最大化应用程序的吞量首选：Parallel GC
            - 最小化GC的中断或停顿时间首选（减少延迟）：CMS GC

      5. G1 收集器（区域化分代式）
         - 概述
            - 目标是在低延迟可控的情况下获得尽可能高的吞吐量，所以才担当起“全功能收集器”的重任与期望
            - 是一个并行回收器，把堆内存分割为很多不相关的区域（Region），物理上不连续的。使用不同的 Region来表示Eden，幸存者0区，幸存者1区，老年代等
            - 有计划地避免 Full GC，跟踪各个 Region 里面的垃圾堆积价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表
            - 每次根据允许的收集时间，优先回收价值最大的 Region
            - 这种方式的侧重点在于回收垃圾最大量的区间，所以我们给G1一个名字：垃圾优先（Garbage First）
            - 在 jdk9 以后的默认垃圾回收器，取代了 CMS 和 Parallel + Parallel Old 组合，被官方称为 “全功能的垃圾收集器”
         - 优点
            - 并行与并发
               - 并行性：G1 在回收期间，可以有多个 GC 线程工作，有效利用多核计算能力，此时用户线程 STW
               - 并发性：拥有与应用程序交替执行的能力，部分工作可以和应用程序同时执行，因此，一般来说，不会在整个回收阶段发生完全阻塞应用程序的情况
            - 分代收集
               - 依然属于分代型垃圾回收器，它区分年轻代与老年代，年轻代依然有 Eden 区和 Survivor 区，但从堆结构看，它不要求整个 Eden 区，年轻代或者
                  - 老年代都是连续的，也不再坚持固定大小和固定数量
               - 将堆空间分配为若干个区域（Region），这些区域中包含了逻辑上的年轻代和老年代
               - 和之前的各类回收器不同，它同时兼顾年轻代和老年代，对比其他回收器，或者工作在年轻代，或者工作在老年代
            - 空间整合
               - CMS: 标记-清除 算法，内存碎片，若干次 GC 后进行一次碎片整理
               - G1 将内存划分为一个个的 region，内存的回收是以 region 作为单位的，Region 之间是复制算法，但整体上实际可看作是标记-压缩算法
               - 两种算法都可以避免内存碎片，这种特性有利于程序长时间运行。分配大对象不会因为无法找到连续内存空间而提前触发下一次 GC，java 堆非常大时，G1优势更加明显
            - 可预测停顿时间模型
               - 除了追求低停顿之外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在垃圾收集上的时间不得超过 N 毫秒
                  - 由于分区原因，只选取部分区域回收，这样缩小了回收的范围，因此对于全局停顿情况的发生也得到较好控制
               - 跟踪各个 Region 的垃圾堆积价值大小（回收所获得的空间大小及回收所需时间的经验值）。在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的
                  - 保证了有限时间内可以获取尽可能高的收集效率
               - 相比于 CMS GC，G1 未必能做到 CMS 在最好情况下的延时停顿，但是在最差情况要好很多
         - 缺点
            - 相较于 CMS,G1 还不具备全方位，压倒性优势。比如在用户程序运行过程中G1无论是为了垃圾收集产生的内存占用。还是程序运行时的额外执行负载都比 CMS 要高
            - 从经验上来说，在小内存应用上 CMS 的表现大概率会优于 G1，而 G1 大内存应用上则发挥其优势，平衡点在 6-8GB 之间
         - 参数设置
            - -XX:+UseG1GC 手动指定使用G1收集器执行内存回收
            - -XX:G1HeapRegionSize 设置每个 Region 大小，值是2的幂，范围是 1MB到32MB之间，目标是根据最小的java堆大小划分出约2048个区域，默认是堆内存的 1/2000
            - -XX:MaxGCPauseMillis 设置期望达到的最大GC停顿时间指标（jvm会尽力实现，但不保证达到），默认是 200ms
            - -XX:ParallelGCThread 设置 STW 工作线程数值，最多设置为8
            - -XX:ConcGCThreads 设置并发标记的线程数，将 n 设置为并行垃圾回收线程数的 1/4 左右
            - -XX:InitiatingHeapOccupancyPercent 设置触发并发 GC 周期的 JAVA 堆占用率阈值，超过此值。就触发 GC，默认值 45
         - 使用场景
            - 面向服务端，大内存，多处理器的机器适合（普通大小的堆里表现并不惊喜）
         - Region
            - 每个 Region 块大小根据堆空间的实际大小而定，整体被控制在 1MB 到 32MB 之间，且为 2 的 N次幂。所有的Region大小相同，且在JVM生命周期内不会被改变
               - 可以通过 -XX:G1HeapRegionSize 设定大小
            - 虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分 Region的集合，通过 Region 的动态分配方式实现逻辑上的逻辑
            - 一个 Region 只能是 Eden,survivor,old 内存区域之一（角色可以转变），
            - 但是G1还增加了新的内存区域叫 Humongous 内存区域，存储大对象，如果超过 1.5 个 region 就放到这里面
            - 堆中的大对象，默认直接分配到老年代。但是如果它是个短期存在的大对象，就会对垃圾回收造成负面影响，所以划分了个 Humongous 区专门存大对象
               - 如果一个 H 区装不下就找连续的 H 区存储。为了找到连续的 H 区存储，有时不得不启动 Full GC，G1 大多数行为都把 H 区作为老年代的一部分看待
            - 使用场景
               - 面向服务端应用，针对具有大内存，多处理器的机器。（在普通大小的堆里表现并不惊喜）
               - 最主要的应用是需要低GC延迟，并具有大堆的应用程序提供解决方案：
                  - 如：在堆大小约6GB或更大时，可预测的暂停时间可以低于0.5秒；（G1通过每次只清理一部分而不是全部的Region的增量式清理来保证每次gc停顿时间不会过长）
               - 用来替换掉JDK1.5中的CMS收集器，在下面的情况时，使用G1可能比CMS好：
                  - 超过50%的Java堆被活动数据占用
                  - 对象分配频率或年代提升频率变化很大
                  - GC停顿时间过长（长于0.5至1秒）
               - HopSpot 垃圾收集器里，除了 G1 以外，其它的垃圾收集器使用内置的JVM线程执行GC的多线程操作，而 G1 GC 可以采用应用线程承担后台运行的 GC 工作，即当JVM的GC线程处理速度慢时，系统会调用应用程序线程帮助加速垃圾回收过程
         - 记忆集与写屏障
            - 概念
               - 一个Region 可能被其它 Region 引用，如果要判断是否可达，没必要查询整个堆，如果每次判断是否可达就全扫整个堆非常耗性能
               - 无论 G1 还是其他分代收集器，JVM 都是使用 Remembered Set 来避免全局扫描
               - 每个 Region 都有一个对应的 Remembered Set
               - 每次 Reference 类型数据写操作时，都会产生一个 Write Barrier 暂时中断操作
               - 然后检查将要写入的引用指向的对象是否和该 Reference 类型数据在不同的 Region（其他收集器：检查老年代对象是否引用了新生代对象）
               - 如果不同，通过 CardTable 把相关引用信息记录到引用指向对象的所在 Region 对应的 Remembered Set 中
               - 当进行垃圾收集时，在 GC 根节点的枚举范围加入 Remembered Set，就可以保证不进行全局扫描，也不会有遗漏
            - 图示
               ```
               X 表示未使用，O 表示已使用
                      引用                引用        
                 *----------------* *----------------*
                 |                | |                |
                 |                v v                |
               XXOXX             XOXOX             XXOXX
                 |                                   | 
                 |    记录              记录         |
                 *---------------*   *---------------*
                                 |   |                
                                 v   v                  
               记忆集            记忆集            记忆集
               ```
         - 回收细节
            - 主要的三个环节
               1. 年轻代
                  - JVM 启动时，G1先准备好 Eden 区，程序在运行过程中不断创建对象到 Eden 区，当 Eden 空间耗尽时，G1 会先启动一次年轻代垃圾回收过程
                  - 年轻代垃圾回收只会回收 Eden 区和 Survivor 区
                  - YGC 时，首先 G1 停止应用程序的执行(STW)，G1创建回收集(Collection Set)，回收集是指需要被回收的内存分段的集合，
                  - 年轻代回收过程的回收集包含年轻代Eden区和Survivor区所有的内存分段
               2. 老年代并发标记过程
                  - 当堆内存使用达到一定值（默认45%）时，开始老年代并发标记过程
               3. 混合回收
                  - 当标记完成马上开始混合回收过程，对于一个混合回收期，G1 从老年区移动存活对象到空闲区，这些空闲区间也成为了老年代的一部分，和年轻代不同，老年代的G1回收器和
                  - 其它GC不同，G1的老年代回收器不需要整个老年代被回收，一次只需要扫描/回收一小部分老年代的Region就可以了，同时，这个老年代Region是和年轻代一起被回收的
                  - 举例
                     - 一个web服务器，java进程最大堆内存4G，每分钟响应 1500 请求，每45秒钟会新分配大约2G的内存，G1会每45秒进行一次年轻代回收，每31小时整个堆的使用率会达到45%
                     - 会开始老年代并发标记过程。标记完成后开始四到五的混合回收
               4. （如果需要，单线程，独占式，高强度的 Full GC 还是继续存在的，它针对 GC 评估失败提供了一种失败保护机制，即强力回收）
         - 垃圾回收过程的详细描述
            1. 回收过程1：年轻代 GC
               - 扫描根：根是指 static 变量指向的对象，正在执行的方法调用链条上的局部变量等，根引用连同 RSet 记录的外部引用作为扫描存活对象的入口
               - 更新RSet：处理 dirty card queue 中的 card，更新 RSet。此阶段完成后，RSet可以准确的反映老年代所在的内存分段中对象的引用
               - 处理RSet：识别被老年代对象指向的Eden中的对象，这些被指向的Eden中的对象被认为是存活的对象
               - 复制对象：此阶段，对象树被遍历，Eden区内存段中存活的对象会被复制到Survivor区中空的内存分段，Survivor区内存段中存活的对象如果年龄未达到阈值，年龄增1,达到阈值会
                  - 被复制到 Old 区空的内存分段。如果Survivor空间不够，Eden空间的部分数据会直接晋升到老年代空间
               - 处理引用：处理 Soft, Weak, Phantom, Final, JNI Weak 等引用。最弱终 Eden 空间的数据为空，GC停止工作，而目标内存中的对象都是连续存储的，没有碎片，
                  - 所以复制过程可以达到内存整理
                  - 对于应用程序的引用赋值语句 object.field=object, JVM会在之前和之后执行特殊的操作以在 dirty card queue 中入队一个保存了对象引用信息的 card。在年轻代回收的时候
                  - G1 会对 dirty card queue 中所有的 card 进行处理，以更新 RSet，保证 RSet 实时准确的反映引用关系
                  - 那么为什么不在引用赋值语句处理直接更新 RSet 呢？这是为了性能的需要，RSet 的处理需要线程同步，开销会很大，使用队列性能会好很多
   
            2. 回收过程2：并发标记过程
               - (STW)初始化标记：标记根节对象。这个阶段是 STW 的，并且会触发一次年轻代 GC
               - 根区域扫描：GC 扫描 Survivor 区直接可达老年代区域对象（初始标记存活对象指向老年代的引用），并标记被引用的对象。这一过程必须在 young GC 之前完成
               - 并发标记：在整个堆中进行并发标记（和应用程序并发执行），此过程可能被 young GC 中断。在并发标记阶段，若发现
                  - 区域对象中所有对象都是垃圾，那这个区域会被立即回收。同时，并发标记过程中，会计算每个区域的对象活性（区域中存活对象的比例）
               - (STW)再次标记：需要修正上一次标记结果，是 STW 的。G1 中采用了比 CMS 更快的初始快照算法 snapshot-at-the-beginning(SATB)
                  - 在开始标记的时候生成一个快照图标记存活对象
                  - 在并发标记的时候所有被改变的对象入队（在 write barrier 里把所有旧的引用指向的对象都变成非白的颜色）
                  - 可能存在游离的垃圾，将在下次被收集
               - (STW)独占清理：计算各个区域的存活对象的GC回收比例，并进行排序，识别可以混合回收的区域。为下阶段做铺垫。是STW的
                  - 这个阶段并不会实际上去做垃圾收集
               - 并发清理：识别并清理完全空闲的区域
   
            3. 混合回收
               - 概念
                  - 当越来越多对象晋升到老年代时，为了避免堆内存耗尽，虚拟机触发一个混合的垃圾收集器，即Mixed GC，该算法并不是一个 Old GC
                  - 除了回收整个 Young Region 还会回收一部分的 Old Region 这个需要注意：是一部分老年代，而不是全部老年代。可以选择哪些 Old Region
                  - 进行收集，从而可以对垃圾回收的耗时时间进行控制，也要注意的是 Mixed GC 并不是 Full GC
               - 细节
                  - 并发标记结束以后，老年代中百分百为垃圾的内存分段被回收了，部分为垃圾的内存分段被计算了出来。默认情况下，这些老年代的内存分段会分8次
                     - 可以通过 -XX:G1MixedGCCountTarget 设置）被回收
                  - 混合回收的回收集（Collection Set）包括八分之一的老年代内存分段，Eden区内存分段，Survivor区内存分段。混合回收的算法和年轻代回收的算法完全一样
                     - 只是回收集多了老年代的内存分段。
                  - 由于老年代中的内存分段默认分8次回收，G1会优先回收垃圾多的内存分段。垃圾占内存分段比例越高的，越会被先回收并且有一个阈值会决定内存分段是否被回收
                     - -XX:G1MixedGCLiveThresholdPercent，默认为 65%，意思是垃圾占内存分段比例要达到 65% 才会被回收。如果垃圾占比太低，意味着存活的对象占比高，在复
                     - 制的时候会花费更多的时间
                  - 混合回收并不一定要进行8次。有一个阈值 -XX:G1HeapWastePercent，默认值为 10%，意思是允许整个堆内存中有 10% 的空间被浪费，意味着如果发现可以回收的
                     - 垃圾占堆内存的比例低于 10%，则不再进行混合回收。因为 GC 会花费很多的时间但是回收到的内存却很少
            - Full GC
               - G1 的初衷就是要避免 Full GC 的出现，但是如果上述方式不能正常工作，G1 会停止应用程序的执行 STW，使用单线程的内在回收算法进行垃圾回收，
                  - 性能会非常差，应用程序停顿时间会很长
               - 要避免 Full GC 的发生，一旦发生需要进行调整，什么时候会发生 Full GC 呢？比如堆内存太小，当 G1 在复制存活对象的时候没有空的内存分段可用
                  - 则会回退到 Full GC，这种情况可以通过增大内存解决
               - 导致 G1 Full GC 的原因可能有两个
                  - Evacuation 的时候没有足够的 to-space 来存放晋升的对象
                  - 并发处理过程完成之前空间耗尽

   - 七种垃圾回收总结
      ```
      垃圾收集器    分类           作用位置              使用算法                特点          适用场景
      Serial        串行运行       作用于新生代          复制算法                响应速度优先  适用于单cpu环境下的client模式
      ParNew        并行运行       作用于新生代          复制算法                响应速度优先  多cpu环境Server模式下与CMS配合使用
      Parallel      并行运行       作用于新生代          复制算法                吞吐量优先    适用于后台运算而不需要太多交互的场景
      Serial Old    串行运行       作用于老年代          标记-压缩算法           响应速度优先  适用于单cpu环境下client模式
      Parallel Old  并行运行       作用于老年代          标记-压缩算法           吞吐量优先    适用于后台运算而不需要太多交互的场景
      CMS           并发运行       作用于老年代          标记-清除算法           响应速度优先  适用于互联网或B/S业务
      G1            并发，并行运行 作用于新年代，老年代  标记-压缩算法，复制算法 响应速度优先  面向服务端应用
      ```

- 日志分析
   - 一些参数
      - -XX:+PrintGC # 输出GC日志。类似：-verbose:gc
      - -XX:+PrintGCDetails # 输出gc的详细日志
      - -XX:+PrintGCTimeStamps # 输出GC的时间戳（以基准时间的形式）
      - -XX:+PrintGCDateStamps # 输出GC的时间戳（以日期的形式，如 2013-05-04T21:22:22.234+0800)
      - -XX:+PrintHeapAtGC # 在进行GC的前后打印出堆的信息
      - -Xloggc:../logs/gc.log # 日志文件的输出路径
   - 日志的部分分析
   - 日志的补充说明
      - “[GC” 和 “[Full GC” 说明了这次垃圾收集的停顿类型，如果有 Full 则说明 GC 发生了 Stop The World
      - 使用 Serial 收集器在新生代和名字是 Default New Generation，因此显示的是 [DefNew
      - 使用 ParNew 收集器在新生代的名字会变成 [ParNew，意思是 Parallel New Generation
      - 使用 Parallel Scavenge 收集器在新生代的名字是 [PSYoungGen
      - 老年代的收集和新生代道理一样，名字也是收集器决定的
      - 使用 G1 收集器的话，会显示为 garbage-first heap
      - 通过 -XX:+PrintGCDetails 或 -XX:+PrintGC 打印出来的日志中
         - 堆内存概述
            ```
            Allocation Failure # 表明本次引起 GC 的原因是因为在年轻代中没有足够的空间能够存储新的数据了
            user 代表用户态回收耗时，sys内核态回收耗时，rea实际耗时。由于多核的原因，时间总和可能会超过 real 时间
            ```

            ```
            新生代GC
            [GC [PSYoungGen: 5986K->696k(8704K)] 5986K->704K(9216K),0.0209890 secs][Times:user=0.03 sys=0.00,real=0.02 secs]
            [GC [收集器呁: YoungGC前新生代占用->YoungGC后新生代占用(新生代总大小)]YoungGC前JVM堆占用->YoungGC后JVM堆内存使用(JVM堆总大小),YoungGC耗时秒](Times:YoungGC用户耗时 sys=YoungGC系统耗时,YoungGC实际耗时]

            老年代GC
            [Full GC (System) [PSYoungGen:3408k->0k(28888k)][psoLDgEN:0K->333K(33333K)]3408K->338k(83838k)[PSPermGen:10101K->28181k(2222222k)], 0.3333secs] [Times: user=0.03 sys=0.02, real=0.05 secs]
            [GC类型 (System) [Young区: GC前Young区内存占用->GC后Young区内存占用(Young区总大小)][Old区:GC前Old区内存占用->GC后Old内存占用(Old区总大小)]GC前堆内存占用->GC后堆内存占用(JVM堆总大小)[Perm区: GC前内存占用->GC后内存占用(Perm区总大小)],GC耗时] [Times:user=用户时间 sys=系统时间, real=实际时间]
            ```

            ```
            如果 新生代分配10m，老年代分配10m，eden:s0:s1 = 8:1:1，有如下代码：
            byte[] b = new byte[1024 * 1024 * 2];
            byte[] b2 = new byte[1024 * 1024 * 2];
            byte[] b3 = new byte[1024 * 1024 * 2];
            byte[] b4 = new byte[1024 * 1024 * 4];
            在 jdk7 和 jdk8 中有区别
            jdk7 中是，eden 区中 先装 2m + 2m + 2m，装 4m 时发现装不下，所以 三个 2m 进入老年区，4m进入 eden
            jdk8 中是，eden 区中 先装 2m + 2m + 2m，装 4m 时发现装不下，4m 直接进入老年区

            Heap 内存分析（这里举例）
            def new generation # 这里用的 Serial GC，所以简称 Default
            通常 total 的数据 和 分配的堆大小 != total， 而 eden + from = total，因为 幸存区有一个空间没有使用，所以 total = eden + from
            但是如果 eden + from + to 就等于自己分配的新生代的大小

            tenured/old generation # 老年代相关
            compacting perm gen # 类信息相关
            ```
      - 常见的日志分析工具
         - GCViewer, GCEasy, GCHisto, GCLogViewer, Hpjemter, garbagecat 等
      - 举例
         ```
         class Father {
           int x = 10;
           public Father() {
             this.print();
             x = 20;
           }
           public void print() {
             System.out.println("Father.x=" + x);
           }
         }
         class Son extends Father {
           int x = 30;
           public Son() {
             this.print();
             x = 40;
           }
           public void print() {
             System.out.println("Son.x=" + x);
           }
         }
         class Test {
           public static void main(String[] args) {
             Father f = new Father();
             System.out.println(f.x);
             /* **
             Father.x=10
             20
             ** */

             Father s = new Son();
             System.out.println(s.x);
             /* **
             Son.x = 0
             Son.x = 30
             20
             ** */
             /* **
             创建的对象是 Son，根据创建代码先调用 Son 的无参构造方法，而构造方法中隐式调用父类的无参构造即Father()
             根据 Father() 先调用 print()，但由于对象是 Son，重写了 print()，所以实际调用的是 Son 的 print()
             由于 Son print() 打印 x，而这个 x 是 Son 的 x，此时还未初始化，所以打印 0
             然后 对父类的 x 赋值为 40
             然后初始化 Son 的 x 为 30
             然后调用 Son 的 print()，所以打印 30
             然后给 Son 的 x 赋值为 40
             但是由于 Son 对象赋给了 Father 类型，所以主代码中打印 s.x 实际上是打印的 Father 的 x，所以结果为 20
             ** */
           }
         }
         ```

   - 字节码的内容
      ```
      # 注意 u数字，表示几个字节表示一个内容
      类型            名称                 说明                      长度   数量
      u4              magic                魔数，识别Class文件格式   4字节  1
      u2              minor_version        副版本号（小版本）        2字节  1
      u2              major_version        主版本号（大版本）        2字节  1
      u2              constant_pool_count  常量池计数器              2字节  1
      cp_info         constant_pool        常量池表                  n字节  constant_pool_count - 1
      # 注意 constant_pool_count 是从 1 开始，如果是 22 则实际上只有 21 项常量，索引范围为 1-21
      # 因为通常我们写代码时都是从0开始的，但是这里的常量池却是从1开始，因为它把第0项常量空出来了，这是为了
      # 满足后面某些指向常量池的索引值的数据在特定情况下需要表达“不引用任何一个常量池项目”的含义，这种情况
      # 用索引值0来表
      u2              access_flags         访问标识                  2字节  1
      u2              this_class           类索引                    2字节  1
      u2              super_class          父类索引                  2字节  1
      u2              interfaces_count     接口计数器                2字节  1
      u2              interfaces           接口索引集合              2字节  interfaces_count
      u2              fields_count         字段计数器                2字节  1
      u2              fields               字段表                    n字节  fields_count
      u2              methods_count        方法计数器                2字节  1
      method_info     methods              方法表                    n字节  methods_count
      u2              attributes_count     属性计数器                2字节  1
      attribute_info  attributes           属性表                    n字节  attributes_count
      ```

      ```
      类型的描述符
      B 基本数据类型 byte
      C 基本数据类型char
      D 基本数据类型double
      F 基本数据类型float
      I 基本数据类型int
      J 基本数据类型long
      S 基本数据类型short
      Z 基本数据类型 boolean
      V 代表 void 类型
      L 对象类型，比如：Ljava/lang/Object;
      [ 数组类型，代表一维数组。比如：double[][][] is [[[D
      ```

      ```
      访问标识（access_flag, 访问标志， 访问标记）
      ACC_PUBLIC      0x0001 标志为public类型
      ACC_FINAL       0x0010 标志被声明为final，只有类可以设置
      ACC_SUPER       0x0020 标志允许使用invokespecial字节码指令的新语义，JDK1.0.2之后编译出来的类的这个标志默认为真。（使用增强的方法调用父类方法）
      ACC_INTERFACE   0x0200 标志这是一个接口
      ACC_ABSTRACT    0x0400 是否为abstract类型，对于接口或者抽象类来说，次标志值为真，其他类型为假
      ACC_SYNTHETIC   0x1000 标志此类并非用户代码产生（即：由编译器产生的类，没有源码对应）
      ACC_ANNOTATION  0x2000 标志这是一个注解
      ACC_ENUM        0x4000 标志这是一个枚举
      ```

      ```
      部分字节码指令
      局部变量压栈指令将给定的局部变量表中的数据压入操作数栈
      局部变量压栈
         xload_<n> (x 为 i,l,f,d,a, n 为 0 到 3)
         xload n (x 为 i,l,f,d,a)
         # x 的符号表示 int,long,floag,double,引用
         # 指令 xload_n/xload n 表示将第n个局部变量压入操作数栈，比如 iload_1, fload_0, aload_0, dload 3 等

      常量入栈指令
      常量入栈指令的功能是将常数压入操作数栈，根据数据类型和入栈内容的不同，又可以分为 const系列，push系列 和 ldc指令
      1. 指令 const系列：用于对特定的常量入栈，入栈的常量隐含在指令本身里。指令有：iconst_<i>(i从 -1 到 5), lconst_<l>(l从0到1),fconst_<f>(f从0到2),dconst_<d>(d从0到1),aconst_null
         比如：
            iconst_m1 将 -1 压入操作数栈
            iconst_x (x为0到5) 将x压入栈
            lconst_0,lconst_1分别将长整数0到1压入栈
            fconft_0,fconst_1,fconst_2分别将浮点数0,1,2压入栈
            dconst_0和dconst_1分别将double型0和1压入栈
            aconst_null将null压入操作数栈
            # 从指令的命名上不验证找出规律，指令助记符的第一个字符总是喜欢表示数据类型，i表示整数，l表示长整数，f表示浮点数，d表示驭精度浮点，习惯上用a表示对象引用。如果指令隐含操作的参数
            # 会以下划线形式给出
      2. 指令push系列：主要包括 bipush和sipush。它们的区别在于接收数据类型的不同，bipush接收8位整数作为参数，sipush接收16位整数，它们都将参数压入栈
      3. 指令ldc系列：如果以上指令都不能满足需求，那么可以使用万能的ldc指令，它可以接收一个8位的参数，该参数指向常量池中的int,float或者String的索引，将指定的内容压入堆栈
         类似的还有 ldc_w，它接收两个8位参数，能支持的索引范围大于ldc
         如果要压入的元素是long或者double类型的，则使用ldc2_w指令，使用方式都是类似的
      ```

      ```
      出栈装入局部变量表指令
      出栈装入局部变量表指令用于将操作数栈中栈顶元素弹出后，装入局部变量表的指定位置，用于给局部变量赋值
      这类指令主要以 store 的形式存在，比如 xstore (x为i,l,f,d,a), xstore_n (x为i,l,f,d,a, n 为 0 至 3)
         其中，指令 istore_n 将从操作数栈中弹出一个整数，并把它赋值给局部变量索引 n 位置
         指令 xstore 由于没有隐含参数信息，故需要提供一个 byte 类型的参数类指定目标局部变量表的位置

      说明：
         一般说来，类似像 store 这样的命令需要带一个参数，用来指明将弹出的元素放在局部变量表的第几个位置，但是，为了尽可能压缩指令大小，使用专门的 istore_1 指令表示将弹出的
         元素旋转在局部变量表第1个位置，类似的还有 istore_0,istore_2,istore_3，它们分别表示从操作数栈顶弹出一个元素，存放在局部变量表第 0,2,3 个位置

      由于局部变量表前几个位置总是非常常用，因此这种做法虽然增加了指令数量，但是可以大大压缩生成的字节码的体积。如果局部变量表很大，需要存储的槽位大于 3，那么可以使用 istore 指令
      外加一个参数，用来表示需要存放的槽位位置
      ```

      ```
      在创建对象并赋值的时候，指令中可能有 dup，这个指令是对地址复制一个到操作数栈中，一般执行后操作数栈中有两个相同的地址值，为的是一个拿来进行初始化，一个拿来赋值到局部变量表中
      对于对象类型的数组也同样适用，但是对于 非装箱的基本类型的数组一般不会有此种情况，因为基本类型不需要有初始化，因为基本类型不是对象
      dup # 复制操作数栈顶的1个Slot的数据到操作数栈顶
      dup2 # 复制操作数栈顶的2个Slot的数据到操作数栈顶（一般用于一个数据占用两个 Slot 的情况）
      _x 的指令是复制栈顶数据并插入栈顶以下的某个位置，共有4个指令：dup_x1,dup2_x1,dup_x2,dup2_x2，对于带_x的复制插入指令，只要将指令的dup和x的系数相加，结果即为需要插入的位置，因此
         dup_x1插入位置：1+1=2，即栈顶2个Slot下面    # 1 2 3 -> 1 3 2 3（注意 3 是占用2个Slot的一个数据）
         dup_x2插入位置：1+2=3，即栈顶3个Slot下面    # 1 2 3 -> 3 1 2 3（注意 3 是占用2个Slot的一个数据）
         dup2_x1插入位置：2+1=3，即栈顶3个Slot下面   # 1 2 3 -> 1 3 2 3（注意 3 是占用2个Slot的两个数据）
         dup2_x2插入位置：2+2=4，即栈顶4个Slot下面   # 1 2 3 -> 3 1 2 3（注意 3 是占用2个Slot的两个数据）
      ```

      ```
      什么都不做的指令 nop，一般可用于调试，占位等
      ```


* 字节码指令
   - 对于大部分数据类型相关的字节码指令：它们的操作码助记符中都有特殊字符来表明专门为哪种数据类型服务
   - 操作指令数不超过 256 个指令，一个指令占一个字节
      - i 代表int类型的数据操作
      - l 代表long
      - s 代表 short
      - b 代表 byte
      - c 代表 char
      - f 代表 float
      - d 代表 double
   - 常用指令
      - 局部变量压栈指令，将一个局部变量加载到操作数栈：xload, xload_<n>，其中 x 为i,l,f,d,a；n为0 到 3或其它
         - iload_0 # 将局部变量表索引位置0的变量压入操作数栈中
            - 这里操作指令总共一个字节
         - iload 0 # 将局部变量表索引位置0的变量压入操作数栈中
            - 这里操作指令总共一个字节，如果操作数占两个节点，那么总共三个节点
            - 与上一个指令作用相同，但是这里更占空间一些
      - 常量入栈指令，将一个常量加载到操作数栈：bipush,sipush,ldc,ldc_w,ldc2_w,aconst_null,iconst_m1,iconst_<i>,lconst_<l>,fconst_<f>,dconst_<d>
      - 出栈装入局部变量表指令，将一个数值从操作数栈存储到局部变量表：xstore,xstore_<n>，其中x为i,l,f,d,a等；n 为0到3；xstore（其中x为i,l,f,d,a,b,c,s）
      - 出栈装入局部变量表指令，将一个数值从操作数栈存储到局部变量表：xstore,xstore_<n>，其中x为i,l,f,d,a等；n 为0到3；xstore（其中x为i,l,f,d,a,b,c,s）
      - 挔充局部变量表的访问索引的指令：wide
   - 局部变量压栈指令
      - xload_<n>（x 为 i,l,f,d,a；n为0到3）
      - xload（x为i,l,f,d,a）
      - 指令 xload_n 表示将第n个局部变量压入操作数栈，比如iload_1,fload_0,aload_0等指令，其中 aload_n 表示将一个对象引用压栈
      - 指令xload通过指定参数的形式，把局部变量压入操作数栈，当使用这个命脉时，表示局部变量的数量可能超过了4个，比如指令iload, fload等
   - 常量入栈
      - 指令const系列：用于待定的常量入栈，入栈的常量隐含在指令本身里，指令有:iconst_<i>（i从-1到5），lconst_<l>（l从0到1），fconst_<f>（f从0到2），dconst_<d>（d从0到1），aconst_null
         - iconst_m1将-1压入操作数栈
         - iconst_x（x为0到5）将x压入栈
         - lconst_0，lconst_1分别将长整数0和1压入栈
      - 指令push系列：主要包括bipush和sipush,它们的区别在于接收数据类型不同，bipush接收8位整数作为参数，sipush接收16位整数，它们都将参数压入栈中
      - 指令ldc系列：以上指令都不满足需求，那么可以使用万能的ldc指令，接收一个8位的参数，该参数指向常量池中的int，float或者String的索引，将指定的内容压入栈中，类似的还有 ldc_w，它接收两个8位参数，能支持的索引范围大于ldc，如果要压入的元素是long或者double类型，鶄ldc2_w指令，使用方式都是类似的
   - 出栈
      - store，比如xstore（x为i,l,f,d,a），xstore_n（x为i,l,f,d,a；n为0至3）
   - 创建指令
      - new # 创建类实例的指令
      - 创建数组的指令
         - newarray # 创建基本类型数组
         - anewarray # 创建引用类型数组
         - multianewarray # 创建多维数组
      - 上述创建指令可以用于创建对象或者数组，由于对象和数组在java中的广泛使用，这些指令的使用频率也非常高
   - 字段访问指令
      - 访问类字段（static字段，或者称为类变量）的指令：getstatic, putstatic
      - 访问类实例字段（非static字段，或者称为实例变量）的指令：getfield,putfield
   - 数组操作指令
      - 数组操作指令主要有：xastore和xaload指令，具体为：
         - 把一个数组元素加载到操作数栈的指令：baload,caload,saload,iaload,laload,faload,daload,aaload
         - 将一个操作数栈的值存储到数组元素中的指令：bastore,castore,sastore,iastore,lastore,fastore,dastore,aastore
   - 类型检查指令
         - 检查类实例或数组类型的指令：instancdof,checkcast
         - 指令checkcast用于检查类型强制转换是否可以进行，如果可以，那么checkcast指令不会改变操作数栈，否则它会抛出ClassCastException异常
         - 指令instanceof用来判断给定对象是否是某一个类的实例，它会将判断结果压入操作数栈
   - 方法调用与返回指令
      - 调用 # 省略#############
      - 返回
         - ireturn（返回值是 boolean,byte,char,short和int类型时），lreturn,freturn,dreturn和areturn
         - 另外还有一个 return 指令供声明为 void 的方法，实例初始化以及类和接口的类初始化方法使用
         - 如果当前返回的是 synchronized 方法，那么还会执行一个隐含的 monitorexit 指令，退出临界区
         - 最后会丢弃当前方法的整个帧，恢复调用者的帧，并将控制权转交给调用者
   - 操作数栈管理指令
      - 省略 #############
   - 条件判断指令
      - 省略 #############
   - 其它指令 ##### 省略
   ```
   public static String fun() {
      String str = "hello";
      try {
        return str;
      } finally {
        str = "Linux";
      }
   }
   // 最终返回结果为 "hello"
   ```


* 类的加载过程
   - 对于类的二进制数据流，虚拟机可以通过多种途径产生或获取（只要所读取的字节码符合JVM规范即可）
      1. 虚拟机可能通过文件系统读入一个class后缀的文件
      2. 读入jar,zip等归档数据包，提取类文件
      3. 事先存放在数据库中的类的二进制数据
      4. 使用类似于 HTTP 之类的协议通过网络进行加载
      5. 在运行时生成一段 class 的二进制信息等
   - 类加载过程
      1. 加载
         - 对类的加载后，会把类模板信息放在 方法区/元空间，然后在堆中创建类的 Class 对象
         - -XX:TraceClassLoading # 可以打印加载信息的数据
      2. 链接
         - 验证
         - 准备
            - 简而言之，为类静态变量分配内存，并将其初始化为默认值
               - 基本类型为0, boolean 为 false，引用类型为 null 
               - 不包含 [static final] 的，因为 [static final] 的在编译的时候就赋值了，那么会在准备阶段显式赋值
               - 而且要注意赋值不能有构造方法和代码执行，否则会在初始化阶段赋值
               - 如果使用字面量的方式定义一个字符串的常量的话，也是在准备环节直接进行显式赋值
                  - public static final str = new String("kk"); // 因为 String 的赋值是 new String()，所以会在初始化阶段赋值
                  - public static final str2 = "Linux" // 因为 String 的赋值是字面量，所以在准备阶段赋值
            - 这里不包含基本数据类型的字段用 static final 修饰的情况，因为 final 在编译的时候就会分配了，准备阶段会显式赋值
            - 注意这里不会实例变量分配初始化，类变量会分配在方法区中，而实例变量会是随着对象一起分配到 Java 堆中
            - 在这个阶段并不会像初始化阶段中那样会有初始化或者代码被执行
         - 解析 
            - 将类，接口，方法，字段等符号引用变为直接引用
      3. 初始化
         - 概念
            - clinit 是 jvm 生成的初始化方法，遵循父级先初始化的原则
            - 在一些类的运行逻辑都可以在这个阶段执行，比如 static { new String("kk"); }
         - 一些没有 clinit 的情况
            ```
            public class Test {
               public int num = 1; // 成员变量赋值，不管是否显式赋值，都不会有 clinit
               public static int num1; // 静态的变量，因为没显式赋值，所以不会有 clinit
               public static final int num2 = 3; // static final 的基本数据类型的字段，不管是否显式赋值，都不会生成 clinit 
            }
            ```
         - 虚拟机会保证一个类的 <clinit>() 方法在多线程环境中被正确地加锁，同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的<clinit>()方法，
            - 其他线程需要阻塞等待，直到活动线程执行<clinit>()方法完毕
         - 正是因为函数 <clinit>() 带锁线程安全的，因此，如果在一个类的 <clinit>() 方法中有耗时很长的操作，就可能造成多个线程阻塞，引发死锁。并且这种死锁是很验证发现的
            - 因为看起来它们并没有可用的锁信息
      4. 类的初始化
         - 主动使用，会造成初始化
            1. 当创建一个类的实例时，比如使用new关键字，或者通过反射，克隆，反序列化
            2. 当调用类的静态方法时，即当使用了字节码 invokestatic 指令
            3. 当使用类，接口的静态字段时（final修饰特殊考虑），比如，使用getstatic或者putstatic指令（对应访问变量，赋值变量）
               ```
               public class TestA {
                  public statis final int i = 2 # 这个属性被调用不会触发初始化
                  public statis final int i = new Randome().nextInt(10) # 这个属性被调用会触发初始化
               }
               public interface TestB {
                  // 这个属性只是为了作初始化验证输出
                  public static final Thread = new Thread() {
                     {
                        System.out.println("Compare的初始化");
                     }
                  };
                  public static final int NUM1 = 1; # 这个属性被调用不会触发初始化
                  public static final int NUM2 = new Random().nextInt(10); # 这个属性被调用会触发初始化
               }
               ```
            4. 当使用java.lang.reflect包中的方法反射类的方法时，比如：Class.forName("com.atguigu.java.Test")
            5. 当初始化子类时，如果发现其父类还没有初始化过，则需要先触发父类的初始化
               - 注意
                  - 当Java虚拟机初始化一个类时，要求它的所有父类都已经被初始化，但是这条规则并不适用于接口
                  - 在初始化一个类时，并不会先初始化它所实现的接口
                  - 在初始化一个接口时，并不会先初始化它的父接口
                  - 因此，一个父接口并不会因为它的子接口或者实现类的初始化而初始化，只有当程序首次使用特定接口的静态字段时，才会导致该接口初始化
            6. 如果一个接口定义了default方法，那么直接实现或者间接实现该接口的类的初始化，该接口要在其之前被初始化
            7. 当虚拟机启动时，用户需要指定一个要执行的主oudu（包含main()方法的那个类），虚拟机会先初始化这个类
            8. 当初次调用MethodHandle实例时，初始化该MethodHandle指向的方法所在的类（涉及解析REF_getstatic,REF_putstatic）
         - 被动使用不会造成 初始化
            - 概念
               - 被动使用不会引起类的初始化，也就是说：并不是在代码中出现的类，就一定会被加载或者初始化。如果不符合主动使用的条件，类就不会初始化
            - 情况
               - 当访问一个静态字段时，只有真正声明这个字段的类才会被初始化
                  - 当通过子类引用父类的静态变量，不会导致子类初始化
               - 通过数组定义类引用，不会触发此类的初始化
               - 引用常量不会触发此类或接口的初始化，因为常量在链接阶段就已经被显式赋值了
               - 调用 ClassLoader 类的 loadClass() 方法加载一个类，并不是对类的主动使用， 不会导致类的初始化
                  - ClassLoader.forName("xxx.xx.xx"); // 是主动初始化；注意如果是加载的话，此句是主动加载
                  - ClassLoader.getSystemClassLoader().loadClass("xxx.xx.xx"); // 是被动初始化；注意如果是加载的话，此句是主动加载
      5. 缷载
         - 判定一个常量是否“废弃”还是相对简单的，而要判定一个类型是否属于“不再被使用的类”的条件就比较苛刻了。需要同时满足下面三个条件（满足条件后只是“被允许”回收）
            1. 该类所有的实例都已经被回收，也就是 Java 堆中不存在该类及其任何派生子类的实例
            2. 加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如OSGi,JSP的重加载等否则通常是很验证达成的
            3. 该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法

* 类加载器
   - 类的加载
      - 加载类型
         - 显式加载
            - 显式加载指的是在代码中通过调用 ClassLoader 加载 class 对象，如直接使用 
            - Class.forName(name)
            - this.getClass().getclassLoader().loadClass(name)
            - ClassLoader.getSystemClassLoader().loadClass(name);
         - 一些方法
            - Class clazz = Class.forName(全路径名）; # 获取指定的类
            - Method[] ms = clazz.getDeclareMethods(); # 获取所有的声明方法
            - Method method = ms[0];
            - method.getModifiers(); # 获取方法的修饰符
            - Modifier.toString(method.getModifiers()); # 打印指定方法的修饰符
            - method.getReturnType().getSImpleName(); # 获取方法的返回值类型名
            - Class[] types = method.getParameterTypes(); # 获取方法的参数类型列表
         - 特殊说明
            ```
            public class InitializationTest {
               // 当只有这一句时，对应非静态字段，不管是否进行了显式赋值，都不会生成<clinit>()方法
               public int num = 1;
               // 当只有这一句时，对应静态的字段，没有显式的赋值，不会生成<clinit>()方法
               public static int num1;
               // 当只有这一句时，声明为 static final 的基本数据类型的字段，不管是否进行了显式赋值，都不会生成<clinit>()方法
               // 这个赋值是在 链接中的准备阶段赋值的
               public static final int num2 = 1;
               // 当只有这一句时，是在初始化阶段赋值
               public static Integer ii = Integer.valueOf(2);
               // 当只有这一句时，是在初始化阶段赋值
               public static final Integer ii2 = Integer.valueOf(2);
               // 当只有这一句时，是在准备阶段赋值
               public static String s = "helloworld";
               // 当只有这一句时，是在准备阶段赋值
               public static final String s2 = "helloworld";
               // 当只有这一句时，是在初始化阶段赋值
               public static final String s2 = new String("helloworld");
            }
            ```
         - 隐式加载
            - 隐式加载则是不直接在代码中调用 ClassLoader 的方法加载 class 对象，而是通过虚拟机自动加载到内存中，如在加载某个类的 class 文件时，
            - 该类的 class 文件中引用了另外一个类的对象，此时额外引用的类将通过 JVM 自动加载到内存中
      - 类的唯一性
         - 同一个加载器加载的同一个字节码的二进制
      - BootstrapClassLoader
         - 由 C/C++ 语言编写，嵌套在 JVM 内部
         - 它用来加载 Java 的核心库 JAVA_HOME/jre/lib/rt.jar 或 sun.boot.class.path 路径下的内容。用于提供 JVM 自身需要的类，并不继承自 java.lang.ClassLoader，没有父加载器
         - 出于安全考虑，启动类加载器只加载包名为 java,javax,sun 等开头的类
         - 加载扩展类和应用程序类加载器，并指定为他们的父类加载器
      - ExtClassLoader
         - 大致结构
            - ClassLoader
               - SecureClassLoader
                  - URLClassLoader
                     - ExtClassLoader in Launcher
                     - AppClassLoader in Launcher
         - 由 Java 语言编写，由 sun.misc.Launcher$ExtClassLoader 实现
         - 间接继承于 ClassLoader 类
         - 父类加载器为启动类加载器
         - 从 java.ext.dirs 系统属性所指定的目录中中加载类库，或从 JDK 的安装目录的 jre/lib/ext 子目录下加载类库。如果用户创建的 JAR 放在此目录下，也会自动由扩展类加载器加载
      - AppClassLoader
         - java 语言编写，由 sun.misc.Launcher$AppClassLoader 实现
         - 间接继承于 ClassLoader 类
         - 父类加载器为扩展类加载器
         - 负责加载环境变量 classpath 或系统属性 java.class.path 指定路径下的类库
         - 应用程序中的类加载器默认是系统类加载器（重要）
         - 它是用户自定义类加载器的默认父加载器
         - 通过 ClassLoader 的 getSystemClassLoader() 可以获取到该类加载器
      - 用户自定义类加载器
         - 在 Java 的日常应用程序开发中，类的加载几乎是由上述3种加载器相互配合执行的。在必要时，我们还可以自定义类加载器，来定制类的加载方式
         - 体现 Java 语言强大生命力和巨大魅力的关键因素之一是，Java 开发者可以自定义类加载器来实现类库的动态加载，加载源可以是本地的 jar 包，也可以是网络上的远程资源
         - 通过类加载器可以实现非常绝妙的插件机制，这方面的实际应用安全举不胜举。例如，著名的OSGI组件框架，再如Eclipse的插件机制。类加载器为应用程序提供了一种动态增加新功能的机制
            - 这种机制无须重新打包发布应用程序就能实现
         - 同时，自定义加载器能够实现应用隔离，例如 Tomcat,Spring 等中间件和组件框架都在内部实现了自定义的加载器，并通过自定义加载器隔离不同的组件模块。这种机制比 C/C++ 程序要好太多
            - 想不修改 C/C++ 程序就能为其新增功能，几乎是不可能的，仅仅一个兼容性便能阻挡住所有美好的设想
         - 自定义类加载器通常需要继承于 ClassLoader
   - 获取 ClassLoader 的途径
      - 对象.getClassLoader(); // 获得当前类的 ClassLoader
      - Thread.currentThread().getContextClassLoader(); // 获得当前线程上下文的 ClassLoader，上下文 ClassLoader 其实就是 AppClassLoader（通过源码可知）
      - ClassLoader.getSystemClassLoader(); // 获得系统的 ClassLoader
      - 对于 数组获取加载器，是根据数组所用的对象类型的加载器而约定的
         ```
         // 如果自己定义了类 User
         String [] s = new String[2]; s.getClass().getClassLoader(); // 是 null，因为 String 的加载器是 BootstrapClassLoader，所以获取不了
         int[] s = new int[2]; s.getClass().getClassLoader(); // 是 null，因为 int 是基本数据类型，不具有加载器
         int[] i = new int[2]; i.getClass().getClassLoader(); // 是 null，因为 int 是基本数据类型，不具有加载器
         User[] u = new User[2]; u.getClass().getclassLoader(); // 是 AppClassLoader，因为 User 的加载器是 AppClassLoader
         ```
   - 加载类的区别
      - Class.forName() 是一个静态方法，最常见的是 Class.forName(String className);根据传入的类的全限定名返回一个 Class 对象。
         - 该方法在将 Class 文件加载到内存的同时，会执行类的初始化，如：Class.forName("com.test.java.HelloWorld");
      - ClassLoader.loadClass() 是一个实例方法，需要一个 ClassLoader 对象来调用该方法。该方法将 Class 文件加载到内存时，并不会
         - 执行类的初始化，直到这个类第一次使用时才进行初始化。该方法因为需要得到一个 ClassLoader 对象，所以可以根据需要指定使用哪个类加载器，
         - ClassLoader cl = ...; cl.loadClass("com.test.java.HelloWorld");
   - 类加载器主要的方法
      - abstract ClassLoader 有几个重要方法
         1. loadClass(String) 
            - 加载相应名称的类，返回结果为java.lang.Class类的实例，如果找不到类，则返回 ClassNotFoundException 异常。该方法中的逻辑就是双亲委派模式的实现。不建议重写，重写可以制定打破双亲委派机制
         2. resolveClass(Class<?>)
            - 解析类
         3. findClass(String) # 查询类的逻辑
            - 查询相应名称的二进制类，返回结果为java.lang.Class类的实例，这是一个受保护的方法，JVM鼓励我们重写此方法，需要自定义加载器遵循双亲委托机制，该方法会在检查完父类加载器之后被loadClass()方法调用
         4. defineClass(byte[], int, int)
            - 根据给定的字节数组b转换为Class的实例，off和len参数表示实际Class信息在byte数组中的位置和长度，其中byte数组b是ClassLoader从外部获取的。这是受保护的方法，只有在自定义ClassLoader子类中可以使用
   - 双亲行派原则的优点和弊端
      - 优点
         - 保护程序安全，防止核心 API 被随意篡改
         - 避免类的重复加载，确保一个类的全局唯一性
      - 缺点
         - 检查类是否加载的委托过程是单向的，这个方式虽然从结构上说比较清晰，使各个 ClassLoader 的职责非常明确，但是同时会带来一个问题
            - 即顶层的 ClassLoader 无法访问底层的 ClassLoader 所加载的类

* JDK9新特性
   - ExtClassLoader 不再存在，而是由 PlateformClassLoader 替代
   - AppClassLoader 和 ExtClassLoader 和 BootstrapClassLoader 全部都直接继承于 BuiltinClassLoader
   - BuiltinClassLoader 直接继承于 SecureClassLoader
   - 不同模块的类 由 不同的加载器加载


* JVM 调优
   - 性能优化的步骤
      1. 发现问题-性能监控
         - GC 频繁
         - cpu load过高
         - OOM
         - 内存泄漏
         - 死锁
         - 程序响应时间较长
      2. 排查问题-性能分析
         - 打印GC日志，通过GC viewer 或者 http://gceasy.io来分析日志
         - 灵活运用命令行工具：jstack,jmap,jinfo等
         - dump 出堆文件，使用内存分析工具分析文件
         - 使用阿里Arthas或jconsole,jVisualVM来实时查看JVM状态
         - jstack查看堆栈信息
      3. 解决问题-性能调优
         - 适当增加内存，根据业务背景选择垃圾回收器
         - 优化代码，控制内存使用
         - 增加机器，分散节点压力
         - 合理设置线程池线程数量
         - 使用中间件提高程序效率，比如缓存，消息队列等
   - 性能评价/测试指标
         - 停顿时间
            - 响应时间
         - 吞吐量
            - 单位时间内完成的工作量（请求）的量度
            - 在GC中：运行用户代码的时间占总运行时间的比例（总运行时间：程序的运行时间+内存回收的时间）；吞吐量为 1-1/(1+n) -XX:GCTimeRatio=n
         - 并发数
            - 同一时刻，对服务器有实际交互的请求数
         - 内存占用
            - Java 堆区所占的内存大小
         - 相互间的关系
            - 以调整公路通行状态为例
   - 命令
      - 以下的所有命令可以根据：`命令 -h` 来查看相应的帮助手册
      - jps <options> <hostid> # 查看当前存在的java进程
         - options
            - -q # 只查看进程不显示程序名
            - -l # 展示更完整的程序全名
            - -m # 输出虚拟机进程启动时传给主类main()的参数
            - -v 列出虚拟机进程启动时jvm参数，比如 -Xms20m -Xmx50m 是启动程序指定的jvm参数
            - 如果某java进程关闭了默认开启的 UsePerfData 参数（即使用参数 -XX:-UsePerfData），那么 jps命令（以及下面介绍的jstat）将无法探知该Java进程
         - hostid # 用于远程连接
            - <hostid>: <hostname>:[:<port>]
            - 如果想要远程监控主机上的 java 程序，需要安装 jstatd
            - 对于具有更严格的安全实践的网络场所而言，可能使用一个自定义的策略文件来显示对特定的可信主机或网络的访问，尽管这种技术容易受到IP地址欺诈攻击
            - 如果安全问题无法使用一个定制的策略文件来处理，那么最安全的操作是不运行jstatd服务器，而是本地使用 jstat 和 jps 工具
      - jstat -<option> [-t] [-h<lines>] <vmid> [<interval> [<count>]] # 查看jvm统计信息
         - 基本
            - -class # 显示ClassLoader 的相关信息：类的装载，卸载数量，总空间，类装载所消耗的时间等
            - interval # 用于指定刷新打印的频率 单位毫秒（将 interval 替换成秒数）
            - count # 对于指定刷新打印频率的打印次数（将 count 替换成 次数）
            - -t # 可以在输出信息前加上一个 Timestamp 列，显示程序从开始到现在的运行时间 单位秒
            - -h # 可以在周期性数据输出时，输出多少行数据后输出一个表头信息
         - JIT相关
            - -compiler # 显示JIT编译器编译过的方法，耗时等
            - -printcompilation # 输出已经被JIT编译的方法
         - 垃圾回收相关的
            - -gc 显示与GC相关的堆信息，包括Eden区，两个Survivor区，老年代，永久代等的容量，已用空间，GC时间合计等信息
            - -gccapacity # 显示内容与-gc基本相同，但输出主要关注Java堆各个区域使用到的最大，最小空间
            - -gcutil # 显示内容与-gc基本相同，但输出主要关注使用空间占总空间的百分比
            - -gccause # 与-gc基本相同，但是会额外输出导致最后一次或当前正在发生的GC产生的原因
            - -gcnew # 显示新生代GC状况
            - -gcnewcapacity # 显示内容与-gcnew基本相同，输出主要关注使用到的最大，最小空间
            - -geold # 显示老年代GC状况
            - -gcoldcapacity # 显示内容与-gcold基本相同，输出主要关注使用到的最大，最小空间
      - jinfo # 实时查看和修改jvm配置参数
         - jinfo [option] <PID>
            - jinfo -sysprops PID # 查看由 System.getProperties()取得的参数
            - option
               - no option # 输出全部的参数和系统属性
               - -flag name # 输出对应名称的参数
               - -flag[+-]name # 开户或关闭对应名称的参数，只有被标记为manageable的参数才可以被动态修改
               - -flag name=value # 设定对应名称的参数
               - -flags # 输出全部的参数
               - -sysprops # 输出系统属性
         - jinfo [option] <executable core>
         - jinfo 不仅可以查看运行时某一个java虚拟机参数的实际取值，甚至可以在运行时修改部分参数，并使之立即生效
            - 但是，并非所有参数都支持动态修改。参数只有被标记为manageable的flag可以被实时修改。其实，这个修改能力是极其有限的
            - java -XX:+PrintFlagsFinal -version | grep manageable # 查看被标记为 manageable 的参数
      - 拓展
         - java -XX:+PrintFlagsInitial # 查看所有jvm参数启动的初始值
         - java -XX:+PrintFlagsFinal # 查看所有jvm参数的最终值
            - java -XX:+PrintFlagsFinal -version | grep manageable # 查看被标记为 manageable 的参数
         - java -XX:+PrintCommandLineFlags # 查看那些已经被用户或者jvm设置过的详细的xx参数的名称和值
      - jmap # 导出内存映像文件&内存使用情况
         - 作用一方面是获取dump文件（堆转储快照文件，二进制文件），它还可以获取目标Java进程的内存相关信息，包括Java堆各区域的使用情况，堆中对象的统计信息，类加载信息等
         - jmap [option] <pid>
         - jmap [option] <executable <core>
         - jmap [option] [server_id]@<remote server IP or hostname>
         - option
            - -dump # 生成dump文件
               - -dump:live # 只保存堆中的存活对象
            - -finalizerinfo # 以ClassLoader为统计口径输出永久代的内存状态信息
            - -heap # 输出整个堆空间的详细信息，包括GC的使用，堆配置信息，以及内存的使用信息等
            - -histo # 输出堆空间中对象的统计信息，包括类，实例数量和合计容量
            - -permstat # 以ClassLoader为统计口径输出永久代的内存状态信息
            - -F # 当虚拟机进程对 -dump 选项没有任何响应时，强制执行生成dump文件
         - 通常在写Heap Dump文件前会触发一次Full GC，所以heap dump文件里保存的都是FullGC后留下的对象信息；（这是对于自动方式，手动方式是即时快照，不会先执行 Full GC）
         - 由于生成dump文件比较耗时，因此大家需要耐心等等，尤其是大内存镜像生成dump文件则需要耗费更长的时间来完成
         - dump文件生成方式
            - 手动的方式
               1. jmap -dump:format=b,file=<filename hprof> <pid>
                  - 所有的对象
               2. jmap -dump:live,format=b,file=<filename.hprof> <pid>
                  - 只有存活的对象
            - 自动的方式的两个参数
               - -XX:+HeapDumpOnOutOfMemoryError
                  - 在程序发生OOM时，导出应用程序的当前堆快照
               - -XX:HeapDumpPath=<filename.hprof>
                  - 可以指定堆快照的保存位置
         - 显示堆内存信息
            - jmap -heap pid # 显示堆内存信息
            - jmap -histo pid # 显示堆内存信息
            - jmap -permstat pid # 查看系统的ClassLoader信息
            - jmap -finalizerinfo # 查看堆积在finalize队列中的对象
         - 其它说明
            - 由于jmap将访问堆中的所有对象，为了保证在此过程中不被应用线程干扰，jmap需要借助安全点机制，让所有线程
            - 在不改变堆中数据状态。也就是说，由jmap导出的堆快照必定是安全点位置的。这可能导致基于该堆快照的分析结果存在偏差
            - 举个例子，假设在编译生成的机器码中，某些对象的生命周期在两个安全点之间，那么:live选项将无法探知到这些对象
            - 另外，如果某个线程长时间无法跑到安全点，jmap将一直等下去
            - 与前面讲的jstat则不同，垃圾回收器会主动将jstat所需要摘要数据保存至固定位置之中，而jstat只需直接读取即可
      - jhat # jdk自带堆分析工具
         - jhat xxx.hprof # 解析文件
         - 与jmap命令搭配使用，用于分析jmap生成的heap dump文件（堆转储快照）。jhat内置了一个微型HTTP/HTML服务器，生成dump文件的分析结果后，用户可以在浏览器中查看分析结果（分析虚拟机转储快照信息）
         - 使用了jhat命令，就启动了一个http服务，端口是7000,即http://localhost:7000 就可以在浏览器里分析
         - jhat命令在jdk9,jdk10中已经被删除，官方建议使用VisualVM代替
      - jstack # 打印jvm中线程快照
         - 语法 jstack [option] pid
         - 可以用以分析线程死锁等问题
         - jstack管理远程进程的话，需要在远程程序的启动参数中增加：
            - -Djava.rmi.server.hostname=主机地址
            - -Dcom.sun.management.jmxremote
            - -Dcom.sun.management.jmxremote.port=8888
            - -Dcom.sun.management.jmxremote.authenticate=false
            - -Dcom.sun.management.jmxremote.ssl=false
         - 在 thread dump 中，要贩几种状态
            - 死锁：Deadlock（重点关注）
            - 等待资源：Waiting on condition（重点关注）
            - 等待获取监视器：Waiting on monitor entry（重点关注）
            - 阻塞：Blocked（重点关注）
            - 执行中：Runnable
            - 暂停：Suspended
         - option
            - -F # 当正常输出的请求不被响应时，强制输出线程堆栈
            - -l # 除堆栈外，显示关于锁的附加信息
            - -m # 如果调用到本地方法的话，可以显示C/C++的堆栈
            - -h # 帮助操作
      - jcmd # 多功能命令行
         - 它是一个多功能的工具，可以用来实现前面除了jstat之外所有命令的功能，比如：用它来导出堆，内存使用，查看Java进程，导出线程信息，执行GC，JVM运行时间等
         - jcmd 拥有 jmap 的大部分功能，并且在 Oracle 的官方网站上也推荐使用 jcmd 命令代替 jmap 命令
         - jcmd -l # 列出所有jvm进程
         - jcmd pid help # 针对指定的进程，列出支持的所有命令
         - jcmd pid 具体命令 # 显示指定进程的指令命令的数据
      - jstatd # 远程主机信息收集
         - 之前的指令只涉及到监控本机的java应用程序，而在这些工具中，一些监控工具也支持对远程计算机的监控（如jps, jstat），为了启用远程监控，则需要配合使用 jstatd 工具
         - 命令 jstatd 是一个 RMI 服务端程序，它的作用相当于代理服务器，建立本地计算机与远程监控工具的通信。jstatd 服务器将本机的 java应用程序信息传递到远程计算机

   - 视图工具
      - JDK自带工具
         - jconsole
            - JDK自带的可视化监控工具，查看java应用程序的运行概况，监控堆信息，永久区（或元空间）使用情况，类加载情况等
         - Visual VM
            - Visual VM是一个工具，它提供了一个可视界面，用于查看java虚拟机上运行的基于java技术的应用程序的详细信息
         - JMC
            - Java Mission Control，内置Java Flight Recorder。能够以极低的性能开销收集Java虚拟机的性能数据
      - 第三方工具
         - MAT
            - MAT(Memory Analyzer Tool)是基于Eclipse的内存分析工具，是一个快速，功能丰富的Java heap分析工具，它可以帮助我们查找内存泄漏和减少内存消耗
            - Eclipse的插件gaaa
         - JProfiler：商业软件，需要付费，功能强大
            - 与 VisualVM类似
         - Arthas
            - Alibaba开源的Java诊断工具。深受开发者喜爱
         - Btrace
            - Java运行时追踪工具，可以在不停机的情况下，跟踪指定的方法调用，构造函数调用和系统内存等信息
      - 介绍
         - jvisualvm 
            - 插件可以在 https://visualvm.github.io/pluginscenters.html 下载再放到相应文件夹下，也可以在工具中在线安装
            - IDEA安装 VisualVM Launcher 插件
               - Preferences -> Plugins -> 搜索 VisualVM Launcher 安装重启
               - 安装后，需要在 Settings 中的 VisualVM Launcher 配置 jdk_home 目录以及 VisualVM executable 的可执行文件位置
            - 远程方案
               - 确定远程服务器的ip地址
               - 添加JMX（通过JMX技术具体监控远端服务器哪个Java进程）
               - 修改bin/catalina.sh文件，连接远程的tomcat
               - 在.../conf中添加jmxremote.access 和 jmxremote.password 文件
               - 将服务器地址改为公网ip地址
               - 设置阿里云安全策略和防火墙策略
               - 启动 tomcat，查看 tomcat 启动日志和端口监听
               - JMX中输入端口号，用户名，密码登录
