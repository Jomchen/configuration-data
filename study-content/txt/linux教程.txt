									Linux内核版本 wwww.kernel.org
									     此教程基于centOS6
									(每天四集)Linux进度: 15.1.2

	2017/07/04 18:00
									
** 重看
	* 4.5集，6.4.2集，6.5集，7.1.2集，10.6.2集，12.3集
		12.4集讲解各服务作用和建议关闭的建议
		远程连接工具，
		软件安装，
		分区，
		网络，
		帮助命令得到的配置文档和帮助文档，
		网络章节的挂载光盘，
		环境变量的永久生效
		
** pdf文档重看
	* 第一章
		> 计算器概论
	* 第六章
		> man 和 man page 仔细阅读
		> cp的命令参数
		> SUID SGID BIT 重看
		> atime ctime mtime的区别
		> 文件属性权限SUUID SGID BIT
	* 第七章
	* find的查询
	* 第十章和第十一章的最后部分
	* 某一章的系统脚本调用流程
	
** 文章未看懂地方
	* 搜索命令的 时间查找
				
	
-----------------------------------------------------------------------------------------------------------------------------------

	
** 信息
	* 账户
		> Z: root M: zhou123456
		> Z: zhou00 M: zhou00
		


		
** 虚拟机
	* 虚拟机快捷键
		> ctrl+alt+enter 全屏, 点击窗口右上方窗口撤销全屏
		> ctrl+alt 调出鼠标, 点击鼠标进入虚拟机内部
		> ctrl+g 进入linux控制
	* 最常用的报错
		> Command not found 命令错误或者没有安装此命令
		> No Such file or directory 可能是某个文件名错了或者没有相应目录
		> 总结：有可能命令不存在，你输错命令，目前用户没有将此命令所在的
			目录加入指令搜索目录里
		

** Linux 比较重要的几个文件
	* /etc/fstab								# 开机自动挂载配置
	* /proc/partitions							# 系统分区情况
	* /etc/locale.conf							# 语言环境编码
	* ~/.bash_logout							# 注销时需要执行的内容的文件
	* ~/.bash_history							# 历史命令
		
** Linux 常见事项&注意事项

	* Linux文档信息注释都是用#开头的
	* 远程服务器不允许关机，只能重启
	* 重启时应该关闭服务
	* 不要再服务器访问高峰运行高负载命令
	* 远程配置防火墙时不要把自己踢出服务器
	* 指定合理密码规范并定期更新
	* 合理分配权限
	* 定期备份重要数据和日志
	* linux没有扩展名的情况，但是一般用扩展名作为一定的区分，用权限打开相应文件
	* 压缩文件: *.gz, *.bz2, *.tar.bz2, *.tgz
	* 二进制软件包: .rpm
	* 网页文件: *.html, *.php
	* 脚本文件: *.sh
	* 配置文件: *.conf
	


	
** Linux 目录作用
	* 单用户模式相当于安全模式
	* Linux常用文件类型
		> 正规文件
			>> 纯文本档(ASCII)
			>> 二进制文件(binary)
			>> 数据格式文件(data)
		> 目录(directory)
		> 连接档(link)
		> 设备与装置文件(device)
			>> 区块(block)设备档，例如移动硬盘等存储设备
			>> 字符(character)设备文件，例如鼠标键盘等
		> 资料接口文件(sockets)
		> 数据输送文件(FIFO, pipe)
	
	* 目录作用
		> /bin/			# 存放系统命令目录,普通，超级，单用户模模式下也可以执行
		> /sbin/		# 保存和系统环境设置相关的命令(只有超级用户可以使用，
			少部分命令普通用户可以使用)
		> /usr/bin/		# 存放系统命令的目录，普通，超级可用，单用户模式下不能执行
		> /usr/sbin/	# 存放根文件系统不必要的系统管理命令，只有超级用户可用
		> /boot			# 系统启动目录，保存系统启动相关文件，如内核文件和启动引导程序(grub)文件等
		> /dev/			# 设备文件保存位置，用以保存设备文件的
		> /etc/			# 配置文件保存位置，如密码，账户，启动脚本，常用配置等
		> /home/		# 普通用户的家目录
		> /lib/			# 系统调用的函数库保存位置
		> /lost+found/	# 当系统意外崩溃或机器意外关机，产生的碎片存放位置，当系统
			启动过程中fsck工具会检测这里并修复，这个目录只在每个分区中出现，例如/lost+found
			就是根分区的备份恢复目录,/boot/lost+found就是/boot分区的备份恢复目录，也就是说每个挂载点都有
			此目录
		> /media/		# 挂载目录，系统建议是用来挂载设备的，例如软盘光盘
		> /misc/		# 挂载目录，系统建议用来挂载NFS服务的共享目录,虽然系统准备了三个默认挂载目录/media
							, /mnt, /misc, 但是到底用哪个由管理员决定
		> /opt/			# 第三方安装的软件保存位置，但更加习惯把软件放到/usr/local目录中
		> /proc/		# 虚拟文件系统，该目录不保存在硬盘中，而是在内存中，主要保存系统的内核，进程，
			外部设备状态，如/proc/cpuinfo保存CPU信息，/proc/devices是保存设备驱动，/proc/filesystems保存文件系统列表，/proc/net是网络协议信息
		> /sys/			# 虚拟文件系统，和/proc目录相似，都是在内存中，保存内核相关信息
		> /root/		# 超级用户的家目录，普通用户家目录在/home下，超级用于家目录直接在/下
		> /srv/			# 服务数据目录，一些系统服务启动后，可以在这个目录中保存所需要的数据
		> /tmp/			# 临时目录，系统存放临时文件目录，该目录所有用户可访问写入，建议不保存重要数据，最好没辞开机都清空
		> /usr/			# 系统软件资源目录，存放系统软件资源的目录，系统安装的软件大都放在这里，除了usr/bin和/usr/sbin/这两个
		> /var/			# 动态数据保存位置，主要保存缓存，日志以及软件运行所产生的文件
		> /mnt/			# 一般用于挂载


		
	
** VMwar虚拟机使用

	* 一块硬盘中：
		主分区：最多只能有4个(包括与不包括扩展分区的情况下)
		扩展分区：
			最多只能有1个
			主分区加扩展分区最多只有4个
			不能写入数据和格式化，只能包含逻辑分区
		逻辑分区：
			由扩展分区分出来，可以放数据和格式化
	* Linux中：
		IDE硬盘：Linux最多支持59个逻辑分区
		SCSI硬盘：Linux最多支持11个逻辑分区
	* 虚拟机安装完毕后工具栏有一个钟表是 创建快照
		相当于备份当前的状态(也有备份的意思),
		右边还有一个钟表加工具手的图标 恢复快照
	* 虚拟机->设置 可以设置虚拟机参数
	* 虚拟机->管理->克隆 可以克隆一个一模一样的系统



	
** 分区(挂载)
	* 因为Linux的规则是每个硬件都有独立的设备文件名，
		所以每个设备都要设置设备文件名
	* Linux 分区->格式->为硬盘设置设备文件名->设置盘符
	* 硬件					设备文件名
	  > IDE硬盘					/dev/hd[a-d]
	  > SCSI/SATA/USB硬盘		/dev/sd[a-p]
	  > 光驱					/dev/sr0或者/dev/cdrom
	  > 软盘					/dev/fd[0-1]
	  > 打印机(25针)			/dev/lp[0-2]
	  > 打印机(USB)				/dev/usb/lp[0-15]
	  > 鼠标					/dev/mouse
	  > 注意中括号里的表示第几个的数目,硬盘分区的区设备名例子:/dev/hda1即在硬盘设备名后第一个区
	  > 假如一块硬盘a分了三个主分区和一个扩展分区，扩展分区里分了两个逻辑分区,
			那么这个时候的逻辑分区第一个分区表示为/dev/sda5 (也可能不是sd，视情
			况而定，但是5理解为4之后的数字，因为主分区加扩展分区总共最多四个，
			1~4的数字只能必须分给主/扩展分区，所以主/扩展分区不管总共有没有4个，
			第一个逻辑分区都为5，逻辑分区永远从5开始)
	* 分区规则
		> 必须分区
			1. / (根分区)
			2. swap swap分区 (交换分区或虚拟内存，内存2倍，最大不超过2G因为效果不佳，不超过2GB)
		> 推荐安装
			1. /boot (启动分区，200MB)
	* centOS 默认硬盘格式为EXT4

	

	
** Linux 安装
	* 简介
		> Install or upgrade an existing system: 安装或升级现有系统
		> Install system with basic video driver: 安装过程采用基本的显卡驱动
		> Rescue installed system: 进入系统修复模式
		> Boot from local driver: 推出安装从硬盘启动
		> Memory test: 存储介质检测
	* 分区
		> 不管先分了什么区，/boot分区最后都会自动变为sda1排在第一
		> 先分/boot 设定大小(一般200m)
		> 文件系统类型 swap 设定大小一般设为内存的两倍(但是超过2G就没意义)
		> /home 设定大小 
		> / 根分区 一般设定剩余空间大小(他会自动变为sda5变成逻辑分区) 因为Linux
			考虑到以后的扩展
		> 系统安装形式选项
			1.Desktop(桌面)
			2.Minimal Desktop(最小化桌面)
			3.Minimal(最小化)
			4.Basic Server(基本服务器)
			5.Database Server(数据库服务器)
			6.WebServer(网页服务器)
			7.Virtual Host(虚拟主机)
			8.software development workstation(软件开发工作站)
	

	
			
** linux使用
	* 默认最高管理员 用户名:root 密码:安装时候的密码(密码隐藏不会显示)
	* ls查看目录
		> /root/install.log 存储了安装在系统中的软件包激起版本信息
		> /root/install.log.syslog 存储了安装过程中留下的事件记录
		> /root/anaconda-ks.cfg 以Kickstart配置文件的格式记录安装
			过程中设置的选项信息
	* 登录		
		> 登陆root后可以reboot重启系统
		> 其它未知操作
			>> sudo passwd 用户名 	# 更改密码，输入一次原密码，再输入两次新密码
			>> sudo -s 				# 切换到root用户
		> 乌班图的root转换
			>> sudo su				# 切换成root用户
		> centOS中的root转换
			>> su 用户名			# 切换用户(不转换环境变量)
			>> su - 用户名 			# 切换用户(同时切换环境变量)
	* 网络配置
		> 桥接 虚拟机根据真实机网卡进行通信，并且设置相同网段，
			且可以实现同一网段的机子间通信(但是会多占用一个ip地址，
			还容易引起ip地址冲突)
		> NAT 通过VMnet8的假网卡通信(只能跟本真实机通信,不占用多的ip地址,如果主机能上网，虚拟机也能上网)
			依赖于虚拟网卡8
		> Host-only 通过VMnet1假网卡通信(只能跟本真实机通信,不占用多的ip地址)
			依赖于虚拟网卡1
		> ifconfig 查看ip信息
		> ifconfig eth0~1 描述网卡
		> ifconfig eth0 地址
			为此第一个网卡更改地址为指定的ip地址，
			此更改只是临时的，重启后又失效
		> windows 在dos窗口中 ping ip地址 就可以远程连接此地址
		
		> 桥接的连接有时候即使用了跟真实机同样的网段仍然不能上网，
			因为真实机有无线和有限的网卡，桥接会自动选择就可能选择没有网卡的
			此时要在虚拟机->编辑->虚拟网络编辑器->更改桥街道
		> 在windows的网络适配器管理可能有四个内容：一个是有限网卡，一个是无线网卡，
			一个是VMware的关于nat的虚拟网卡，一个是VMware的关于Host-only的虚拟网卡
		
		
		
				
** Linux常用命令
	* 注意事项
		> Linux 严格区分大小写，所有内容以文件的形式保存
		> 命令 [-选项] [参数]
			有多个选项可以合并，例如 ls -ald，有些命令也不遵循此命令规则
		> 隐藏文件是用 .起名的
	* 按键信息
		> stty [-a]				# 查询所有按键信息(加上-a，否则是查看部分按键)
			有^的是ctrl
	* 信息解析
		> ls [命令参数] 路径
			-a	# 显示所有文件，包括隐藏文件
			-A	# 显示所有文件，包括隐藏文件，但是不包括.和..的两个目录
			-f	# 直接列出结果，不进行排序(默认ls会用档名排序)
			-F	# 根据文件、目录等信息，给予附加数据结构例如：*代表可执行文件，
					/代表目录，=代表socket文件，|代表FIFO文件
			-i	# 查看i节点(相当于id或索引)
			-l	# 详细信息显示 -d查看目录属性 
			-h	# 文件大小人性化显示
			-n	# 列出UID与GIG而非使用者与群组的名称
			-r	# 将排序结果反向输出，例如：原本档名由小到大，变为由大到小
			-R	# 连同子目录内容一起列出来，等于该目录下的所有文件都会显示出来
			-S	# 以文件容量大小排序，而不是用档名排序
			-t	# 依时间排序，而不是用档名
			--color=never	# 不要依文件特性给予颜色显示
			--color=always	# 显示颜色
			--color=auto	# 让系统字形依据设定来判断是否给予颜色
			--full-time		# 以完整实践模式(包括年、月、日、时、分)输出
			--time={atime,ctime}	# 输出access时间或改变属性属性时间(ctime)而非内容
				变更时间(modification time)
				# 默认情况下显示的是mtime
				
				# atime --> 文件最近被读取的时间
				# ctime --> 文件状态最近被修改的时间
				# mtime --> 文件内容最近被修改的时间
			
			一个文件只能有一个索引，一个索引可以有多个文件(因为硬链接)
			
		> ls最后面可以跟多个要查看的对象	
		> 默认查看一个路径是查看这个路径下的所有子文件夹或子文件信息，所以要查看一个挂载点的信息用 -d
		> 出来的信息 ：
			第一列：权限， 第二列：在硬连接中被引用多少次， 第三列：所属人
			第四列：所属组， 第五列：一级目录和文件名占用的大小，而不是一级
			目录下的目录和数据及其一级目录下的文件内容的数据大小(这里的大小
			要和平常的大小区分开，所以要利用du命令),第六列：修改时间
		> ls -al 路径 	# 查看隐藏的和不隐藏的详细信息
			第一列例子 -rw-r--r--   
			-文件类型(文件 -:二进制文件 d:目录 l:软连接 b:装置文件里面的可
				供储存的接口设备，即可随机存取装置 c:装置文件里面的串行端口
				设备，例如键盘，鼠标，即一次性读取装置)
			rw- r-- r-- 
			u   g   o			1. 这三个分别对应: u所有者 g所属组 o其他人
								2.  r读 w写 x执行(-表示无权限，有权限会对应相应的字母)
								3. 三个横杠依次占位是 r, w, x
								4.		权限类型	对于文件	对于目录		
									r: 读权限，可以查看文件内容，可以列出目录中的内容
									w: 写权限，可以修改文件内容，可以在目录中创建删除文件
									x: 执行权限，可执行文件，可以进入目录
	

	
						
** Linux 常用命令

	* 常用命令
	
		> 重新启动 X-window 方法(注：这不是重启系统，而是重启 X-window 模块)
			>> 注销在重新登录
			>> ctrl + alt + backspace 重新启动 X-window
			
		> 终端切换
			ctrl + alt + F2 ~ F6	# 文字接口登入 tt2 ~ tt6 终端机
			ctrl + lt + F1			# 图形接口桌面
			# 如果安装的是桌面版 Linux 那么默认启动的是 X 窗口，如果安装的是
				文本式的系统则， tty1 ~ tty6 会默认是文字界面
				
				在文字化界面的 tty 上，执行 startx 可以启动图形化界面
					# 生效条件：
						1. 没有其他 的 X window 被占用
						2. 有安装了 X Window system，并且 server 是启动了的
						3. 最好要有窗扣管理员，例如 GNOME/KDE 或者是阳春的TWM等
			
	
		> 当输入一段命令太长时可以写作两行，例如：
			abcdefghij 等效于：
			abcde\
			fghij
		> tab键用法
			1. 刚开始是输入一个指令，但是指令未输入完毕则连续两次按tab键
				可以将按tab键之前字符开头的所有指令罗列出来(命令补全)
			2. 如果指令输入完毕后，在指令选项未输完或路径未输完情况连续
				两次按可以起到选项补全或路径补全(文件补全)
				
		> uname -s 			# 查看系统名
		> uname -r 			# 查看Linux核心版本
		> uname -m 			# 查看操作系统的位版本
		> ls -l /lib/modules/$(uname -r)/kernel/fs	# 查看linux支持的文件系统
		> cat /proc/filesystems	# 查看已经加入内存中支持的文件系统
		> type 命令			# 可以查看当前命令在默认情况下设置的别名
		> which [-a] 命令	# 将由PATH目录中可以找到的指令第第一个出来，如果加上
			-a则列出在PATH中查找到的所有而不是只找到的第一个
		> \命令				# 因为有的命令默认有别名，所以这样能调用原生命令
		> clear 或者 ctrl+l 或者 clear screen	# 清屏(但是如果滑动鼠标滚轮还是
													能够看到记录，这是欺骗式清除)
		> printf "\033c"	# 这是真正的清除屏幕内容，滚动鼠标滚轮也没有记录											
		> ctrl+c			# 终止当前行为
		> ctrl+d			# 退出输入
		> ctrl+z			# 把当前任务后台暂停
		> shift+pageUp 		# 往上翻页
		> shift+pageDown	# 往下翻页
		> tab键 			# 按tab键可以补全，经常用于ls查询时
		> who				# 查看目前有谁在本机在线
		> whoami			# 查看自己目前的用户身份
		> df				# 查看分区
		> env				# 查看用户的环境变量
		> export			# 查看用户的环境变量，与env命令结果基本一致(除此外还有其它作用)
		> echo $RANDOM	# 可以得到一个随机数，随机数介于0~32767的数值
		> echo				# 脚本输出显示命令
			echo $PATH 		# $是指后面接的是变量，所以echo $PATH
			表示查看PATH的变量信息
		> pwd[-P]			# 当前所在目录
		> dir				# 查看当前所在目录下的所有文件
		> basename 挂载点	# 显示这个挂载点最后的名字
			范例：basename /home/zhou00/t.txt ----> t.txt
		> dirname 挂载点	# 显示这个挂载点最后名字之前的路径
			范例：dirname /home/zhou00/t.txt ----> /home/zhou00
		> locale	# 显示语言环境的配置信息，配置文件为 /etc/locale.conf
		> file 挂载点		# 判断指定挂载点是属于ASCII、binary、data类型以及
			有没有动态函式库等信息
		> date				# 显示当前时间
		> date 时间			# 定义时间(可以查看帮助文档时间格式写法)
			date +%Y/%m/%d ---->格式化显示为年/月/日
			date +%H:%M:%S ---->格式化显示为时:分:秒
		> 时间戳换算为时间 date -d "1970-01-01 时间戳数 days"
		> 时间换算为时间戳 echo $(($(date --date="2014/01/06" +%s)/86400+1))
		> sync				# 数据同步写入硬盘(因为Linux为了速度有一种内存数据暂时
			不写入硬盘的机制，所以执行此命令后可以马上写入硬盘)
		> 命令 & 			# 将此命令在后台执行
		> cal
			查看当月日历，cal 年份 查看指定年所有月日历
			cal 月份 年份 查看指定年月的日历
		> bc
			计算器(+加 -减 *乘 /取商 %取余 ^指数)
			在计算机模式下：
				1. 只需要输入表达式不需要写"="，直接回车可得答案
				2. 计算机默认预设输出除法的商，要得到小数需要输入scale=小数位数
				3. quit 退出
		> 指令 --help # 一般用于查询指令的用法内容
		> man指令一般用于查询指令或者系列文件格式的文档内容作用
			用man指令查出来的结果，在指令处也许有括号括住的数字(例如DATE(1))，括号数字代表：
				1: 用户在shell环境中可以操作的指令或可执行文件
				2: 系统核心可呼叫的函数与工具等
				3: 一些常用的函数与函式库，大部分为c的函式库
				4: 装制文件的说明，通常在/dev下的文件
				5: 配置文件或者是某些文件的格式
				6: 游戏
				7: 惯例与协议等，例如Linux文件系统、网络协议、ASCII code 等等的说明
				8: 系统管理员可用的管理指令
				9: 根kernel有关的文件
			# 在查询结果后输入 “/字符串”会向下查找字符串，输入 “?字符串”会向上查找字符串
			# 在指定查找后按n和N分别代表向矢量方向的向下和向上查找
			# 既然有man查出来的文档信息，通常这个文档信息是保存在某个目录里面的，通常
				是放在/usr/share/man这里的，然而可以修改它的搜寻路径来改善这个目录的问题
				往往是修改/etc/man_db.conf(有的版本为man.conf或manpath.conf或man.config等)
		> man -f 指令
			# 因为这里是查看具体指令的文档，所以这里的指令一定要正确
			# 可以查看更详细的文档参考目录。例如 man -f man 列出：
				man(1) 和 man(1p) 和 man(7)
			# 如果以后要指定看那个文档就要输入数字，例如 man 1 指令
			# 如果不指定数字则默认情况打开的是根据搜寻顺序有关。搜寻顺序往往记录在/etc/man_db.conf
				但一般来说是先搜寻到数字较小的那个
		> man -k 指令关键字
			# 可以查到所有跟关键字有关的说明文档
			# 也可以通过tab键补全的方式得到索要的命令，只是要查看说明文档还是要用man
		> 许多说明文档都会在/usr/share/doc下的
		> ctrl + alt + F1~F6	# 必须是在登录主机情况下选择切换连接终端
		> systemctl 指令(只有 CentOS 7.x 支持)
			指令如下：
				halt		# 进入系统停止的模式，屏幕可能会保留一些讯息，这与你的电源管理模式有关
				poweroff	# 进入系统关机模式，直接关机没有提供电力
				reboot		# 直接重新启动
				suspend		# 进入休眠模式
		> ulimit [命令选项] [配额]
			# 因为linux是属于一个多用户类型的系统，所以此命令是限制用户对系统资
				源的使用量
			命令选项：
				-H：hard limit，严格的设定，必定不能超过这个设定的数值
				-S：soft limit，警告的设定，可以超过这个设定值，但是若超过则有警告讯息。
					在设定上，通常soft会比hard小，距离来说，soft可以设我80
					而hard设定为100，那么你可以使用90(因为没有超过100)，但
					介于80~100之间时，系统会有警告讯息通知你！
				-a：后面不接任何选项与参数，可以列出所有的限制额度
				-c：当某些程序发生错误时，系统可能会将该内存中的数据写成文件(除错用)
					这种文件就被称为核心文件(core file)。此为限制核心文件的容量。
				-f：此shell可以建立的最大文件容量(一般可设定为2GB)单位为Kbytes
				-d：程序可使用的最大断裂内存(segment)容量
				-l：可用于锁定(lock)的内存量
				-t：可使用的最大CPU时间(单位为秒)
				-u：单一用户可以使用的最大程序(proess)数量
		
	* Bash常用快捷键
		> ctrl+a：把光标移动到命令行开头
		> ctrl+e：把光标移动到命令号尾
		> ctrl+c：强制终止当前的命令
		> ctrl+l：清屏
		> ctrl+u：删除或剪切光标之前的命令
		> ctrl+k：删除或剪切光标之后的内容
		> ctrl+y：粘贴ctrl+U或ctrl+K剪切的内容
		> ctrl+r：在历史命令中搜索，按下ctrl+R之后，就会出现搜索界面，只要
			输入搜索内容，就会从历史命令中搜索
		> ctrl+d：退出当前终端
		> ctrl+z：暂停，并放入后台，这个快捷键牵扯工作管理的内容
		> ctrl+s：暂停屏幕输出
		> ctrl+q：恢复屏幕输出
		
	* 目录命令
		> mkdir [命令选项] 地址加文件名
			命令选项：
				-p 递归创建路径，如果路径不存在就创建相应路径 例子: mkdir /a/b/c	
					，如果a，b其中一个不存在则报错所以用mkdir -p /a/b/c
				-m 预先设立权限，根据设立权限创建，不用在乎默认权限 例如：
					mkdir -m 744 /home/test/direct
				
			# 还可以在一个目录下创建多个目录，假如/a/b已经存在 mkdir /a/b/c /a/b/c2则创建了c,c2
			# 创建目录或文件(如果目录中包含没有的目录会报错)
			
			
				
		> rmdir	[-p] 目录名 
			# 删除空目录(注只能删除空目录，如果加上-p则删除继续迭代删除往上的空目录)

		> cd 目录名	# 切换到对应挂载点
		> pwd [-P]	# 显示当前详细目录，如果跟了-P则表示显示确实的当前目录，而
						非连接(link)路径，例如 cd /var/mail	
			pwd		# /var/mail
			pwd -P	# /var/spool/mail
		> . 和 .. 	# .表示当前目录，..上一级目录
		> - 		# 代表最近改变工作目录前的工作目录
		> ~ 		# 代表[目前用户身份]所在的家目录
		> ~account 	# 代表 account 这个用户的家目录(account 是个账号名称)
		
		
	* 复制命令
		> cp 默认只复制文件
		> cp 源挂载1 源挂载2 源挂载3... 目标目录名	# 拷贝文件(也可以拷贝多个文件)
		> cp 源文件目录文件名 目标目录新名字 # 拷贝加改名字
		> cp [命令参数] 源挂载 目标挂载
			-a	# 相当于 -dr --preserve=all的意思
			-r	# 递归复制，用于复制目录(对文件有效，对有文件的文件夹也有效)
			-p	# 保留文件属性(因为单纯的拷贝，拷贝后新地址的文件修改时间会成操作时间,
				所以用-p可以保留原时间信息)
			-d	# 若来源文件为连接文件的属性，则复制连接文件属性而非文件本身(硬链接可以正常复制，不必加此选项)
					否则复制连接文件过来，实际上是相当于复制了指引文件
			-f	# 进行强制，若目标文件已经存在且无法开启，则删除在尝试一次
			-i	# 若目标文件已经存在，在覆盖时先询问动作的进行
			-s	# 复制成为富豪连接文件，亦即快捷方式文件
			-u	# destination比source旧才更新destination，或destination不存在的情况下复制
			--preserve=all	# 除了-p的权限相关参数外，还加入SELinux的属性，links，xattr等
				也复制了，最后需要注意的，如果来源档有两个以上，则最后一个目的文件一定要是
				目录才行
			
			
				
	* 剪切改名命令
		> mv							# 改名，剪切
		> mv 原目录 目标目录			# 剪切
		> mv 文件名或文件夹名 目标目录	# 此方法也是剪切，
											前提是当前所在
											路径有这个文件
											名或文件夹名
		> mv 源目录 目标目录加新名字	# 剪切加改名
		> mv 源挂载1 源挂载2 源挂载3... 目标目录	# 移动多个挂载都目标目录
		> mv 旧名字 新名字				# 改名字，前提是在当前目录下的文件名\
			命令选项：
				-f						# 强制，如果目标文件存在，不会询问而直接覆盖
				-i						# 若目标文件相同，询问是否覆盖
				-u						# 若文件已经存在，且源文件比较新，才会更新
		
	* 删除命令
		> rm 默认值处理文件(如果有删除多个文件或文件夹，多个地之间用空格隔开)
		> rm 文件路径目录	# 删除文件，会提示是否删除,输入y或n表示是或否 
		> rm [-r 删除目录]	(对文件也有效，有子文件子文件夹的时候也能删除)
			 [-i 互动模式]	# 在删除前会询问使用者是否动作
			 [-f 强制执行] # 可以不提示直接删除，也可以解决有子目录的情况，而且不会提示你)
			 (注意：如果进入了某个文件夹，然后执行 rm * 则会删除当前路径下的所欲文件)
		
	* 文件操作命令
		> 创建文件
			touch [命令选项] 文件
				命令选项：
					-a		# 仅修改access time(ctime会自动变成当前时间)
					-c		# 仅修改文件的时间，若该文件不存在则不新建立新文件(修改三个时间)
					-d		# 后面可以接预修订的日期而不用目前的日期，也可以使用
								--date="日期或时间"(无法修改ctime，ctime会自动变为当前时间)
								
					-m		# 仅修改mtime(ctime会自动变成当前时间)
					-t		# 后面可以接预修订的时间而不用目前的时间，
								格式为[YYYYMMDDhhmm](无法修改ctime，ctime会自动变为当前时间)
		
			>> 注意：如果文件不存在则创建，如果文件存在则是修改它的更新时间
			>> touch # 创建文件
			>> 如果直接 touch 文件名 			# 没有指定路径情况下会在当前路径进行创建
			>> touch 路径文件名1 路径文件名2	# 这会创建两个文件,如果文件名有空格
													则相当于创建了两个文件，空格左边路径下一个，空格右边下一个
			>> 如果要创建一个有空格的文件名则应该用双引号" " 包围起来
			>> touch "xxx yyy"(不建议用这些有歧义的文件名)
			>> 复制内容cp -a 它的atime和mtime也会同时复制，但是因为复制后的文件是刚创建的
				所以ctime会是当前时间
			>> touch命令如果跟了文件，那么atime和ctime和mtime就都会变为当前时间
			>> touch -d 和 -t 并不能修改ctime的时间
		
		> 文件查看
			>> cat [命令选项] 挂载文件	# 查询文件内容
				命令选项：
					-A				# 相当于-vET 的整合，可列出一些特殊字符而不是空白而已
					-b				# 列出行号，仅针对非空白行做显示行号，空白行不标行号
					-E				# 将结尾的断行字符$显示出来
					-n				# 显示行号，连同空白行也会有行号，与-b的选项不同
					-T				# 将[tab]按键以^I显示出来
					-v				# 列出一些看不出来的特殊字符
					
			>> tac # 倒序显示文件内容
			
			>> nl [命令选项] 文件
				命令选项：
					-b：指定行号指定的方式，主要有两种：
						-b a：表示不论是否为空行，也同样列出行号，类似cat -n
						-b t：如果有空行，空的那一行不要列出行号
					-n：列出行号表示的方法，主要有三种：
						-n ln：行号在屏幕的最左方显示
						-n rn：行号在自己字段的最右方显示，且不加0
						-n rz：行号在自己字段的最右方显示，且加0
					-w 数字： 行号字段的占用的字符数
						-n rz -w 3：行号只显示三位数

		> 文件翻页查看
			>> more 文件路径名	# 分页查询
			>> 输入了以上指令后: 
				1. 按空格键或f键是翻页 
				2. 按enter键是逐行显示 
				3. 按q或Q退出翻页模式
				4. :f显示出文件名以及当前所在行号
				5. /字符串	# 查找字符，按n往下查，按N往上查
			

		> 文件可退页的翻页查看
			>> less 文件路径名	
				1. 可以反向翻页的分页查询
				2. 正常翻页和more指令一样,pageup往上翻页,上箭头往上翻一行
				3.在less模式里输入 /关键词 
					# 可以标记有关键字的信息,此时按n键可以
						往下搜索相应关键词的信息
			
		> head [-n 数字] 文件路径名	
			# 没有扩展选项会默认显示前10行，如果数字是绝对值则显示前数字行
				如果数字为负数则显示除了后绝对值的所有行，其它全部显示
		> tail [-n 数字] 文件路径名	
			# 没有扩展选项默认显示后10行，如果数字为有“+”的数字表示显示数字
				绝对值及其以后的所有行，如果跟单纯的绝对值表示显示后数字行
		> tail -f 文件路径名	# 此时会显示文件后10行，但是如果这个文件被其它线程改变
			那么这里的内容会自动同步显示
			
		> od [-t 命令参数] 文件
			命令参数：
				a	# 利用默认的字符输出
				c	# 使用ASCII字符输出
				d[size]	# 利用十进制输出，每个整数占用size字节
				f[size] # 利用浮点数输出，每个数占用size字节
				o[size] # 利用八进制输出，每个整数占用size字节
				x[size] # 利用十六进制输出，每个整数占用size字节
		
	* 软硬连接命令
		> ln -s 源文件或文件夹路径名 新文件路径名	
			# 生成有链接的软文件相当于快捷键,如果
				原文件为文件夹或文件那么软连接就为对应类型
		> ln 源文件路径名 新文件路径名	
			# 生成有链接的硬文件
			
		> 两者区别：	
			>> 软连接文件三个权限都是rwx
			>> 当源文件移动了位置后，软连接会失效，查看详情后
				它的“->”信息会报红硬链接会同步所以仍然可以指向
				源文件，查询详细信息硬链接并无“->”指引符号
			>> 硬链接的id和源文件的id一样，软连接则不一样
			>> 硬链接不能垮分区，也不能指向目录
			>> 删除源文件后，硬链接无影响，软连接指引失效
		
		> 注意：
			>> 软连接可以跨分区，硬链接不能跨分区使用
			>> 软连接无要求，硬链接不能针对目录使用
			>> 如果软硬链接删除后，源文件不会删除。不一样的是，
				可以利用硬链接实现数据同步
			
	* 权限管理
	
		> 只有文件所有者和超级管理员可以更改权限
		> chmod [R] # 命令可以更改文件或目录权限(加上-R是递归修改)
		> chmod [{ugoa}{+-=}{rwx}][文件或目录地址]	# 三个括号分别表示
			1.所属人,所属组,其它,全部 2.增加,减少,强制修改 3.读,写,执行
		> 如果有多个授权可以用 ","分隔 例如: chmod u+w,g-r,o=rw
		
		> 权限对应的值: r---4, w----2, x----1	# 如果多个权限就是权限值相加
		> rwxrw-r--
			7 6 4
				-R 递归修改
		> chmod 520 文件目录地址  等价于  chmod u=rx,g=w,o-rwx	# 那三位数字分别表示三个不同针对的权限
		> 因为如果更改了一个目录的权限，但是目录的子文件和文件夹权限不会改，如果都要改就用-R递归修改
		> 如果一个目录A有修改权限，就算其子目录的权限没有w权限也能删除A(理由请见权限分析)
		> 注意要删除一个文件不是这个文件有w权限，而是这个文件的上级目录是否有w权限
		> 权限对于文件和文件夹的作用
			对于文件: (r: 可以读取文件内容, w: 可以修改文件内容, x: 可以执行文件)
			对于文件夹: (r: 可以列出文件夹内的目录内容, w: 可以创建/删除文件夹内的内容,
						w: 可以进入文件夹)
						
	* 改变文件的所属者/所属组
		> chown [-R] 用户名 文件或文件夹路径	# 改变所属者，并且只能root有权限
			chown [-R] 所属者:所属组 文件或文件夹路径 # 同时更改所属者和所属组(所有者和所属组可省略一个)
			chown [-R] 所属者.所属组 文件或文件夹路径 # 更改所属组(所有者和所属组可省略一个)
			注意：以防所属者或所属组名字中有空格，造成第三种方式的歧义建议
			用第二种
		> chgrp [-R] 组名 文件或文件夹路径	# 改变所属组
		
	* 权限管理命令
		> umask -S	
			# 可以显示新建文件或文件夹的u,g,o的缺省权限
			# 但是权限显示和创建的文件默认权限会不一样
		> umask	
			# 将权限用一个四位数显示，从左至右第一位表示特殊权限，
			# 后三位分别表示u,g,o的权限
		> umask -S 显示的是rwxr-xr-x ， umask 显示的是0022
		> 但是文件的权限为rw-r--r-- 与指令显示的权限不是一样的
			即文件的默认权限是在文件夹的默认权限基础上取消x
			第一位代表特殊权限，其它三位来历请见:
				满权限-->   777: rwx rwx rwx
				要求权限--> 755: rwx r-x r-x
				结果得出--> 022: --- -w- -w-(即222，规则是同时存在则去掉，
					否则取存在的值，类似于异或)
			那么要设置文件夹默认权限为 rwx------时
				则输入 umask 077(但是不建议修改默认权限)
		> umask 权限出来的数字代表去掉的权限，这样好理解
		> 关于预设的umask权限应该修改/etc/bashrc
	* 缺省的所有者和所属组
		> 创建一个文件的缺省所有者就是创建文件的用户
		> 一个用户可以有多个所属组，但是每个用户只有一个缺省所属组,
			那么创建文件的默认所属组就是这个缺省所属组
	
	* 搜索命令
		> find [PATH] [option] [action] # 查找指定的文件信息(此命令适用于所有用户)
			命令选项：
				# atime，ctime， mtime的用法都差不多
				-mtime n	# n为数字，意义为在n天之前的[一天之内]被更动过内容的文件
				-mtime +n	# 列出在n天之前(不含n天本身)被更动过内容的文件
				-mtime -n	# 累出在n天之内(含n天本身)被更动过内容的文件
				
				—— —— —— —— —— —— —— ——
				  7  6  5  4  3  2  1  现在
				<------+4  -4--------->
				        <-4->
					
				范例：
					find / -mtime 0	# 代表从现在开始到前24小时这个时间段内被修改
						过的文件
					find / -mtime 3	# 代表3天前的24小时更动过的文件\
					
				-newer file	# file为一个存在的文件，累出比file还要新的文件
					
				-inum ID	# 指定i节点，即ls -inum所显示每条记录的i节点，相当于id
				-uid ID号	# 指定用户的UID
				-gid ID号	# 指定组的GID
				-name 名字	# 通过文件查询条件的数据(
					例如 find /home/ -name ini，这样只能是一个ini单词的记录能够查询到
					，并不是包含ini字符的记录，所以这是精确的不是模糊的，如果要查询仅
					仅是包含ini的文件的模糊查询则应该为 find /home/ -name *ini*，如果
					是ini开头后面只跟两个字符的应该为 find /home/ -name ini??，如果查询
					ini但是不区分大小写则应该为 find /home -iname ini)

				-user 名字	# 根据所属者查找，例如: find /home/ -user zhou00(查找home/
					目录下所属者是zhou的内容)
				-group 名字	# 根据所属组查找
				-nouser		# 查找文件拥有者不在/etc/passwd的人的文档
				-nogroup	# 寻找文件的拥有群组不存在于/etc/group的中信息的文档
								当你自行安装软件时，很有可能该软件的属性中没有文
								件拥有者，这是可能的。

				-size 【+-】SIZE
					# +n或-n或n(分别是大于小于等于相应的值)，如果只是数字表示数据块
					1 = 512B = 0.5K，例如: find /home/ -size +2 ---->大于1KB的)
					这个SIZE的规格有c：代表byte；k：代表1024bytes；所以要找比50kb
					大的文件就是 -size +50k

				-type 根据文件类型查找 
					# f一般正规文件 d目录 l软链接文件 b,c装置文件，s是socket文件，
						p是FIFO
						例如: find /home -type f -a -name *.txt	
						# 查找home目录下名字一.txt结尾并且是文件的信息
					
				-a(与的条件) -o(或的条件) 例如: find /home -size +5 -a -name ini
					表示大小为5个数据块并且名字为ini的
					-exec或者-ok 命令 {} \; 
					对搜索结果执行命令操作，如果用-ok
					那么会查到的每个结果会询问你是否进行命令执行，回y或n，
					如果用-exec则不必询问直接执行
					例如:
					find /home -type f -exec ls -ilh {} \;(表示在home目录下
					查找所有文件并且用ls -ilh 的命令进行信息显示，也可以进行
					删除操作
					
				-perm mode：搜寻文件权限刚好等于mode的文件，这个mode为为类似chmod
					的属性值，举例来说，-rwsr-xr-x的属性为4755
				-perm -mode：搜寻文件权限[必须要全部囊括mode]的权限，举例来说我们
					要搜寻-rwxr--r--，亦即0744的文件，使用-perm -0744，当一个文件
					权限为-rwsr-xr-x，亦即4755时，也会被列出来，因为-rwsr-xr-x的
					属性已经囊括了-rwxr--r--的属性了
				-perm /mode：搜寻文件权限[包含任一mode的权限]的文件，举例来说，
					我们搜寻-rwxr-xr-x，亦即-perm /755时，但一个文件属性为-rw-------
					也会被列出来，因为他有-rw...的属性存在
					
				-exec command：command为其它指令，-exec后面可以再接额外的指令来处理
					搜寻到的结果
				-print：将结果打印到屏幕上，这个动作是默认动作
				
				# 范例：find / -perm /700 -exec ls -ilh --color=auto {} \;
			
				-amin(访问时间access)
					# 查看相应指定时间被浏览访问的
				-cmin(文件属性change，通过ls查看到的信息更改的时间) 
					# 查看相应指定时间文件属性被修改过的
				-mmin(文件内容modify)
					# 查看相应指定时间文件内容被修改过的
						+时间(超过时间) -时间(时间之内) n(等于时间)
						例如: find /home/ cmin -5 5分钟之内被更改过得文件信息

		> locate [命令选项] 关键字
			
			locate是根据 /var/lib/mlocate/ 里的信息进行查询的
		
			命令选项：
				-i：忽略大小写的差异
				-c：不输出档名，仅计算找到的文件数量
				-l：仅输出几行的意思，列入输出5行则是 -l 5，即查到的结果只显示指定行
				-S：输出 locate 所使用的数据库文件的相关信息，包括该数
					据库所记录的文件/目录数量
				-r：后面可接正则表达式
			>> 简介:
				更快的查询
				它是建立一个文件资料库提供查询并且默认定时更新，不是在硬盘里直接查询，
				所以有时候文件存在却查不到，并且如果文件存在tmp的临时文件夹中也可能查
				不到,即使是updatedb也可能查不到
				
			>> updatedb 更新资料库
			
			
			
		> grep [命令选项] 查找字符串 文件路径名 
			# 可以查找文件内容中指定字符串的所在的所有行号及其行显示
			
			命令选项：
				-E 支持延伸型正则表达式(可以用 egrep 命令代替)
				-a 将二进制文件以text文件的方式搜索
				-c 计算找到搜寻字符串的次数
				-i 是不区分大小写，例如: grep -i Jane /home/test/t.txt
				-n 输出行号
				-v 排除指定字符串的行，例如: grep -v ^# /home/test/t.txt 
					显示不是以#开头的所有行
				--color=auto 搜索出的关键字用颜色显示
	
	* 帮助命令
		> man 命令名
			进入帮助文档介绍你的命令(按空格翻页，enter一行一行翻， q退出，
				Home首页，End尾页)
			如果想往光标下查关键字，如-a 可以输入 /-a就可以定位了(?-a往上找)
			按n可以往下查找，按N往上查找，按q结束man查看
		> man 配置服务名
			查看服务的帮助文档，切忌勿写成 man 服务绝对地址名，否则
			是显示这个配置服务的内容
			passwd 命令有命令帮助文档以及配置文件帮助文档，要查看配置文档帮助
			信息就用 man 5 passwd
		> 在查询帮助文档中可能出现 命令(数字) 的内容，数字分别代表：
			1 用户在shell环境中可以操作的指令或可执行文件
			2 系统核心可呼叫的函数与工具
			3 一些常用的函数(function)与函式库(library)，大部分为C的函式库(libc)
			4 装置文件的说明，通常在/dev下的文件
			5 配置文件或者是某些文件的格式
			6 游戏(games)
			7 惯例与协议等，例如Linux文件系统、网络协议、ASCII code 等等的说明
			8 系统管理员可用的管理指令
			9 根kernel有关的文件
		> which [-a] 命令
			# 根据PATH的所有路径查找对应的执行档名，如果跟了-a则列出所有同名的
				档名，不跟-a则只列出第一个找到的档名
			# 根据PATH变量列出指定可执行档名所在的完整路径以及档名的别名
				范例：which -i cp 结果如果包含 cp='cp -i'那么就有别名
				
		> whereis [命令选项] 文件或目录名
			# 只在特定目录下进行查找。查找命令的执行文件，帮助手册，source来源文件等路径
			命令选项：
				-l：可以列出whereis回去查询的几个主要目录而已
				-b：只找binary格式的文件
				-m：只找在说明文件 manual 路径下的文件
				-s：只找 source 来源文件
				-u：搜索不在上述三个项目当中的其它特殊文件
				
			# 帮助文档路径中包含有 名字1 或 名字2的情况; 1：命令的帮助 5：配置文件的帮助
		> whatis 命令
			可以查看这个命令的简单简介	
		> apropos 配置文件名
			查看配置文件的简短信息
		> 命令 --help
			查看命令的所有选项
		> help shell内置命令
			用于查看shell的内置命令(shell相当于命令解析器，用于解析命令传给，
				因为命令是通过linux内核传给linux系统然后由系统返回处理后结
				果信息，shell命令通常man指令是查找不到的
	
	* 文书编辑器Vim
		> /etc/vimrc	# 此文件记录vim的默认配置，不过不建议修改，建议修改~/.vimrc
			同样也是默认配置文件，只不过/etc/vimrc是对于全局的
		> 简介:刚进入时是默认是命令模式(有命令模式，插入模式，编辑模式)
		> vi 文件详细名 则用vim打开
		> 命令模式
			1. 命令模式输入的任何字符都会默认认为是命令
			2. 输入wq: 退出vim
		> 插入模式
			1. 相当于平时windows的文本编辑的环境
			2. 在命令模式输入i a o(I A O)则自动转换成插入模式，
				在插入模式按ESC键则转为命令模式
				
		> 编辑模式
			1_0. 在命令模式输入 : 则左下角有: 的符号，此时就是编辑模式
			1_1. 在命令模式输入 / 或者 ? 也自动转为编辑模式，只不过作
				用为用来搜索
			1_2. gd按键(即先按g再按d会在光标所在单词高亮显示，并且按n会自动
				往下查找，而且所有相同的单词都会高亮显示，按[ESC]:noh 命令
				可以取消高亮
			2. 在左下角的冒号输入命令全为编辑模式命令，确定后自动转为命令模式
			
		> 命令(以冒号开头表示在编辑模式下输入，否则是命令模式)
		
			>> 常用命令以及操作:
				0.  a ---->在光标所在字符后插入，A ---->在光标所在行尾插入
					i ---->在光标所在字符前插入，I ---->在光标所在行行首插入
					o ---->在光标下插入新行,	 O ---->在光标上插入新行
					(这六个建按后除了有相应效果外还同时进入插入模式)
					
				1. 
					h、j、k、l	# 分别表示光标的左、下、上、右移动
					数字h|j|k|l	
								# 根据按的字母是h还是j还是k还是l让光标分别向左移
									数字个字符向下移数字行，向上移数字行，向右移
									数字行
					ctrl+f		# 屏幕向下移动一页，相当于pageDown
					ctrl+b		# 屏幕向上移动一页，相当于pageUp
					ctrl+d		# 屏幕向下移动半页
					ctrl+u		# 屏幕向上移动半页
					+			# 光标移动到非空格的下一列
					-			# 光标移动到非空格的上一列
					n<space>	# n是数字，在输入数字后按空格键光标会向右移动
									n个字符
					n<Enter>	# n是数字，再输入数字后按Enter键会让光标往下移
									n行，但同时光标还会移到行的最左端
					
				
				2. 
					gg	# 到第一行
					G	# 到最后一行
					nG	# 到第n行
					
				3.
					H	# 光标移动到这个屏幕最上方那一列第一个字符
					M	# 光标移动到这个屏幕的中央那一列第一个字符
					L	# 光标移动到这个屏幕最下方那一列的第一个字符
				
				4. . 不要怀疑！这就是小数点！意思是重复前一个动作的意思。如果你
					想要重复删除，重复贴上等等动作，按下小数点就好了
				
				5. 0	# 移到行首
				6. $	# 移到行尾
				7. x	# 删除光标所在字符
					X	# 删除光标前一个字符
				8. nx	# 删除光标所在处及后n个字符(包括光标所在位置)
					nX	# 删除光标所在处前n个字符(不包括光标所在位置)
					
				9.
					dd			# 剪切光标所在行
					ndd			# 从当前光标位置剪切n行
					d n h|l		# 删除之前或之后的n个字符(之前是不包含光标所在位
									置字符，之后是包含光标所在字符)
					d0			# 删除当前行光标之前的数据
					d$			# 删除当前行光标之后的数据
					dnG			# n为数字，从当前行删除到指定行
					dG			# 删除光标到最后一行范围的所有数据
					:n1,n2d		# 删除从n1~n2行的内容
					:nd			# 删除第n行
					D			# 删除光标所在行到文件末尾内容
					
				10.	
					yy	# 复制光标行
					nyy	# 复制当前行以下n行(包括当前行)
					y0	# 复制当前行第一个字符到光标所在的范围字符
					y$	# 复制当前行光标所在字符到当前行尾的范围字符
					y n h|l		# 复制当前字符到之前或之后的n个字符(之前是不包含
						光标所在位置字符，之后是包含光标所在字符)
					ynG	# n位数字，从当前行复制到指定行
					yG	# 复制当前行到最后一行范围所有数据
					n1,n2y	# 复制从n1~n2行的数据
					:ny	# 复制第n行
					
				11.
					小写p	# 粘贴在当前光标所在行的下一行
					大写P	# 粘贴在当前光标所在行的上一行
					
				12. r ---->取代光标所在处字符
				13. R ---->从光标所在处开始替换字符，按Esc结束
					否则一直是替换模式
					
				14. 
					J		# 将光标所在行和下一行结合成同一行
					c		# 重复删除多个数据，列入向下删除10列，范例：10cj
					u		# 复原前一个操作
					ctrl+r	# 重做上一个动作
					
				15. /字符串	---->查找你要找的字符串，再按n继续查找
				16. :%s/旧字符串/新字符串/g或者c ---->全文把旧的替换成新的字符串
						如果跟g则不询问，跟c则每次询问
						
				17. 
					:n1,n2s/旧字符串/新字符串/g或者c 
						# 指定替换范围，从n1~n2把旧的替换成新的字符串 n1,n2分别是相应行数
							并且最后如果是g表示全部替换，如果是c会每行一个且询问
					:n1,n2s/^/#/g 
						# 表示把n1~n2行的开头替换成#(行尾表示用"$")开头是一个位置不是第一
							个字符相当于在开头增加"#"
					:n1,n2s/#//g 
						# 表示把n1~n2行的"#"替换成空字符串中间没有内容表示空字符串
					:n1,n2s/^#/kk/g 
						# 表示把n1~n2行的第一个"#"字符替换成"kk"
					:1,$/old_string/new_string/g	
						# 表示第一行到最后一行的替换
				
					# 正则表达式
						1. 由于"/"会被认为是命令的一部分，所以替换和被替换的字符串中如
							果有"/"字符串应该用"\/"进行转义表示
							
						2. 
							\<: 单词的开头
							\>: 单词的结尾
							\{n,m}: 重复n 到 m 次
							\?: 0个或一个
						
						
				
				17_1. :set nohl						# 关闭高亮
				18. :set ic							# 忽略大小写，在用命令模式查
														找就可以忽略大小写
				19. :set noic						# 取消忽略大小写
				20. :set number 或者 set num		# 为内容添加行号
				21. :set nonumber 或者 set nonum	# 取消行号
				
				
				22. :wq	# 保存修改并退出vim
				23. :n	# 到第n行
				
				24. :w	# 保存修改
					:w new_filename	# 另存为指定文件(例：:w/home/test/copy.txt)
					:n1,n2 w filename	# 将n1到n2的内容存储到filename这个名字的文件
					:w!	# 若文件属性为只读，则强制写入，不过到底能不能写入还是跟你
						对文件的权限有关
						
				25.
					:q	# 离开
					:q!	# 若修改过文件，又不想保存则使用该命令强制离开且不保存
					
				26. ZZ	# 快捷键，保存修改并退出
				27. 
					:！ command	# 暂时离开vi到指令模式下执行command的显示结果！例如
					:! ls /home	即可在vi当中查看 /home 低下以 ls 输出的文件信息！
				
					
				28. :r 文件路径名	# 将此文件内容导入到光标下一行
			
			
				29. :r !命令	# 可以把命令执行结果导入到光标所在位置(例: ":r !date"
					就可以在光标处加上当前时间)
				30. :map 快捷键 触发命令(例:在行首加上"#"后然后返回命令模式,
					想把此效果作为ctrl+p的快捷键，则在编辑模式输入map 然后
					control+v+p一起按(或者先按control+v再按control+p)，
					然后空格隔开好输入具体命令 
					命令输入 I#<ESC>
				31. 设定后重启会失效，因为没有把vim设定写在每个用户的家目录下
					(root用户)/root/.vimrc (普通用户)/home/用户名/.vimrc (.vimrc为文件名在里面写
					编辑模式下的命令，那么那个用户启动vim时这些命令会自动执行)
				32. :ab 字符串a 字符串b 在命令模式输入 字符串a 后空格或回车，
					字符串a就会变为字符串b

		> 关于断行字
			>> 因为windows断行字是^M$，而linux是LF($)，所以需要转换
			>> 但是linux本身不具备这个转换软件，需要光盘里的软件安装
			>> 步骤：
				su -
				mout /dev/sr0 /mnt
				rpm -ivh /mnt/Packages/dos2unix-*
				umount /mnt
				exit
			>> 命令：
				dos2unix [-kn] file [newfile]
				unix2dox [-kn] file [newfile]
				命令选项：
					-k			# 保留该文件原本的mtime时间格式(不更新文件上次内容经过修订的时间)
					-n			# 保留原本的旧档，将转换后的内容输出到新文件，如：dos2unix -n old new
		
		> 高级应用：内容选择，多开分屏，内容补全
		
			>> 文档区域块选择
				v：字符选择，会将光标经过的字符反白
				V：列选择，会将光标经过的列反白选择
				ctrl+v：区域块选择，可以用长方形的方式选择资料
				y：将反白的地方复制起来
				d：将反白的地方删除掉
				p：将刚刚复制的区域块，在游标所在处贴上
				
			>> 多开分屏
				1. vi A文件 B文件 C文件 ...
				2. :files	# 列出现在vim已经打开的所有文件
				3. :n 下一个文件
				4. :N 上一个文件
				5. :wq! 保存并退出
				6. :sp [文件名]	
					# 如果不跟文件名则把当前这个被vim打开的
						文件水平分屏的形式两个窗口打开
					# 如果跟文件名则把当前被vim打开的文件和
						你设定的文件用水平分屏的形式两个窗
						口打开
					# 如果是vsp则是竖直分屏
				7. 在已经打开一个文件的时候
					:vnew 文件名	# 与新文件竖直分屏
					:new 文件名		# 与新文件水平分屏
				
				8. 
					:files	# 可以列出已经被vim打开的文件
					ctrl+ww # 焦点后一个文件(或者ctrl+w，然后按上下键切换)
					ctrl+wq # 焦点前一个文件用以上两个其中一个连续使用也能切换
					
					ctrl+w+j 或 ctrl+w+下	# 先按ctrl+w然后松开两个键，再按第三
						个键光标移动到下方的窗口
					ctrl+w+k 或 ctrl+w+上	# 先按ctrl+w然后松开两个键，再按第三
						个键光标移动到上方的窗口
					ctrl+w+q				# 结束下方的窗口
				9. :only 取消分屏
					
				10.
					vim -o数字 文件名1 文件名2	# 水平分屏(数字代表要分屏的个数)
					vim -O数字 文件名1 文件名2	# 竖直分屏(数字代表要分屏的个数)
					
				11. vi -o 文件路径1 文件路径2 ...	# 水平多开文件
				12. vim 文件1 文件2					# 打开多个文件
				
			>> 分屏情况下的内容调换
				ctrl + W + H|J|K|L		# 内容移动左|下|上|右的窗口中，如果刚好
					是两个分屏则是内容调换，多个分屏待测试
					
			>> 分屏的尺寸
				ctrl + W <				# 调节分屏宽度
				ctrl + W >				# 调节分屏宽度
				ctrl + W =				# 所有的屏一样的高度
				ctrl + W +				# 增加高度
				ctrl + W -				# 减小高度
		
			>> 内容补全
				ctrl+x -> ctrl+n
					# 透过目前正在编辑的这个文件中的内容进行补全
					
				ctrl+x -> ctrl+f
					# 以当前目录内的文件名作为关键词进行内容补全
					
				ctrl+x -> ctrl+o
					# 以本文件的扩展名作为语法补充，以vim内建的关
						键词作为补充
						
				# 使用方法：在需要补全处先按ctrl+x，然后根据需要按
					剩下的组合键
				




				
	* 用户管理
		> useradd 用户名	# 添加用户
		> passwd 用户名		# 改密码(普通用户如果改密码太过简单则不能成功)
		> who	# 查看登录用户的信息，三列信息分别是
			1_ 登录用户名 
			2_ 登录终端(tty表示本地终端，pts表示远程终端) 
			3_ 登录时间(包含ip地址，没有则为本机登录)
		> w		# 查看登录用户的详细信息
		
	* 压缩
		> 集中压缩格式简介
			>> 一些格式
				*.zip windows和linux通用的格式
				*.bz2、*.gz、*.tar *.xz Linux的常见的一些压缩和打包格式
				
			>> gzip [命令选项] 文件路径名
				命令选项：
					-c		# 将压缩的数据内容输出到屏幕上，可透过数据流重导向来处理
						用法：gzip -c 被压缩文件 > 结果文件名
						此方法还会保留源文件,并创建压缩后的文件
					-d		# 解压
					-t		# 可以用来检验一个压缩文件的一致性，看看文件有无错误
						用法：gzip -t 压缩文件名
					-v		# 可以显示出源文件/压缩文件案的压缩比等信息
					-#		# #为数字，代表压缩等级，-1 最快，但是压缩比最差，-9
						最慢，但是压缩比最好，预设是-6
			
				其它：
					1. 压缩后后缀为.gz
					2. 压缩后不保留源文件，解压后不保留包
					3. 相应文件就压缩在了被压缩文件所在的路径下
					4. 只能压缩文件，并且压缩完毕后源文件就自动删除了
					5. 不管压缩的时候被压缩文件有没有跟文件路径，最后
						解压的都只是不带路径的文件不会存在解压出来有路径的情况
					6. gunzip 文件路径名(gzip -d 文件路径名) ---->解压文件
				
			>> tar命令
				tar [-z|-j|-J] [cv] [-f 结果档命] 处理的文件或目录	# 打包压缩
				tar [-z|-j|-J] [tv] [-f 处理的档命]					# 查看档命
				tar [-z|-j|-J] [xv] [-f 处理的档命]					# 解压缩
			
				1. tar 打包后文件路径名 被压缩路径目录
					1. 如果被压缩路径目录有多个则用空格隔开
					2. 打包后后缀为.tar，如果附带-z压缩后缀为.tar.gz
						如果附带-j压缩后缀为.tar.bz2
					3. 用于打包，打包后不会删除源文件，解包后不会删除源包
					4. 如果压缩时候被压缩的存在路径，那么解压后也会存在路径
					5. 打包后的文件会存在你当前所在目录，后缀应该为.tar
					6. 命令选项f写在最后，v写在倒数第二个字符，这样能够避免错误
					7. 命令选项: 
						-c : 打包，可搭配-v来查看过程中被打包的档名(filename)
						-x : 解打包或解压缩的功能，可以搭配-C在特定目录解开
							-c, -t, -x 不可同时出现在一串指令列中
						-z : 透过gzip进行压缩/解压缩，此档名最好为 *.tar.gz
						-j : 透过bzip2进行压缩/解压缩，此档名最好为 *.tar.bz2
						-J : 透过xz进行压缩/解压缩，此档名最好为 *.tar.xz
						-v : 在压缩/解压缩过程中，将正在处理的档命显示出来
						-f 文件名 : 指定文件名，这个选项指将要处理的文件
						-C 目录名 : 这个选项用在解压缩，指在特定目录进行解压(仅支持全部解压)
							范例：tar -jxv -f filename.tar.bz2 -C 目录名
						-t : 查看打包文件的内容含有哪些档名，重点在查看档名
							
						-p : 保留备份数据的原本权限与属性，常用语备份(-c)重要的配置文件
						-P : 保留绝对路径，亦即允许备份数据中含有根目录存在之意
						--exclude=FILE : 在压缩过程中，不要将FILE打包(可以多次调用)
							范例：tar -cjv -f /root/system.tar.bz2 --exclude=etc* --exclude=/riit/system.tar.bz2 /etc/root
							# 打包/root/下的所有文件，但是不打包以etc开头以及不打包自己
					
					# 其它范例
						无中间文件的拷贝
							tar -cvf - /etc | tar -xvf -			# 将/etc下的数据一边打包，一边解包
								并且不会产生中间文件，那两个 “-” 分别代表 standard output 与 standard input
								可以将 “-” 想象成 内存中的缓冲区(注意这条命令会把相应的数据拷贝到当前所在路径下)
						多文件打包为一个文件
							tar -czvf xx.tar.gz 文件1 文件2 文件3
							
				2. 注意
					A. 解压后包文件仍存在
					B. 命令选项f写在最后，v写在倒数第二个字符，这样能够避免错误
					C. 在压缩时候如果是写的是源文件的原路径名，则解压后会附带文件夹(
						并且不加-P的情况下会自动去掉第一个“/”，否则如果已解压就会直接
						解压到根下)
					D. 解压默认是全部解压，如果想解压其中某一个档名，则应该先用-t指令查看
						内部档名，然后在解压命令最后加上预解压档名名字即可(解压档名必须是
						压缩内部档名查询出来的结果中记载的)
					F. 压缩解压都不会删除源文件，解压后默认是在当前路径下，如果压缩包内的
						压缩内容是以“/”开头则会解压到相应根目录下的情况
					
			>> zip 压缩后文件名 文件或目录
				
				# 预设压缩后是保留源文件的
				# 预设解压后是保留压缩文件的
			
				1. 命令选项：
					-p：保留源文件原来的属性和权限
					-r：压缩目录
				2. 后缀.zip
				3. 解压情况跟tar命令类似
				5. unzip 文件名 ---->解压文件
				
			>> bzip2 [命令选项] 被压缩的文件路径名(此种压缩比惊人，只能压缩文件)
				命令选项
					-c				# 将压缩的过程产生的数据输出到屏幕上(参照gzip)
					-d				# 解压
					-k				# 保留源文件，而不会删除原始的文件(参照gzip)
					-z				# 压缩的参数(默认值，可以不加)
					-v				# 可以显示出源文件/压缩文件案的压缩比等信息
					-#				# 与gzip同样的，都是在计算压缩比的参数，-9最佳,-1最快
				1. 后缀 .bz2
				2. 压缩后保存在被压缩文件所在的目录里，解压后只有文件不带路径
				3. 命令选项:
					-k : 保留源文件
				4. bunzip2 [-k(保留源文件)]文件名 ----> 解压.bz2文件(gzip2 -d 文件名同理)
				
			>> xz [命令选项] 被压缩文件路径名(此种压缩比bzip2性能更强)
				命令参数
					-c				# 同样的，就是将数据由屏幕上输出的意思
					-d				# 解压缩的参数
					-t				# 测试压缩文件的完整性，看有没有错误
					-l				# 列出压缩文件的相关信息
					-k				# 保留源文件
					-#				# 同样的也有较佳的压缩比的意思
		
			>> 文本的压缩后查看内容
				>> 针对于.gz格式的压缩包
					zcat/zmore/zless 可以对应cat/more/less的方式来读取纯文本文档被
					压缩后的压缩文件的内容
					甚至于还可以用egrep查找纯文本压缩后文件中纯文本的内容
				>> 针对.bz2格式的压缩包
					bzcat/bzmore/bzless/bzgrep
				>> 针对.xz格式的压缩包
					xzcat/xzmore/xzless/xzgrep 可以对应cat/more/less/grep的方式
					读取文件内容
					
	* 备份
		> xfsdumpe 命令
			>> 此命令备份，第一次是对对象全部备份，之后会根据上一次作的变动情况增减数据备份
			>> 此命令不支持没有挂载的文件系统备份，所以只能备份已经挂载的(即只能
				支持已经挂载的文件系统，不能自定义文件备份)
			>> 必须使用root的权限才能操作(涉及文件系统的关系)
			>> 只能备份XFS文件系统
			>> 备份下来的数据(文件或存储媒体)只能让xfsrestore解析
			>> 是透过文件系统的UUID来分辨各个备份档的，不能具备两个相同UUID的文件系统
			
		> xfsdump [-L S_label] [-M M_label] [-l #] [-f 备份档] 待备份资料
			命令选项：
				-L		# 会记录每次备份的session标头，这里可以填写针对此文件系统的额简要说明
				-M		# 可以记录存储媒体的标头，这里可以填写此媒体的简易说明
				-l		# 是L的小写，就是制定等级~有0~9共10个等级(预设为0，完整备份)
				-f		# 有点类似tar，后面接产生的文件，亦可接例如/dev/sr0装置文件名或其它文档名等
				-I		# 从/var/lib/xfsdump/inventory列出目前备份的信息状态
		
		> 
			xfsrestore -I											# 查看备份文件资料
			xfsrestore [-f 备份档] [-L S_label] [-s] 待复原目录		# 单一文件全系统复原
			xfsrestore [-f 备份档] -r 待复原目录					# 透过累积文件复原
			xfsrestore [-f 备份文件] -i 待复原目录					# 进入互动模式
			
			命令选项：
				-I		# 跟xfsdump相同输出，可查询备份数据，包括label名称和备份时间
				-f		# 后面接备份档，企业界可能会接/dev/st0等磁带机，我们这里接档名
				-L		# 就是Session的Label name，可用-I查询到的数据，在这个选项后输入
				-s		# 需要接某特定目录，亦即仅复原某一个文件或目录
				-r		# 如果是用文件来存储备份数据，那这个就不需要使用，如果是一个磁带
					内有多个文件需要这个东西来达成累积复原
				-i		# 进入互动模式，进阶管理员使用的
				
	* 近似于扇区性质的备份
		> dd if=源装置文件 of=目标装置文件 bs=block大小 count=block数量
			选项与参数：
				if			# 就是源装置文件
				of			# 目标装制文件
				bs			# 规划一个block的大小，若未指定则预设是512bytes(一个sector的大小)
				count		# 多少个bs的意思
				
			# 这是直接将源装制文件的内容复制到目标装置文件		
			
			
		
	* 光盘刻录
	
		> mkisofs [-o 映像档] [-Jrv] [-V vol] [-m file] 待备份文件 -graft-point isodir=systemdir ...
			选项与参数：
				-o		# 后面接你想要产生的那个映像档档名
				-J		# 产生较兼容与windows及其的文件名结构，可增加文件名长度到64个unicode字符
				-r		# 透过Rock Ridge产生支持Unix/Linux的文件数据，可记录较多的信息(如UUID/GID等)
				-v		# 显示建置ISO文件的过程
				-V vol	# 建立Volume，有点像Windows在文件总管内看到CD title的东西
				-m file	# -m 为排除文件(exclude)的意思，后面的文件不备份的映像档中，也能够使用*通配符
				-graft-point	# graft有砖家或抑制的意思
				
			# 光盘一般格式被称为iso9660，这种格式一般支持旧版的DOS档命，也就是文件名
				8个字符，扩展名3个字符；所以如果加上-r那么可以记录更多的信息，甚至包
				扩UID/GID等权限
				
		> 
			wodim --devices dev=/dev/sr0				# 查询刻录机的bus位置
			wodim -v dev=/dev/sr0 blank=[fast|all]		# 抹除重复读写片
			wodim -v dev=/dev/sr0 -format				# 格式化DVD+RW
			wodim -v dev=/dev/sr0 [可用选项功能] file.iso	
				选项与参数：
					--devices		# 用在扫描磁盘总线并找出可用的刻录机，后续装置为ATA接口
					-v				# 在cdrecord运作的过程中，显示过程而已
					dev=/dev/sr0	# 可以找出此光驱的bus地址，非常重要
					blank=[fast|all]	# 为可抹除可重复写入的CD/DVD-RW，使用fast较快，all完整
					-format			# 对光盘片进行格式化，但是仅针对DVD+RW这种格式的DVD而已
					
					[可用选项功能] 主要是写入CD/DVD时可使用的选项，常见的有
						-data		# 指定后面的文件以数据格式写入，不是以CD音轨(-audio)方式写入
						speed=X		# 指定刻录速度，例如CDE可用speed=40为40倍数DVD则可用speed=4之类
						-eject		# 指定刻录完毕后自动退出光盘
						fs=Ym		# 指定多少缓冲存储器，可用在将映像档先暂存至缓冲存储器，预设为4m
										一般建议可增加到8m，不过，还是视情况而定
					
					针对DVD的选项功能
						driveropts=burnfree		# 打开Buffer Underrun Free模式的写入功能
						-sao					# 支持DVD-RW的格式
	
	* 网络命令	
		> write 用户名 [用户所在终端接]
			范例： write testAccount pts/2
				>> 然后继续输入信的内容，敲错了用Ctrl+退格键删除，Ctrl+D保存结束并发送
				>> 如果用户不在登录状态是发不出去的
				
			# 这个命令会严重影响他人办公
				mesg n	# 这个指令可以拒绝write的信息但是不能绝root用户发送的信息
				mesg y	# 接口对write信息的封闭
		> wall 信息内容
			给所有在线用户发送信息，包括自己也能够收到信息
		> ping [选项] ip地址
			>> 用于测试网络连通性，如果对方回复则可以通信，否则一直ping
			>> -c 指定发送次数
			>> 例如: ping -c 3 192.168.0.1
			>> 接收方ctrl+C中断ping请求
			
		> ifconfig
			>> 查看当前网卡信息
			>> ifconfig 网卡名称 IP地址		# 查看和设置网卡信息(只能临时设置网卡IP地址)
		> mail 用户名
			>> 回车后Subject:提示输入邮件名称，输入邮件名称后再回车会要求输入内容，
				ctrl+D保存结束并发送。
				用于为用户发送邮件，不管用户是否在线
			>> mail 光是mail命令就是查看邮件
				如果有信件，每个信件有序列号，按序列号回车就查看，
				h 			# 列出信件标头，如果要查询40封信件左右的信件标头可以输入 h 40
				d 序列号 	# 删除后续接的信件号码，删除20~40封为d20-40，如果要生效必须配合p指令
				s 			# 将信件存储为文件，例如把第5封信件内容存为 ~/mail.file则指令为 s5~/mail.file
				x			# 或者输入exit，这个指令之前不论你做了什么操作，用x离开后之前的都不生效
				q			# 这个离开会让你之前的操作生效
				
		> last	# 用于记录计算机所有登录的所有信息
		> lastlog	# 查看所有用户最近登录时间
		> lastlog -u 用户id		# 查看指定用户最后登录时间
		> traceroute 网络资源地址
			查看数据包到指定资源地址经过的所有节点
			
		> netstat	# 查看网络状态相关信息
			选项:
				-a : 本机所有的网络连接
				-t : TCP协议
				-u : UDP协议
				-n : 显示IP地址和端口号
				-l : 监听
				-p : 列出该网络服务的进程PID
				-r : 路由
				
			范例:
				# netstat -tlun 查看本机家庭的端口
				# netstat -an 查看本机所有的网络连接
				# netstat -rn 查看本机路由表
			
			结果分析：
				查询出来一半有两部分
				1. 与网络较相关的部分
				2. 与本机的进程自己的相关性(非网络)
				
				第一部分结果分析：
					Proto：网络的封包协议，主要分为TCP与UDP封包
					Recv-Q：非由用户程序链接到此socket的复制的总bytes数
					Send-Q：非由远程主机传送过来的 acknowledged 总 bytes数
					Local Address：本地端的IP:port情况
					Foreign Address：远程主机的IP:port情况
					State：联机状态，主要有建立(ESTABLISED)及监听 (LISTEN)
					
				第二部分结果分析(socket file)：
					Proto：一般就是unix
					RefCnt：连接到此socket的进程数量
					Flags：联机的旗标
					Type：socket存取的类型，主要有确认联机的STREAM与不需确认的DGRAM两种
					State：若为CONNECTED表示多个进程之间已经联机建立
					Path：连接到此socket的相关程序的路径！或者是相关数据输出的路径
			
			# 一些常用的端口意义：
				80：www
				22：ssh
				21：ftp
				25：mail
				111：RPC(远程过程调用)
				631:CUPS(打印服务功能)
		
		> 特殊文件
			# 进程都是在内存当中的，内存中的数据又都是写入到/proc/*这个目录下的
				所以可以直接观察/proc这个目录当中的文件
			# 目前主机上的各个进程的PID都是以目录的形态存在于/proc当中，由于开机
				执行的第一支程序systemd的PID是1，所以这个PID得所欲相关信息都写入
				到/proc/1的目录当中，可以直接观察这个目录
				ll /proc/1
				
				/proc/1/cmdline		# 这个进程被启动的指令串
				/proc/1/environ		# 这个进程的环境变量的内容
				
			# 系列档名意义：
				/proc/cmdline	# 加载kernel时所下达的相关指令与参数，查看此文件可以了解指令是如何启
					动的
				/proc/cpuinfo	# 本机的CPU的相关信息，包含频率、类型与运算功能
				/proc/devices	# 这个文件记录了系统各个主要装置的主要装置代号，与mknod有关
				/proc/filesystems	# 目前系统已经加载的文件系统
				/proc/interrupts	# 目前系统上面的IRQ分配状态
				/proc/ioports		# 目前系统上面各个装置所配置的I/O地址
				/proc/kcore			# 这个就是内存大小
				/proc/loadavg		# 还记得top以及uptime命令，上头的三个平均负载数值就是记录在此
				/proc/meminfo		# 使用free列出的内存信息
				/proc/modules		# 目前我们的Linux已经加载的模块列表，也可以想象成驱动程序
				/proc/mounts		# 系统已经挂载的数据，就是用mount这个指令呼叫出来的数据
				/proc/swaps			# 到底系统挂加载的内存在哪里，使用掉的partition就记录在此
				/proc/partitions	# 使用fdisk -l会出现目前所有partition，在这个文件中也有记录
				/proc/uptime		# 就是uptime的时候，出现的信息
				/proc/version		# 核心版本，就是uname -a显示的内容
				/proc/bus/*			# 一些总线的装置，还有USB的装置也记录在此
		
		> setup		# 更改网络配置，并且永久生效(radhat版本Linux 专有命令)
		
		> service network restart	# 重启网络
		
		> mount [-t 文件系统] 设备文件名 挂载点
			>> 直接mount命令是查看挂载情况
			>> 文件系统是内核对不同设备支持的类型，可以用cat /proc/filesystems 查看
			>> 光盘的文件系统类型是 iso9660
			>> 设备文件名是系统分配的
			>> 范例: 
				mkdir /mnt/cdrom	# 创建挂载点文件夹
				mount -t iso9660 /dev/sr0 /mnt/cdrom	
					# 将对应设备文件名挂载在指定挂载点
				(mount /dev/sr0 /mnt/cdrom 这个命令默认用 -t iso9660进行挂载)
				cd /mnt/cdrom # 查看挂载文件夹下的内容，即查看光盘下的内容
				
		> umount 设备文件名	# 取消挂载
			如果当前目录正在挂载点使用取消挂载会失败
			linux光盘用完了需要取消挂载点才能退出光盘，
			直接按弹出光盘物理键无效，因为系统认为正在使用。
			
	* 关机命令
		> shutdown(推荐使用，因为它能在关机和重启前先保存程序进程执行)
			>> 如果为指定时间默认1分钟后执行
			>> 选项:
				-k: 不真的关机，只是发送警告讯息出去(后面跟时间 信息)
				-c: 取消前一个关机命令
				-h 关机
				-r: 重启
			>> 范例:
				shutdown -k now message	# 会提示message信息
				shutdown -h now	# 立即关机
				shutdown -h +5	# 5分钟后关机
				shutdown -h 20:30	# 晚上八点半定时关机
			>> 其它关机命令:
				halt(系统停止，屏幕可能会保留系统已经停止的讯息！)
				poweroff(系统关机直接断电，屏幕空白，慎用)
				init 0
			>> 其它重启命令:
				reboot
				init 6
				
		> 系统运行级别
			>> cat /etc/inittab		# 查看启动级别文件
			>> 文件中的 id:级别:initdefault:	# 开机默认启动的级别
			>> runlevel		# 查看当前默认级别
			>> 启动级别
				0 关机
				1 单用户(只启动最简单的核心程序，其它的加载项都不加载，一般
					用于修复系统，相当于windows的安全模式系统)
				2 不完全多用户，不含NFS服务(仅仅是命令行，只是不包含NFS服务，
					NFS相当于unix和linux资源共享的程序)
				3 完全多用户(仅仅是命令行)
				4 未分配
				5 图形界面
				6 重启
			>> logout 退出命令



			
** 软件包管理
	* 在同一个版本的同一个软件可以同时安装源码包和rpm包(安装路径应该设置不相同)
		但是这种行为是非常不好的情况

	* 软件包分类
		> 源码包(能够看到源码但运行速度慢)
			>> 脚本安装包(有人为源码包写定了安装选择的情况，
				相当于自动安装，但源码包不能自动安装)
		> 二进制包(RPM包(可能linux版本不一样二进制文件也会不一样)、
			系统默认包，不能看到源代码，但运行速度快)
	* 优缺点
		> 源码包
			>> 优点： 开源可修改，可自由选择所需功能，
				更稳定效率高，卸载方便
			>> 确定： 
				1. 过程较多，安装较大软件集合时(如LAMP环境搭建)，容易出现
					拼写错误
				2. 编译过程时间长，安装过程一旦报错，新手很难解决
		> RPM包
			>> 优点：
				1. 包管理系统简单，只用几个命令就可以实现安装升级查询卸载
				2. 安装速度比源代码包安装快得多
			>> 缺点：
				1. 经过编译，不再能看到源代码
				2. 功能选择不如源码包灵活
				3. 依赖性
	
	* 绝大多数RPM软件包默认安装位置
		> /etc/ 配置文件安装目录
		> /usr/bin/ 可执行的命令安装目录
		> /usr/lib/ 程序所使用的函数库保存位置
		> /usr/share/doc/ 基本的软件使用手册保存位置
		> /usr/share/man/ 帮助文件保存位置
	
	* RPM的管理
		> RPM管理方式
			>> RPM 命令管理
			>> yunm 在线管理
			
		> RPM命名规则
			>> 范例: httpd-2.2.15-15.3l6.centos.1.i686.rpm
				httpd: 软件包名
				2.2.15: 软件版本
				15: 软件发布的次数
				el6.centos: 适合的Linux平台(如果没写则表示任何Linux平台)
				i686: 适合的硬件平台(如果是noarch则表示任何硬件平台)
				rpm: rpm包扩展名
			>> 如果一个文件是用 .so.数字 结尾的文件表示库依赖，表示这个
				文件不是独立的，存在于某个软件下，解决方案见依赖性模块依赖
				
		> 依赖性
			>> 树形依赖: a->b->c
				1. 卸载只能从左至右，安装只能从右至左
			>> 环形依赖: a->b->c->a
				1. 安装时候用一条命令安装同时a,b,c
			>> 模块依赖: 模块依赖查询网站: www.rpmfind.net
				1. 会告诉你那个文件的库依赖对应的某个linux版本对应的package程序
					只要对应的linux系统安装了对应的程序，那么这个库程序就存在了
				2. 通过yunm在线管理方式解决，通过一个命令装载，如果存在依赖问题
					会自动到一个有总资源服务的网站自动下载依赖，能够解决所有依赖
					问题，但redhad系列是要收费的，centOS是社区维护，不收费
			>> (ubuntu的yun命令为apt-get，centos的yun命令为yunm)
			
		> RPM包操作
			>> 简介
				1. 操作没有安装的软件包时用包全名，且所属位置要在存在未安装包的位置
					，操作已安装的软件用包名
				2. 包名和包全名的概念只在手动RPM的管理中有效
				3. 如果你是插入光盘安装需要对光盘挂载然后进入挂载点后在挂载
					点里进行安装
			>> 安装/升级/卸载
				1. rpm -ivh rpm全名
					-i 安装
					-v 查看安装信息
					-h 查看安装过程
					--nodeps 不检测依赖性(如果遇到依赖问题会出现要么装上不能用，
						要么很多底层功能失效等多种故障)
						
				2. rpm -U 包全名
					-U 升级
					-v 查看安装信息
					-h 查看安装过程
					
				3. rpm -e 包名
					-e 卸载
					-nodeps 不检查依赖性
			>> 查询
				1. rpm 命令选项 包名
					注意:
						包在生产好后就已经决定了其版本详细信息，并且也决定
						好了默认安装路径，此路径是建议不要修盖，因为系列查询
						是有一定默认机制的，手动设置会打乱规则，不便管理
					命令选项:
						-q: 查询(查询对应的包是否安装)
						-a: 所有包
						-i 查询软件信息
						-p 查询未安装信息(如果用的是此选项则后面只能跟包全名)
						-l 列表(list)
						-f 查询系统文件属于哪个软件包，此文件必须为包安装所得，
							如果只是直接创建等非包安装形式所得则不能反向查到
							所属包
						-R 查询软件包的依赖性
					
					范例:
						rpm -q | grep 字符 ----> 查看所有包含字符关键字的所有包
						rpm -qa ---->查询所有已经安装的RPM包
						rpm -qip 包全名 ----> 查看对应的未安装包详细信息，
							此时需要当前路径在包列表所在路径
						rpm -ql 包名 ---->查看包中的文件装在哪里，如果要查未安装
							软件包预装位置则 包名改为包全名
						rpm -qf 系统文件名 查询系统文件属于哪个软件包
						rpm -qR 包名 ---->查看已安装包依赖
						rpm -qRp 包全名 ---->查看未安装包的依赖
						
			>> 校验和文件提取
				1. rpm -V 已安装包包名
					简介：
						查看软件是否有更改，无更改会没有任何显示，
						修改删除增加了已安装软件中的任何文件则表示已更改
						
						查询出来的三列数据，第一列表示修改的具体内容，第二列表示属于
						什么类型，第三列表示对应包下的路径的文件
					文件类型：
						c 配置文件
						d 普通文件
						g “鬼”文件，很少见，就是该文件不应该被这个RPM包包含
						l 授权文件
						r 描述文件
					验证内容的8个信息：
						S 文件大小是否改变
						M 文件类型或权限(rwx)是否改变
						5 文件MD5校验和是否改变(可以看成文件内容是否改变)
						D 设备中，从代码是否改变
						L 文件路径是否改变
						U 文件属主(所欲这)是否改变
						G 文件属组是否改变
						T文件的修改时间是否改变
						
				2. 文件提取
					rpm2cpio 包全名 | \cpio-idv.文件绝对路径
						rpm2cpio 将rpm包转换我cpio格式的命令
						cpio 是一个标准工具，用于创建软件档案文件和从档案文件中提取文件 
						"\"相当于命令太长分两行写完命令
						"."表示把提取的文件提取到用户当前所在目录
						这个命令可以理解为 rpm2cpio命令将相应的包转换成cpio格式，然后
						利用cpio命令在这个cpio格式的包中提取相应路径的文件
					cpio 选项 < [文件|设备]
						选项：
							-i copy-in模式，还原
							-d 还原时自动新建目录
							-v 显示还原过程
							
			>> yunm 在线管理前言
				1. 简介：
					主要用于自动安装解决依赖问题。
					不一定一定要上网，也可以在有包的CD环境进行安装
					主要用于自动安装解决依赖问题不一定一定要上网，
					也可以在有包的CD环境进行安装
					
				2. 附言配置永久生效网络配置
					2_0. setup
						配置网络永久生效的命令，此命令redhat专用
					2_1. 开启网卡
						配置完毕后保存过后，因为网卡默认是关闭的所以要开启，
						如果不开启，无论重启网络服务多少遍都无效
						vi /etc/sysconfig/network-scripts/ifcfg-eth0
						将文件中的ONBOOT="no"改为ONBOOT="yes"
						eth0表示第一块网卡，具体设置的网络根据情况选择网卡
					2_2. 重启网络服务
						service network restart
						
				3. 网络yunm源
					简介：
						通过联网在官网升级yum源软件资源，以.repo结尾的都是
						合法的yum源
					vi /etc/yunm.repos.d/CentOS-Base.repo
					[base] 容器名称，一定要放在[]中
					name 容器说明，可以自己随便写
					mirrorlist 镜像站点，这个可以注释掉
					baseurl 我们的yunm源服务器的地址。默认是CentOS官网的yunm源
						服务器，是可以使用的，如果你觉得慢可以改成你喜欢的yunm
						源地址，源地址服务器在国外
					enabled 此容器是否神效，如果不写或携程enable=1都是生效，xie
						成enable=0就不生效
					gpgcheck 如果是1是指RPM的数字证书生效，如果是0则不生效
					gpgkey 数字证书的公钥文件保存位置，不用修改
					
			>> yunm 在线管理
				1. yunm list ---->查询所有软件包列表(是从网上查询，所以需要联网)
				2. yunm search 包名 ---->搜索服务器上所有和关键字相关的包 
				3. 安装
					3_0. yum -y install 包名
						install 安装
						-y 自动回答yes(如果没有这个选项则每安装一个软件前
							会提醒你是否安装)
					此命令会自动下载安装需要的依赖，所以计算机一定要联网
				   3_1. 升级
					yum -y update 包名
						update 升级
						-y 自动回答yes
					如果不写包名表示升级系统所有软件包括linux系统内核，
					系统内核升级后需要在本地有一定配置才能正常运行，远程
					操作后就根本连接不上，所以注意，以防系统崩溃
				   3_2. 卸载
					yum -y remove 包名
						remove 卸载
						-y 自动回答yes
					假如有系列依赖是 软件a->b->c，如果要安装a，那么安装顺序是
					c,b,a在卸载的时候是a,b,c，如果要卸载c那么会连a,b也卸载，
					注意：有可能c被系统软件依赖，那么对应系统软件也会被卸载
					那么系统就可能出问题
				4. 软件包组
					4_0. yum grouplist ---->查看所有软件包组
					4_1. yum groupinstall 软件组名 ---->安装这个软件组中所有软件
						如果某个组的名字有空格，则用此命令安装时，对应软件组名应
						该用""包括起来，因为名字命名如果有空格表示不同的名字，双引
						号可以解决名字有空格的问题
					4_2. yum groupremove 软件组名 ---->卸载指定软件组
			
		>> 光盘yum源搭建
			1. 步骤：
				1_0. 挂载光盘
				1_1. 让网络yum失效(让以下除了第三个文件外其它文件后缀改掉)
					/etc/yunm.repos.d/ 目录下有文件
						CentOS-Base.repo
						CentOS-Debuginfo.repo
						CentOS-Media.repo
						CentOS-Vault.repo
					默认以第一个文件为连接网络源信息，如果不行则利用第三个
				1_2. 修改光盘yum源文件
					注意：修改文件必须按照对应格式修改，因为格式文件如果存在不
						必要的缩进和空格会报错
					vim CentOS-Media.repo
						name=CentOS-$releasever-Media
						baseurl=file:///mnt/cdrom
						# 地址为你自己的光盘挂载地址，file://是协议开头，第三个
						"/"表示根
						# file:///media/cdrom/
						# file:///media/cdrecorder/
						# 注释这两个不存在的地址
						gpgcheck=1
						enabled=1
						# 把enabled=0改为enabled=1，让这个yum源配置文件生效
						gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-6
						
	* 源码包安装
		> 一般默认安装位置：/usr/local/软件名/
		> 一般要想启动一个软件执行文件应该输入它的绝对路径
			但是RPM包安装的服务可以使用系统服务管理命令来管理
			绝对路径启动：/etc/rc.d/init.d/httpd start
			service命令启动：service httpd start
				(service 是 redhat版本Linux专有命令)
		> 源码包安装的服务不能被服务管理命令管理，因为没有安装到默认路径中
			所以只能用绝对路径进行服务的管理
		> 如何确定安装过程报错：
			> 安装过程停止
			> 并出现error、warning或no提示
		> 安装方式：
			> 创建安装路径
			> 解压到指定目录
			> 进入解压的文件夹在说明文档帮助下按照要求安装
		> 卸载源码包时只需要删除安装目录即可
		
	* 脚本安装
		> 不存在脚本安装包，安装包只存在源码、rpm安装包
		> 是认为吧安装过程写成自动安装的脚本，只要执行脚本，定义简单
			参数，就可以完成安装，非常类似于Windows下软件的安装方式



			
** 用户和用户组管理
	* 用户信息文件 /etc/passwd
		> 用于存放所有用户的信息
		> 如果将UID改为0那么系统会将UID为0的都当成超级管理员
		> 七个数据组成一行信息，数据间用":"分隔
		> 各字段含义
			1. 第1字段：用户名称
			2. 第2字段：密码标志
			3. 第3字段：UID(用户ID)
				0：超级用户
				1-499：系统用户(伪用户)
				500-65535：普通用户
			4. 第4字段：GID(用户初始组ID)
				组分类：
					4_0：初始组：就是建立一个用户时就会
						有一个跟用户名相同名字的组名存在
						每个用户的初始组只能有一个
					4_1：附加组：指用户可以加入多个其它的
						用户组，并拥有这些组的权限，附加组
						可以有多个
			5. 第5字段：用户说明
			6. 第6字段：家目录
				普通用户：/home/用户名/
				超级用户：/root/
			7. 第7字段：登录之后的Shell
			
			
		# UID范围代表意义：
			0：通常为系统管理员(不建议多个账号的UID是0，容易造成系统管理员混乱)
			1~999：保留给系统使用的id(一些程序不想用超级管理员运行而且要用一些较小
				的权限去执行，所以建立一些拥有者的账号去使用，并且通常不能作登录)
				1~200：由distributions自行建立的系统账号
				201~999：若用户有系统账号需要需求时，可以使用的账号UID
			1000~60000：给一般使用者用的，事实上目前的Linux(3.10.x版本)已经可以支持
				4294967295(2^32-1)这么大的UID号码了
			
	* 影子文件 /etc/shadow
		> 用于存放所有用户的密码信息
		> 九个数据组成一行信息
		> 各字段含义：
			第1字段：用户名
			第2字段：加密密码
				加密算法升级为SHA512散列加密算法
				如果密码位是"!!"或"*"代表没有密码，且不能登录
				注意：如果一个用户本来有密码，如果在换算加密后的
				密码字符串前加"!"，那么无论怎样的密码换算都不能成功
				相当于把此用户黑了
			第3字段：密码最后一次修改时间
				使用1970年1月1日作为标准时间，每过一天则时间戳加1(系统把1970/01/01
					那天算为了1)
			第4字段：两次密码的修改间隔时间(亦即密码不可被更动的天数)
				(和第3字段相比，即第三字段后几天内不能改)
			第5字段：密码有效期，亦即密码需要重新变更的天数(和第3字段相比)
			第6字段：密码修改到期前的警告天数(和第5字段相比)
			第7字段：密码过期后的宽限天数(和第5字段相比)
				0：代表密码过期后立即失效
				-1：代表密码永远不会失效
				其它数字：到期后宽限时间
			第8字段：账号失效时间
				> 要用时间戳表示
			第9字段：保留
			
		> authconfig --test | grep hashing		# 查看密码的加密机制
		> 就算忘记密码可以进入单人维护模式，系统会主动给予root权限的bash接口 或者
			以LiveCD开机后挂载根目录去修改/etc/shadow将密码清空
			
		> 时间和时间转换
			>> 把时间戳转换成日期
				date -d "1970-01-01 16066 days"
			>> 把日期换算为时间戳
				echo $(($(date --date="2014-01-06"+%s)/86400+1))
			>> 时间是由1970/01/01计算而来，那一天为0，而86400为一天的秒数
				%s为1970/01/01以来累计的总秒数
			
			
	* 组信息文件 /etc/group
		> 各字段含义：
			第1字段：组名
			第2字段：组的密码标志(一般用于root用户为组设立一个组长，组长
				以此密码来设定此组的组员删减)
			第3字段：GID
			第4字段：组中的附加用户，多个附加用户用","隔开
			
		> 相关命令
			groups			# 查看你所在的初始组和附属组(第一个是有效群组)
			newgrp 组名		# 切换成指定的组为有效群组(注意：这样能够在建文件的
								时候组别是你指定的那个组，并且你的指定组一定要位
								于你的默认组或者附属组中才能这样切换)
				
				newgrp命令相当于启动了一个新的环境，让父环境沉睡，用exit可以退出
				此环境，回到父环境
			
	* 组密码文件 /etc/gshadow
		> 个字段含义：
			第1字段：组名
			第2字段：组密码
			第3字段：组管理员用户名
			第4字段：组中附加用户
			
	* 家目录
		> 超级用户：/root/，所有者和所属组都是root用户，全显示550
		> 普通用户：/home/用户名/，所有者和所属组都是此用户，权限是700
		
	* 用户的邮箱
		> /var/spool/mail/用户名/
		
	* 用户模板目录
		> /etc/skel/
			这个目录为模板目录
			在用户家目录总有些隐藏文件，这些隐藏文件拷贝自模板目录，如果
			在模板目录增加文件A，则每新添加的用户的家目录就都有文件A
			
	* 用户默认值文件
		> /etc/default/useradd
			GROUP=100 # 用户默认组
			HOME=/home # 用户家目录
			INACTIVE=-1 # 密码过期宽限天数(shadow文件7字段)
			EXPIRE= # 密码失效时间(8)
			SHELL=/bin/bash # 默认shell
			SKEL=/etc/skel # 模板目录
			CREATE_MAIL_SPOOL=yes # 是否建立邮箱
		> /etc/login.defs
			PASS_MAX_DAYS 99999 # 密码有效期(5)
			PASS_MIN_DAYS 0 # 密码修改间隔(4)
			PASS_MIN_LEN 5 # 密码最小5位(PAM)
			PASS_WARN_AGE 7 # 密码到期警告(6)
			UID_MIN 500 # 最小和最大UID范围
			GID_MAX 60000
			ENCRYPT_METHOD SHA512 # 加密模式
			
	* 用户管理命令
	
		> useradd 的默认情况可以通过 useradd -D 进行查询，结果如下
			GROUP=100					# 预设的群组
			HOME=/home					# 默认的家目录所在目录
			INACTIVE=-1					# 密码失效日，在shadow内的第七栏
			EXPIRE=						# 账号失效日，在shadow内的第八栏
			SHELL=/bin/bash				# 预设的shell
			SKEL=/etc/skel				# 用户家目录的内容数据参考目录
			CREATE_MAIL_SPOOL=yes		# 是否主动帮助使用者建立邮件信箱(mail box)
			
			# 这些数据是由/etc/default/useradd呼叫出来的
	
		> useradd 用户名名	# 创建用户
			可选命令选项：
				-u UID： 手工指定用户的UID号
				-g 组名：手工指定用户的初始组
				-G 组名：指定用户的附加组
				-d 家目录：手工指定用户的家目录
				-c 用户说明：手工指定用户的说明
				-s shell 手工指定用户的登录shell，默认是/bin/bash
				-e 后面接一个日期，格式为YYYY-MM-DD 此项目可写入shadow第八字段，
					亦即账号失效日的设定项目
				-f 后面接shadow的第七字段，指定密码是否会失效，0为立即失效，-1为
					永不失效(密码只会过期而强制于登录时重新设定而已)
				-M 强制！不建立用户家目录(系统账号默认值)
				-m 强制！要建立用户家目录(一般账号默认值)
				-r 建立一个系统账号，这个账号的UID会有限制(参考/etc/login.defs)
			范例：useradd -u 666 -G root,liming -d /home/liming liming
			
			
		> usermod [选项] 用户名 # 修改用户信息
			可选命令选项：
				-u UID：修改用户的UID号
				-g：改初始组(强烈不推荐)
				-G 组名：修改用户的附加组
				-c 用户说明：修改用户的说明信息(如果说明有空格，则将内容用
					""双引号扩起来)
				-d 家目录：手工指定用户的家目录
				-s shell 手工指定用户的登录shell
				-a 与-G 合用，可增加次要群组的支持，而非设定
				-l 后面接账号名称，亦即是修改账号名称，/etc/passwd的第一栏
				-e 后面接日期，格式是YYYY-MM-DD也就是在/etc/shadow的第六栏
				-f 后面接天数，为shadow的第七字段
				-U：解锁用户锁定(Unlock)
				-L：临时锁定用户(Lock)
				
		
		> userdel [-r] 用户名 # 删除用户，如果加上-r则连同此用户的家目录
			一并删除
			
		> passwd # 更改当前用户的密码
		
		> passwd [选项] [--stdin] 用户名	
			# 如果没有命令选项那么输入此指令后会要求输入密码，即为此用户创建密码
			>> 可选命令选项：
				-S ：查询用户密码的密码状态(仅root用户可用，相当于看
					/etc/shadow的对应用户信息)
					# 用户名 密码设定时间 密码修改间隔时间 密码有效期 警告时间 密码不是失效(-1)
				-l ：暂时锁定用户(仅root用户可用)
				-u ：解锁用户(仅root用户可用)
				-n ：后面接天数，shadow的第4字段，多久不可更改密码
				-x ：后面接天数，shadow的第5字段，多久内必须要更改密码
				-w ：后面接天书，shadow的第6字段，密码过期前的警告天数
				-i ：后面接日期，shadow的第7字段，密码失效日期
				--stdin ：可以通过管道符输出的数据作为用户的密码
					范例：echo "123" | passwd --stdin user1 # 将user1的密码设为123	
		
		> chage [选项] 用户名 # 修改密码状态
			>> 可选命令选项：
				-l：列出用户的详细密码状态
				-d 日期：修改密码最后一次更改日期(shadow3字段)
				-m 天数：两次密码修改间隔(4字段)
				-M 天数：密码有效期(5字段)
				-W 天数：密码过期前警告天数(6字段)
				-I 天数：密码过后宽限天数(7字段)
				-E 日期：账号失效时间(8字段)
			范例：chage -d 0 user1 
				# 把user1用户的密码修改日期归0了(shadow3字段)
					这样用户一登录就被要求修改密码
				
		> id 用户名 # 查看用户的UID，GID，附属组ID
		
		> su [选项] 用户名 
			# 切换用户(如果不跟“-”就得不到切换用户的环境变量
			# 就容易出现各种未知名错误，所以“-”不能省
			# 可选命令选项：
				-：选项只使用“-”代表连带用户的环境变量一起切换
				-c：仅执行一次命令，而不切换用户身份
					格式：su - -c "命令" # 这个命令是指一次临时变换成root身份执
					行指定的命令
					范例：su -root -c "useradd user3" # 会要求你输入root密码，
					添加了一个user3用户
				-m: -m与-p是一样的，表示使用目前的环境设定，不读取新转换身份的环境
				-l: 与 - 相同，但后面需要加预切换的的使用者账号
	
	* 组管理
		> groupadd [选项] 组名 # 添加组
			可选命令选项：
				-g GID：组的组ID
		> groupmod [选项] 组名 # 修改组
			可选命令选项：
				-g GID：修改组ID
				-n 新组名：修改组名
		> groupdel 组名 # 删除组
			# 如果此组里至少包含一个初始组是此组的成员则不能删
			# 如果此组仅仅是属于附属组则可以删
		> gpasswd [-A usr1 ...] [-M user1 ...] 组名 
			
			# 如果没有任何参数时，表示给群组一个密码
			# 它仅仅是对附属组进行操作，不能把用户从自己的初始组中删除
			
			-A 将groupname的主权交给后面的使用者管理(即添加组管理员)
			-M 将此组作为某些账号的附属组
			-r 让组的密码移除
			-R 让组的密码栏失效
			
			-a 用户名：把用户加入组
			-d 用户名： 把用户从组中删除



			
** ACL权限管理

	* 简介：
		作用范例：如果有一个挂载点 /product_test 作为一个小组的开发，那么
		肯定应该为这个文件夹的所属组有750的权限，但是如果此刻有另外一个学
		员来实习，只能有读内容的权限。为了解决此问题做出了 ACL 权限
		
	* 查看/开启/设置 ACL 权限
	
		> 注意：
			>> 在为某个用户或组设定的ACL权限不是实际得到的权限，而是根据你
				设定的权限和mask最大权限进行相与得到的权限
			>> 在为某个挂载点设定了ACL权限之后用“ls”命令查看，会在权限那一
				列的最后有“+”符号代表了ACL权限
			>> 如果用“getfacl”命令查看会查看到具体的ACL详细信息
		> 查看是否支持ACL dumpe2fs -h /dev/sda3
			# dumpe2fs命令是查询指定分区详细文件系统信息的命令
			# 命令选项：-h 仅显示超级块中信息，而不显示磁盘块组的详细信息
			# 查一下指定分区是否支持ACL 查看Default mount options:
			# 如果有 acl 的内容则默认支持acl
			# 正常情况下是默认支持的
		
		> 开启ACL权限
			>> 临时开启，关机则失效
				范例：mount -o remount,acl /  
				# 如果不支持ac需要开启 ACL 权限
				# 重新挂载根分区，并挂载加入acl权限
			
			>> 永久开启生效
				范例：vi /etc/fstab
				# 此文件是系统开机自动检测挂载的文件，如果有任何错误则系统无法启动或崩溃
				# 在根分区行列的支持格式后面添加acl，默认是defaults，如果默认不包含acl那
					么就写成 defaults,acl
				# 此刻重启生效(如果不重启则重新挂载：mount -o remount /)
				
		> getfacl 挂载点 
			# 查看对应挂载点的所有者、所属组、其它人、ACL的人员或组的ACL权限详情
			# 查询出来的 master 代表有效权限，表示你设定的使用者或群组的权限必须
				在有效权限的范围内，使用 setfacl -m m:权限 挂载点 可以设定mask
		
		> setfacl 选项 文件名
			>> 命令选项：
					-m 设定ACL权限
					-x 删除指定的ACL权限
					-b 移除[所有的]ACL设定参数
					-k 移除[预设的]ACL参数，关于所谓的预设
					
					
					-R 递归设定ACL权限
						# 这个命令选项只能针对目录
						# 这个选项要刚好放在挂载点之前，否则报错，例如
							setfacl -m u:zhou00:rx -R /project/
					-d 设定默认的ACL权限(只对目录有效)
						# 如果设定了这个默认ACL权限，那么在这个挂载点下新增的文
							件都会权限都为设定的默认权限
					
			>> 范例格式：setfacl 命令选项 u|g|o:用户名|组名:权限 挂载点
			>> 范例1：setfacl -m u:用户名:rx 挂载点
				# 为用户设定ACL权限格式为“u:用户名:权限”
				# 为这个用户在此挂载点只有r和x的权限
			>> 范例2：setfacl -m g:组名:rwx 挂载点
				# 为组设定ACL权限格式为“g:组名:权限”
				# 为这个组在此挂载点有rwx的权限
			>> 范例3：setfacl -m o：rwx 挂载点
				# 为其它人设定ACL权限格式为“o:权限”
				# 为其它人设定ACL权限格式为 rw
			>> 范例4: setfacl -m u::rwx 挂载点
				# 如果没设定使用者列表，则代表设定该文件拥有者
				
	* 最大有效权限与删除ACL权限
		> 简介：
			# 可以用 getfacl 指令得到文件或文件夹的mask信息
			# mask是用来指定最大有效权限，如果设定了最大有效权限，最终得
				出的结果是给予的权限和mask权限“相与”得到的结果，例如：给定
				ACL为r-x，mask为rwx，则得到的结果为r-x
				
				结果会影响到：所属组，ACL权限的成员和组
				
		> 设定最大权限：
			setfacl -m m:rx /project/ # 设定mask最大权限为rx
		> 删除用户的ACL权限：
			setfacl -x u:用户名 文件名 # 删除指定用户的ACL权限
		> 删除组的ACL权限：
			setfacl -x g:组名 文件名 # 删除指定用户组的ACL权限
		> 删除所有ACL权限：
			setfacl -b 文件名 # 删除所有ACL权限包括用户的和组的
			
	* 默认ACL权限和递归ACL权限
	
		> 简介：
			此两个命令只能针对目录
		> 递归ACL权限
			范例：setfacl -m u:用户名:权限 -R 目录名
			# 对现有的目录及其目录下所有的文件都执行相同的权限，
				但是如果在里面新创建文件的权限就不能保持一致，为
				了解决此问题就用默认ACL权限
		> 默认ACL权限
			setfacl -m d:u:用户名:权限 [-R] 目录名
			或者写成
			setfacl -dm u:用户名:权限 [-R] 目录名
			# -R可以去掉，效果一样。对今后创建的文件执行与父目录
				相同的权限，但是对在执行此命令之前已经存在的子文
				件和子目录则不能更改它的权限



				
** 文件特殊权限
	* chmod 四位数 文件名
		> 这四位数第一位可能的数为：
			4：SUID
			2：SGID
			1：Sticky BIT
			两两相加或三个数相加：综合权限值
			
		> 注意：这三个数可以自由相加得到权限，跟rwx同理，但是
				这三种权限是各自针对的目录和文件的意义是不同的，
				如果跟7则有部分权限相当于白设，所以一般不会设7

		> 注意：特别是vim只有root用户可以修改/etc/shadow，如果
			为他添加了特殊权限那么普通用户就能够通过vim把自己变
			成超级用户(超级用户的UID为0)，所以这是很危险的
	* SUID
		> 简介：
			# 只有可执行的二进制程序才能设定SUID权限
			# 命令执行者要对程序拥有x权限
			# 命令执行者在执行有SUID权限的程序时会
				临时获得此程序所属者的身份
			# SetUID权限只在该程序执行过程中有效，
				也就是说身份改变只在程序执行过程中有效
			# SUID仅可用在binary program 上，不能够用在shell script上，
				因为shell script只是将很多的binary 执行档叫进来而已。
				所以SUID的权限部分，还是要看shell script呼叫进来的程
				序，而不是shell script本身。
		> 范例：
			# 例如使用passwd命令执行改密码，查看/usr/bin/passwd
				命令文件详细信息可以看到有s权限(SUID)权限，所以
				普通用户在执行passwd命令时相当于临时转换成root
				身份然后更改密码(因为shadow文件对任何人是没有任
				何权限的，只有root用户有权使用，因此SUID相当于
				临时变换成root身份进行更改密码的操作)
		> 范例2：
			# 一般passwd命令就是拥有SUID权限
		> 添加权限：
			chmod 4755 文件名 # 权限改为SUID和rwxr-xr-x
			或者 chmod u+s 文件名 # 直接增加SUID权限 
			# 第一位数相当于SUID权限
			# 若执行前-rwxr-xr-x 执行后 -rwsr-xr-x
			# 如果出现-rwSr-xr-x，大写S表示报错不可执行
		> 去掉权限：
			chmod 755 文件名 # 去掉SUID并且权限改为755
			chmod u-s 文件名 # 直接去掉SUID权限(两种方法都可)
			
	* SGID
		> 简介：
			>> 针对文件的作用
				# 只有可执行的二进制程序才能设置SGID权限
				# 命令执行者要对该程序拥有x权限
				# 命令执行在执行程序的时候，组身份升级为该程序文件的所属组
				# SetGID权限同样只在该程序执行过程中有效，也就是说组身份改
					变只在程序执行过程中有效
					
			>> 针对目录
				# 普通用户对此目录拥有r和x权限，才能计入此目录
				# 普通用户在此目录中的有效组会变成此目录的所属组
				# 若普通用户对此目录拥有w权限时，新建的文件的默认
					所属组会是这个目录的所属组
					
		> 范例：
			chmod 2755 文件名 # 把权限改为SGID 以及 rwxr-xr-x
			chmod g+s 文件名 # 直接增加SUID权限(两种方法都可)
				# 若执行前-rwxr-xr-x 执行后 -rwxr-sr-x
		> 范例2：
			一般locate命令就是拥有SGID权限
			
	* Sticky BIT(SBIT)
		> 简介：
			# SBIT粘着位目前只对目录有效
			# 普通用户对该目录有w和x权限，即普通用户可以在此目录拥有写入权限
			# 如果没有粘着位，因为普通用户拥有w权限，所以可以删除此目录下
				所有文件，包括其他用户建立的文件。一旦赋予了粘着位，除了root
				可以操作此目录下文件，普通用户就算拥有w权限，也只能操作自己建
				立的文件，但是不能其它其他用户建立的文件
				
		> 设置粘着位
			>> chmod 1755 目录名 # 设置权限以及粘着位
			>> chmod o+t 目录名 # 直接添加SBIT权限
			>> 设置前如果是rwxrwxrwx 设置后 rwxrwxrwt
		> 取消粘着位
			>> chmod 777 目录名 # 设置权限同时取消粘着位
			>> chmod o-t 目录名	
		> 范例：
				# 一般/tmp目录下就拥有SBIT权限
				
	* 文件系统属性权限chattr
		> 此权限只在Ext2/Ext3/Ext4的lunux传统文件系统上面完整生效，在xfs上仅支持
			部分参数而已
		> chattr [+-=][选项] 文件或目录名
			权限操作：
				+：增加选项
				-：删除权限
				=：等于某权限
			权限选项：
				A：	# 当设定了A这个属性时，若你有存取此文件(或目录)时，它的访问
					时间atime将不会被修改；可避免I/O较慢的及其过渡的存取磁盘。(
					目前建议用文件系统挂载参数处理这个项目)
				S：	# 一般文件是异步写入磁盘的(参考sync的说明)，如果加上S这个属性
					时，当你进行任何文件的修改，该更动会同步写入磁盘中
				s：	# 当设定了s属性时，如果这个文件被删除，它将会被完全移除这个
					硬盘空间，所以如果误删，完全无法救回来
				u：	# 与s相反，当使用u来配置文件时，如果该文件被删除了，则数据内容
					其实还存在磁盘中，可以使用救援该文件
				d：	# 当dump程序被执行的时候，设定d属性将可使该文件(或目录)不会被
					dump备份
				i：
					# 如果对文件设置i属性：
						不允许对文件进行删除、改名，也不能添加和修改数据
					# 如果对目录设置i属性：
						只能修改目录下文件的数据，但不允许建立和删除文件
					注意：此权利对root用户也有限制*************
					
				a：
					# 如果对文件设置a属性：
						只能在文件中增加数据，但是不能删除也不能修改数据
					# 如果对目录设置a属性：
						那么只允许在目录中建立和修改文件，但是不允许删除
					注意：此权利对root用户也有限制*************
					
				c：	# 这个属性设定之后，将会自动的将此文件压缩，在读取的时候将会
					自动解压；但是在存储的时候，将会先压缩在存储(看来对于大文件
					很有用)
					
			# 注意xfs文件系统仅支持AadiS而已；并且很多设定需要由root才能设定
					
		> 查看文件属性特殊权限
			>> lsattr 选项 文件名
				-a：显示所有文件和目录
				-d：若文件名是目录，仅列出目录本身的属性，而不是子文件的
				-R：连同子目录的数据也一并列出来
			>> 你也许会查询得出 ----i--------e- 文件名，i也许没有，如果有
				表示有i属性，e表示是在ext4格式下创建的
				
	* 系统命令sudo权限
	
		> root把本来只能超级用户执行的命令赋予普通用户执行
		> sudo
			# 此命令操作对象是系统命令
		> visudo
			# 实际修改的是 etc/sudoers文件，在里面添加具体的权限
			
		> 用户名A 被管理主机的地址P=(可使用的身份B) 授权命令(绝对路径)
		
			>> 执行命令后会要求用户输入自己的密码就可以执行相应用户的权限的命令
		
			>> 理解：让用户A可以在P地址的服务器上执行授权的命令，并且身份
				当做用户B来执行，严重注意这里的地址P跟平时理解的不同(因为
				可能有多台服务器服务一个服务，所以分不同网段)
				
			>> 范例1：
				root ALL=(ALL) ALL 
				
				由左到右一次含义:
				root:	# 代表可执行sudo命令的用户
				ALL:	# 代表那个网段(此处为所有网段)
				(ALL):	# 代表可替换成哪些用户(此处为可替换成所有用户)
				ALL:	# 代表替换用户后可执行哪些命令(此处为执行替换用户的所有命令)
				
				# 范例1含义为：root用户可以是任何网段登录的，并且可执行任何用户的
					任何命令
				
				# 第四个字段必须用指令所在的绝对路径，范例3：
					myuser1 ALL=(root) /usr/bin/passwd
				
				1.群组设定
					上面的只是为用户设定sudo，如果是为群组设定则第一个字段前加“%”符号
					范例2：
					%群组名 ALL=(ALL) ALL
					范例2_2：
					sc ALL=/sbin/shutdown -r now
						# sc用户在本机能够执行shutdown的重启命令，如果没有-r now
							则表示可以使用shutdown的所有命令，具体权限可以根据写的
							开放程度决定指定用户的使用范围
				
				2.限定操作
					如果按照范例1的情况的管理员用户在使用指令sudo passwd就会修改
					root的密码。为了防止此情况发生，可以在被禁止的命令前加“!”，
					范例3：
						myuser1 ALL=(root) !/usr/bin/passwd,/usr/bin/passwd [A-Za-z]*,!/usr/bin/passwd root
						# 那么myuser1的用户就不能直接执行passwd 和 passwd root的指令了
					
				3. 别名设定visudo
					User_Alias ADMPW = user1,user2,user3,user4
					Cmnd_Alias ADMPWCOM = !/usr/bin/passwd,/usr/bin/passwd [A-Za-z]*,!/usr/bin/passwd root
					ADMPW ALL=(root) ADMPWCOM
					
					# 这样上面的用户都可以执行root的身份执行规定的命令
					
					# User_Alias(用户别名)，Comnd_Alias(命令别名)，Host_Alias(来源主机主机别名)
					# 别名设定的变量名必须要大写
					
				4. sudo的时间
					同一个账号在短时间内再次使用sudo则不用输入密码了，因为系统认为
					是同一个人，但是超过5分钟后就会要求再次输入密码了
					
				5. sudo搭配su命令
					用户 ALL=(root) /bin/su -
					
					# 这样就可以直接输入 su - 然后输入自己的密码就可以转换成root了
					
					

		> sudo [-b] [-u 新使用者账号]
			# 此命令解决了使用不能登录档的用户的权限下去执行任务
		
			>> 命令选项：
				-b:	# 将后续的指令放到背景中让西戎自动执行，而不与目前的shell产生影响
				-u:	# 后面可以接欲切换的使用者，若无此项则代表默认切换到root
			>> 成员使用被赋予的权限
				>> sudo -l # 查看本用户被超级用户赋予了哪些权限
				>> sudo 查询得到的被授予的命令

	* PAM模块验证
		> vim /etc/nologin.txt	# 建立这个文件并且输入内容，以后有人用不能够登录
			的账号登录会提示这里面的信息，而不会显示默认信息
			
** 系统/分区/文件管理

	* df [选项] [挂载点]
		> 简介：
			从文件系统考虑的，不光要考虑文件占用的空间，还要统计被命令或程序
			占用的空间(最常见的就是文件已经删除，但是程序并没有释放空间)
		> 命令选项：
			-a：显示所有的文件系统信息，包括特殊文件系统，如/proc、/sysfs
			-h：使用习惯单位显示容量，如KB，MB或GB等
			-T：连同该分区的filesystem名称(例如xfs)也列出来，就是文件系统
			-m：以MB为单位显示容量
			-k：以KB为单位显示容量。默认就是以KB为单位
			-H：以M=1000K取代M=1024K的进位方式
			-i：不用磁盘容量，而以inode的数量来显示
	* du [选项] [目录或文件名]
		> 简介：
			默认情况如果是跟的目录，那么只会显示目录，以及目录下所有是目录的信息，不
			会显示文件类型的信息
			du命令不会考虑系统和进程占用的空间，只是计算纯文件占用的空间
		
			不仅可以查看一级目录还包括一级目录下的所有子目录及其所有子文件，而且还可以
			统计指定目录或文件的总大小，因为df所计算的包括系统占用进程占用资源等，所以
			同一个挂载点的统计大小du可能要小于df统计的数据
		> 命令选项：
			-a：显示所有子文件和子目录磁盘占用量。默认只统计子目录的磁盘占用量
			-h：使用习惯单位显示磁盘占用量，如KB、MB或GB等
			-s：统计总占用量，而不列出子目录和子文件的占用量
			-S：不包括子目录下的总计，与-s有点差别
			-k：以KBytes累出容量显示
			-m：以MBytes列出容量显示
			
	* 文件系统修复命令fsck
		> fsck [选项] 分区设备文件名
			>> 命令选项：
				-a：不用显示用户提示，自动修复文件系统
				-y：自动修复。和-a作用一致，不过有些文件系统只支持-y
				
	* 显示磁盘状态命令
		> 因为很多系统用ext4的文件系统所以无法查看
		> dumpe2fs [命令参数] 分区设备文件名
			命令参数：
				-b	# 列出保留为坏轨的部分
				-h	# 仅列出superblock的数据，不会列出其它的区段内容
				
	* 对于XFS文件系统的指令
		> xfs_info 挂载点|装置文件名	# 找出相应的superblock记录
		
			
	* lsblk [-dfimpt] [device]
		# 可以列出存储装置的情况
	
		命令选项：
			-d	# 仅仅列出磁盘本身，并不会列出该磁盘的分区数据
			-f	# 同时列出该磁盘内的文件系统名称
			-m	# 同时输出该装置在/dev低下的权限数据(rwx的数据)
			-i	# 使用ASCII的线段输出，不要使用复杂的编码(在某些环境下有用)
			-t	# 列出该磁盘装置的详细数据，包括磁盘队列机制、预读写的数据量大小等
			-P	# 列出该装置的完整文件名！而不是仅列出最后的名字而已
			
	* blkid [设备文件名]
		# 可以叫出目前系统有被格式化的装置情况

		
	* 列出磁盘的分区类型(是GPT还是mbr)
		parted decice_name print
		范例：parted /dev/vda print
			Model: Virtio Block Device (virtblk)		# 磁盘的模块名称(厂商)
			Disk /dev/vda 42.9GB						# 磁盘的总容量
			Sector size (logical/physical):512B/512B	# 磁盘的每个逻辑/物理山区容量
			Partition Table: gpt						# 分区表的格式(MBR/GPT)
			Disl Flags: pmbr_boot
			
			Number	Start	End		Size	File	system Name	Flags			
	
	* 查看分区详情，查看挂载详情
		# /proc/partitions 通过查看这个文件可以知道分区表信息
		# /etc/fstab 通过查看这个文件可以知道挂载信息
	
	* 注意！！如果在删除分区时，在删除之前应该先卸载那个分区(即取消挂载)，否则
		还可以写入数据，但是系统不会对其进行信息的记录)
		
	* gdisk分区(对于GPT格式的分区)
		gdisk 装置名称
		# 装置名称是对于硬盘的装置而非某个分区的装置，因为这个命令
			是针对于硬盘而言的
		.
		.
		.		
		此处省略一万字，操作步骤跟fdisk差不多
		
	* fdisk分区(对于mbr格式的分区)
		> 注意：
			>> 在linux未启动的情况下用虚拟机添加硬盘
			
		> 步骤：
			>> fdisk -l 
				# 查看目前的硬盘分区情况并且包含硬盘设备文件(只能查看分区情况，不能看到是否挂载)
				# 查询的结果：
					第一排：设备文件名对应的硬盘大小，大小转换成字节的大小
					第二排：磁头数，扇区个数，磁柱数
					.
					.
					.
			>> fdisk 装置文件名
			
				执行命令后的命令按键选项：
					a：设置可引导标记
					b：编辑bsd磁盘标签
					c：设置DOS操作系统兼容标记
					d：删除一个分区
					l：显示已知的文件系统leixing。32为Linux swap分区，83为Linux分区
					m：显示帮助菜单
					n：新建分区
					o：建立空白DOS分区表
					p：显示分区列表
					q：不保存退出
					s：新建空白SUN磁盘标签
					t：改变一个分区的系统ID
					u：改变显示记录单位
					v：验证分区表
					w：保存退出
					x：附加功能(仅专家)
				注意：在命令选项按键状态如果有输错命令应该 ctrl+退格键 才能删除
						错误命令安装过程会提示从哪个柱面开始，以及分区大小等等的
						提示，最后操作完毕后用 w 保存退出。如果有时提示分区表正
						在被使用要求重启系统生效，那么可以不重启用partprobe命令
						生效，这个指令会读取全部分区表
						
					
				重新读取分区表(避免重启才生效)
					partprobe [-s]		# 加上了-s可以得到加载的详细信息
			
			>> 分区范例：
				# 如果是一块新硬盘，按了n进行新建分区会出现如下的步骤
				1. 询问e还是p，e是extended(扩展分区),p是primary partition(1-4)即主分区
				2. 选择第几个柱面开始，默认是1
				3. 选择结尾的柱面，或者还可以以 +size{K,M,G}的方式分配大小，默认情况是
					根据柱面进行分区，可以选择根据大小分区
				4. 按w进行保存退出
				
			>> 格式化分区
				注意：可以格式化你刚才分区的分区，但是不能格式化扩展分区，，
					会出错，扩展分区不支持格式化
				
				范例1: mkfs.ext4 [-b size] [-L label] 装置名称
					命令选项：
						-b		# 设定block的大小，有1K，2K，4K的容量
						-L		# 后面接这个装置的标头名称
					
				范例2：mkfs -t ext4 /dev/sdb1	
					# 把对应的设备文件名指定的分区格式化为ext4格式
					# 如果需要则为之指定挂载目录
				
			>> 建立挂载点
				范例：
					1. mkdir /disk1 
					2. mount /dev/sdb1 /disk1/
				注意：
					用mount挂载后重启系统后挂载会失效，所以应该在/etc/fstab中
					进行设置自动挂载
					
	
	* 分配swap分区
		> 自动挂载及修复
			>> 修改：/etc/fstab # 在此文件中添加设备的挂载映射，因为系统启动的时
				候就是根据这个文件查找挂载的
				六个字段：
					第1字段：分区设备文件名或UUID(硬盘通用唯一识别码)
						如果用设备文件名因为系统内核改变的情况会变化，但是UUID是唯一
						不变的不用担心变化
					第2字段：挂载点
					第3字段：文件系统名称
					第4字段：挂载参数
					第5字段：指定分区是否被dump备份，0代表不备份，1代表每天备份，
						2代表不定期备份
					第6字段：指定分区是否被fsck检测，0代表不检测，其它数字代表检
						测得优先级，那么当然1的优先级比2高
						
			>> 相应硬盘分区的挂载点下有lost+found，用来进行硬盘分区备份
			>> mount -a 
				# 依据配置文件/etc/fstab的内容，自动重新挂载
				# 有时候在配置文件中修改了挂载可以执行这个命令先检测有没有错，没有
					错就可以依据配置文件的内容进行自动挂载
				
			>> 注意：如果此文件有误，那么系统重启会出错崩溃，但是会提示你继续重启
				或输入root密码进行修复此文件。用root身份编辑此文件无法保存，因为出
				错后此文件被挂载成了只读权限，所以要重新挂载 mount -o remount,rw /
				然后在修改此文件即可(此方法不适用与所有，只有一些不严重的错误)
			>> 注意2：因为能够提示你输入root密码进行文件修复是因为根分区是好的，如果根分
				区也出错，那么就彻底崩溃了
				
				
	* 磁盘格式化(建立文件系统)
		
		> mkfs.xfs [b size] [-b bsize] [-d parms] [-i parms] [-l parms] [-L label] [-f] \
				[-r parms] 装置名称
				
			命令选项：
				关于单位：底下只要谈到数值时，没有加单位则为bytes值，可以用
				k，m，g，t，p(小写)等来解释比较特殊的是s这个单位，它指的是
				sector的个数
				-b	# 后面接的是block容量，可由512到64k，不过最大容量限制为linux的4k
				-d	# 后面接的是重要的data section的相关参数值，主要有：
					agcount=数值:	# 设定需要几个存储群组的意思(AG)，荣昌与CPU有关
					agsize=数值:	# 每个AG设定为多少容量的意思，通常agcount/agsize只选一个设定即可
					file:			# 指的是格式化的装置是个文件而不是个装置(例如虚拟磁盘)
					size=数值:		# data section的容量，亦即你可以不将全部的装置容量用完的意思
					su=数值:		# 当有RAID时，哪个stripe数值的意思，与底下的sw搭配使用
					sw=数值:		# 当有RAID时，用于存储数据的磁盘数量(需扣除备份碟与备用碟)
					sunit=数值:		# 与su相当，不过单位使用的是几个sector(512byte大小)的意思。
					swidth=数值:	# 就是su*sw的数值，但是以几个sector(512byte大小)来设定
				-f	# 如果装置内已经有文件系统，则需要使用这个-f来强制格式化才行
				-i	# 与inode有较相关的设定，主要的设定值有：
					size=数值		# 最小是256bytes最大是2k，一般保留256就足够了
					internal=[0|1]	# log装置是否为内建？预设1内建，如果要用外部装置，使用底下设定
					logdev=device	# log装置为后面接的哪个装置上头的意思，需设定internal=0才可
					size=数值		# 指定这块登录区的容量，通常最小得要有512个block，大约2M以上才行
				-L	# 后面接这个文件系统的标头名称Label name的意思
				-r	# 指定realtime section 的相关设定值，常见的有：
					extsize=数值	# 就是哪个重要的extent数值，一般不须设定，但有RAID时
						最好设定与swidth的数值相同较佳，最小为4k最大为1G
						
		> mkfs.ext4 [-b size] [-L label] 装置名称
				# 格式化为ext4的传统Linux文件系统命令
				
				命令选项：
					-b	# 设定block大小，有1K，2K，4K的容量
					-L	# 后面接这个装置的标头名称
					
		> 其它文件系统mkfs
			mkfs [tab][tab]
			# 这是一个综合指令，当我们使用mkfs -t xfs 时它就会去找mkfs.xfs的相关
				参数给我们使用，如果要知道支持哪些文件系统的格式化功能可以输入mkfs
				然后连续按两下tab键
				
					
	* 挂载命令
	
		> mount -a # 依据配置文件/etc/fstab的内容，自动挂载，同时也可以在关机前
			根据这个命令看看修改后的 /etc/fstab 是否有异常，以免重启后挂掉
			
	
		> mount [-l] 
			# 不加-l是查询系统中已经挂载的设备，
				加-l会在不加-l的数据情况下显示卷标名称
				mount命令得到的Filesystem volumn name:就是卷标
				
		
		> 挂载命令格式
			>> mount [-t 文件系统] [-L 卷标名] [-o 特殊选项] 设备文件名 挂载点
				选项：
					-t：文件系统：加入文件系统类型来指定挂载的类型，可以ext3、
						ext4、iso9660、vfat(windows的FAT32)、fat(windows的FAT)
						等文件系统
					-L 卷标名：挂载指定卷标的分区，而不是安装设备文件名挂载
					-o 特殊选项：可以指定挂载的特殊选项
				特殊选项：
					atime/noatime：更新访问时间/不更新访问时间。访问分区文件时，
						是否更新文件的访问时间，默认为更新
					async/sync：异步/同步，默认为异步
					auto/noauto：自动/手动，mount -a命令执行时，是否会自动安装
						/etc/fstab文件内容挂载，默认为自动
					defaults：定义默认值，相当于rw,suid,dev,exec,auto,nouser,async
						这七个
					exec/noexec：执行/不执行，设定是否允许在文件系统中执行可执行文件
						默认是exec允许
					remount：重新挂载已经挂载的文件系统，一般用于指定修改特殊权限
					rw/ro：读写/制度，文件系统挂载时，是否具有读写权限，默认是rw
					suid/nosuid：具有/不具有SUID权限，设定文件系统是否具有SUID和SGID
						的权限，默认是具有
					user/nouser：允许/不允许普通用户挂载，设定文件系统是否允许普通用户
						挂载，默认是不允许，只有root可以挂载
					userquota：写入代表文件系统支持用户磁盘配额，默认不支持
					grpquota：写入代表文件系统支持组磁盘配额，默认不支持
				注意：如果中括号的一个都没写就默认
				范例：
					mount -o remount,noexec /home # 让/home目录下可执行文件不能执行
					mount -o remount,exec /home # 让/home目录下可执行文件可以执行

	
	* 挂载光盘和U盘
	
		> 挂载/卸载光盘	
			>> 挂载光盘方法
				1. 创建挂载点：mkdir /mnt/cdrom/
				2. 挂载光盘：mount -t iso9660 /dev/cdrom /mnt/cdrom/
				3. 或者：mount /dev/sr0 /mnt/cdrom/
					# 因为 /dev/cdrom 相当于是 /dev/sr0的软链接，因为是一个光驱，所以是sr0
						如果是多个光驱可能有变动，一切视当前的设备文件名情况而定，光盘的文
						件格式是系统默认的，所以不写就默认是光盘格式
						
			>> 卸载命令(这里指卸载挂载)
				1. umount 设备文件名或挂载点 # 注意如果当前目录在挂载点中会失败，应该退出当
					前的挂载目录
		
		> 挂载/卸载U盘
			>> 挂载：
				1. 注意：如果是在虚拟机中实验，需要鼠标状态在linux中，并且不是远程连接的操作
					然后在插入U盘，再进行一下操作
				2. fdisk -l # 查看U盘设备文件名(正常情况U盘的设备跟硬盘都是识别成sd)
				3. 创建挂载点：mkdir /mnt/usb/
				4. 挂载U盘：mount -t vfat /dev/sdb1 /mnt/usb/
					# 注意：Linux默认是不支持NTFS文件系统的，如果不将linux设置成支持NTFS格式
						则linux是看不到U盘文件内容的
			>> 卸载命令(这里指卸载挂载) # 跟光盘同理
		
	* 对NTFS文件的支持
		> 方法：
			>> 对内核新增硬件识别，重新编译内核
			>> 用第三方软件(http://www.tuxera.com/community/ntfs-3g-download/)
				步骤：
					1. tar -zxvf ntfs-3g_ntfsprogs-2013.1.13.tgz # 解压
					2. cd ntfs-3g_ntfsprogs-2013.1.13 # 进入解压目录
					3. ./configure # 编译器准备。没有指定安装目录，安装到默认位置中
					4. make # 编译
					5. make install # 编译安装
					6. mount -t ntfs-3g 分区设备文件名 挂载点 # 挂载U盘
	

				
** SHELL

	* 简介：
		Shell是解释执行的脚本语言，还是一个功能强大的编程语言。
		
	* 查看当前Linux支持的shell
		ls /etc/shells/
		
		# 较常用的sh:
			1. /bin/sh(已经被 /bin/bash 所取代)
			2. /bin/bash(就是 Linux 预设的shell)
			3. /bin/tcsh(整合 C Shell 提供更多的功能)
			4. /bin/csh(已经被 /bin/tcsh 所取代)
		
	* cd和umask都是属于bash内置指令的范畴

	* 系统定义的环境变量通常用全大写来定义
	
	* 脚本检查命令
		sh [-nvx] 脚本路径名
			命令选项：
				-n：不执行脚本，仅仅检查语法的问题
				-v：在执行脚本前，先将脚本内容输出到屏幕上(全部内容，包括头信息)
				-x：在执行脚本钱，先将使用到的脚本内容显示到屏幕上，这是很常用的参数(只输出执行体文本)
		
	* 查看相应的命令是否属于bash内置命令
	
		> type [-tpa] 指令
			# 不加任何选项与参数时，type会显示出指令是属于外部指令还是bash内置指令
			命令选项：
				-t：当加入-t 参数时，type会将name以底下这些字眼显示出它的意义
					file：表示为外部指令
					alias：表示该指令为命令别名所设定的名称
					builtin：表示该指令为bash内建的指令功能
				-p：如果后面接的指令未外部指令时，才会显示完整文件名
				-a：会由PATH变量定义的路径中，将所有含有指定指令名字的指令都列出来，
					包含alias
					
	* 学前基础
		> echo [选项] [输出内容]
			选项：
				-e：支持反斜线控制的字符转换
			范例：
				echo kkk(如果输出内容有空格则应该包含在双引号内，例如：echo "a b")
			
			高级：
				格式：
					echo ${变量名#|##|%|%%规定格式字符串}
					echo ${变量名/|//旧字符串/新字符串}	
			
				name="abcd:efgh:ijkl:mnop:qrst:uvwx:yz"
				echo ${name#*:} --> efgh:ijkl:mnop:qrst:uvwx:yz
				echo ${name##*:} --> yz
				echo ${name%:*} --> abcd:efgh:ijkl:mnop:qrst:uvwx
				echo ${name%%:*} --> abcd:
				echo ${name/旧字符/新字符} --> 从左至右遇到的第一个旧字符被替换成新字符
				echo ${name//旧字符/新字符} --> 从左至右所有旧字符替换成新字符
				
				总结：
					#：表示字符串从左至右删除形式最短的规定格式字符串
					##：表示字符串从左至右删除形式最长的规定格式字符串
					%：表示字符串从右至左删除形式最短的规定格式字符串
					%%：表示字符串从右至左删除形式最长的规定格式字符串
					/：表示字符串从左至右替换第一个遇到的旧字符串
					//：表示字符串替换所有的旧字符串
					
		> echo ${变量-指定字符}		# 如果变量没有定义，则输出指定字符，否则输出本身的值
		> echo ${变量:-指定字符}	# 如果变量没定义或为空空字符串，则输出指定字符，否则输出本身的值
		
		> 系列转义符：
			\\：	# 输出\本身
			\a：	# 输出警告音
			\b：	# 退格键，也就是光标向左移一个字符
			\c：	# 取消输出行末的换行符。和“-n”选项一致
			\e：	# ESCAPE键
			\f：	# 换页符
			\n：	# 换行符
			\r：	# 回车键
			\t：	# 制表符，也就是Tab键
			\v：	# 垂直制表符
			\0nnn： # 按照八进制ASCII码表输出字符。其中0为数字零，nnn是三位八进制数
			\xhh：	# 按照十六进制ASCII嘛表输出字符。其中hh是两位十六进制数
		> 颜色输出：
			echo -e "\e[1;31m abcd \e[0m" # 输出了红色的 abcd
				# 30m=黑色，31m=红色，32m=绿色，33m=黄色
				# 34m=蓝色，35m=洋红，36m=青色，37m=白色
		> 注意：
			>> 在centOS中双引号中不能带“!”，要有感叹号需要包含在单引号中
				否则感叹号会被当做其它指令形式表示而不是字符串
			>> 在用windows写的.sh脚本和Linux里写的.sh脚本内容某些可能会不
				同，那么需要转换，用dos2unix 文件名,反向转换用unix2dos 文件名
	* 第一个脚本
		> 写一个以.sh结尾的文件
			# 用.sh结尾表名是脚本，但是注意Linux没有扩展名，之所以加上是为了方便区分
		> 内容如下：
			#!/bin/bash
			# 程序名或程序简介
			# Author:作者 (E-mail:邮箱地址)
			. 内容
			. 内容
			. 内容
		> 第一行不是注释，表示一下语句是shell语句，如果不写也暂时不影响，但是如果这个
			文件嵌入了其它编程语句，并且其它语句没有注明是所属的什么类型的语句，那么
			就会出错，所以在原则上这句话必须加上。
		> 执行方法：
			方案1. 
				>> 赋予脚本执行权限
				>> 在命令行输入 相对路径或绝对路径(注意相对路径如果当前目录是跟
					脚本的路径一致，不能直接输入脚本名，应该输入 ./脚本名
			方案2. 
				>> bash 路径
				>> 此方法不需要赋予执行权限
				
	* Bash基本命令/基础
	
		> 执行shell脚本
			在执行时会默认创建一个子bash线程执行，所以脚本里的变量在外部bash是没
			有的，如果用当前所在bash环境执行应该是 source 脚本路径名
			
		> 查看历史命令
			>> history # 查询历史命令
			>> history [选项] [历史命令保存文件] # 清空或写入历史命令
				命令选项：
					-c：清空历史命令
					-w：把缓存中的历史命令写入历史命令保存文件中
					-n：列出行号
					-r：将histfiles的内容读到目前这个shell的history记忆中
					-a：将目前新增的history指令新增histfiles中，若没有
						histfiles则预设写入~/.bash_history
			>> 注意：
				1. 默认缓存中的历史命令要在正常退出后才能自动写入文件
				2. 默认历史命令在 ~/.bash_history中，~是家目录的表示
				3. 历史命令默认保存1000条，可以在/etc/profile文件中修改
					修改后要重新登录后生效
				4. 历史命令调用
					4_0. 使用上、下箭头调用以前的历史命令
					4_1. 使用“!n”重复执行第n条历史命令
					4_2. 使用“!!”重复执行上一条命令
					4_3. 使用“!字符串”重复执行最后一条以该字符串开头的命令
					
		> 基本运用
			>> 查询/设定别名
				1. alias 
					# 可以查看当前支持的别名
					# 别名就是为某个命令用于一个别名代替，到时候输入别名相当于执行指定的命令)
					# 注意：不要用别名覆盖其它同名的命令
				2. alias 别名='命令' # 为命令指定别名
			>> unalias 别名 # 删除别名
			>> 永久生效
				编辑 ~/.bashrc
				# 按照格式编辑别名
			>> 命令执行时顺序
				1. 第一顺位执行用绝对路径或相对路径执行的命令
				2. 第二顺位执行别名
				3. 第三顺位执行Bash的内部命令
				4. 第四顺位执行按照$PATH环境变量定义的目录查找顺序找到的第一个命令
		
		> 重定向输入/输出
			>> 基本概况
				设备	设备文件名	文件描述符	类型
				键盘 	/dev/stdin		0		标准输入
				显示器 	/dev/sdtout		1		标准输出
				显示器 	/dev/sdterr		2		标准错误输出
			>> 输出重定向
				>> 标准输出重定向
					1. 命令 > 文件 
						# 以覆盖的方式吧命令的正确输出输出到指定文件或设备中
					2. 命令 >> 文件 
						# 以追加的方式吧命令的正确输出输出到指定的文件或设备中
					3. cat >> 文件
						# cat是查看文件内容，这里是指查看的内容追加到文件中，
							但是这里的指令形式是让你输入一些内容然后追加到文
							件中，在输入的过程中只要按ctrl+d就可以结束输入
						
				>> 标准错误输出重定向
					1. 错误命令 2> 文件
						# 以覆盖的方式，把命令的错误输出输出到指定的文件或设备当中
					2. 错误命令 2>> 文件
						# 以追加的方式，把命令的错误输出输出到指定的文件或设备当中
						
				>> 正确输出和错误输出同时保存
				
					1. 命令 > 文件 2>&1
						# 以覆盖的方式，把正确输出和错误输出都保存到同一个文件中
						
					1_0. 命令 >> 文件 2>&1
						# 以追加的方式，把正确输出和错误输出都保存到同一个文件中
						
					2. 命令 &> 文件
						# 以覆盖的方式，把正确输出和错误输出都保存到同一个文件中(作用与 1 相同)
						
					2_0. 命令 &>> 文件
						# 以追加的方式，把正确输出和错误输出都保存到同一个文件中(作用于 1_0 相同)
						
					3. 命令 >> 文件1 2>> 文件2
						# 把中缺的输出追加到文件1中，把错误的输出追加到文件2中，在这里相应的“>>”
							改为“>”表示覆盖，相应的“2>>”改为“2>”表示覆盖
							
					4. /dev/null		# 可以把信息传入这里面，等于直接丢掉，这个相当于信息黑洞
						对于没有用的信息全部放在这里面就可以丢掉
						
			>> 输入重定向
				1. cat > 文件A < 文件B
					# 可以理解为文件B的内容作为 “cat >” 的要求输入的内容替代作为文件A的内容
			
				2. cat > 文件A << "eof"
					# 可以理解为把您在键盘的输入内容作为 “cat >” 的要求输入的内容替代作为文件A的
						内容，只是这里 “<<” 作为遇到“eof”的符号表达则自动停止输入，只要在结束的
						时候输入 eof 的字符再按回车即可，“eof”不会录入文档内，只是作为结束符，并
						且也省去了ctrl+d的组合键
						
				3. wc [选项] [文件名]
					命令选项：
						-l：统计行数
						-w：统计单词数
						-c：统计字符
						
					# 如果直接wc命令，会有输入界面，输入完毕后按ctrl+D可以统计你
						输入的 行数， 单词书， 字节数
				
				3. 范例：
					wc [选项] < 文件

		> 多命令顺序执行与管道符
			>> 多命令执行符
				;： # 命令1; 命令2	多个命令顺序执行，之间无逻辑关系，之前的错误了
					之后的也会执行
				&&： # 命令1 && 命令2 # 命令1执行正确，则执行命令2，不正确则不执行
					命令2
				||： # 命令1 || 命令2 # 命令1执行正确，则不执行命令2，不正确则执行
					命令2
			>> 磁盘复制
				1. 不仅能够复制，并且能够复制磁盘性质的系列系统性质文件
				2. dd if=输入文件 of=输出文件 [bs=字节数 count=个数]
					if=输入文件 # 指定源文件或设备
					of=输出文件 # 指定目标文件或目标设备
					bs=字节数	# 指定一次输入/输出多少字节，即把这些字节看做一个
						数据块
					count=个数	# 指定输入/输出多少个数据块
				
				
			>> 管道符
				1. 命令1 | 命令2 # 命令1的正确输出作为命令2的操作对象
				2. 范例：ls -ilh test.txt | more
				
		> 通配符与其他特殊符号	
			>> 通配符：
				?：匹配一个任意字符
				*：匹配0个或任意多个任意字符，也就是可以可以匹配任何内容 
				[字符]：匹配中括号中任意一个字符。例如：[abc]代表一定匹配一个
					字符，这个字符可以是a、b、c中的任意一个
				[-]：匹配中括号中任意一个字符，-代表一个范围。例如：[a-z]
					表示匹配一个字符，这个字符必须是a到z的任意一个
				[^]：逻辑非，表示匹配不是中括号内的一个字符。例如：[^0-9]
					代表匹配一个不是从0到9字符的字符
			>> 其它特殊符号：
				''：在单引号中所有的特殊符号都没有特殊含义，包括“$”、“`”
					“(反引号)”
				""：在上引号中特殊符号都没有特殊含义，但是“$”、“`”和“\”是
					例外，拥有调用变量的值，引用命令和转义符的特殊含义
				``：反引号，反引号括起来的内容是系统命令，在Bash中会先执行
					它，和$()作用一样，不过推荐使用$()，因为反引号非常容易
					看错
				$()：和反引号作用一样，用来引用系统命令(通常用于命令的结果
					作为变量赋值用)
				#：在Shell脚本中，#开头的行代表注释
				$：用于调用变量的值，如需要调用变量name的值，需要用$name的
					方式得到变量的值
				\：转义符，跟在\之后的特殊符号将失去特殊含义，变为普通字符
					如\$将输出“$”符号，而不当做是变量引用
		> 变量
			>> 简介：
				1. 变量必须字母、数字、下划线组成，但是不能用数字开头
				2. Bash中变量类型默认是字符串型，如果要制定其它类型需
					要修改指定变量
				3. 变量用等号连接，等号两侧不能有空格(否则会用空格区分了两个值
				4. 变量的值如果有空格，需要用双引号包括起来
				5. 变量值可以使用转义符
				6. 可以进行变量值叠加，不过变量需要用双引号包含"$变量名"或用
					${变量名}包含
				7. 可以把命令的结果作为变量值赋予变量，则需要使用反引号或$()包
					含命令
				8. 环境变量名建议大写，便于区分
				9. pstree # 查看进程数
				10. set # 所有变量查看
			>> 变量分类
				1. 用户自定义变量(可以随便增删改)
				2. 环境变量(可以增加，删除自己定义的，系统赋予的变量只能改)：
					这种变量中主要保存的是和操作系统环境相关的数据
				3. 位置参数变量(只能改系统赋予的变量)：
					主要用于向脚本中传递参数或数据的，变量名不能自定义，变量作
					用是固定的(位置参数变量根本上是预定义变量的一种，只是因为
					变量太多所以独立出来)
				4. 预定义变量(只能改系统赋予的变量)：
					是Bash中一定定义好的变量，变量名不能自定义，变量作用也是固
					定的
			>> 本地变量
				# 简介：只对当前shell环境有效
				# 范例：
					aa=123 # echo aa ---> 123
					aa="$aa"456 # echo aa ---> 123456
					aa=${aa}789 # echo aa ---> 123456789
				# 变量查看/删除
					1. unset 变量名 # 删除对应变量
			>> 环境变量
				# 简介：对当前shell以及当前环境的子环境shell有效
				# export 变量名=变量值 	# 为环境变量申请值
				# export 变量名 		# 把此变量变为环境变量
				# env 					# 查询环境变量，查看环境变量的专用命令
				# unset 变量名 			# 删除变量
				# set					# 查询所有变量
				
				# 范围由小到大是 env --> export --> set
				# env是默认配置文件的环境变量信息，export是所有环境变量信息，
					set是设定的所有变量信息
				
				# echo $-			# 显示set的所有设定，bash预设是himBH
					
			>> set [-uvCHhmBx]
				命令选项：
					-u				# 预设不启用，若启用后，当使用未设定变量时会显示错误信息
					-v				# 预设不启用，若启用后，在讯息被输出前，会先显示讯息的原始内容
					-x				# 预设不启用，若启用后，在指令被执行前，会显示指令内容(前面有++符号)
					-h				# 预设启用，与历史命令有关
					-H				# 预设启用，与历史命令有关
					-m				# 预设启用，与工作管理有关
					-B				# 预设启用，与[]的作用有关
					-C				# 预设不启用，若使用>等，则若文件存在时，该文件不会被覆盖
				
				主要两个环境变量：
					1. PATH
						用 “:” 分隔的路径，用于在指定路径找查找命令
					2. PS1 定义系统提示符的变量
						\@：显示当前时间，并且还显示上午或下午
						\d：显示日期，格式为“星期 月 日”
						\h：显示简写主机名。如默认主机名“localhost”
						\t：显示24小时制时间，格式为“HH:MM:SS”
						\T：显示12小时制时间，格式为“HH:MM:SS”
						\A：显示24小时制时间，格式为“HH:MM”
						\u：显示当前用户名
						\w：显示当前所在目录的完整名称
						\W：显示当前所在目录的最后一个目录
						\#：执行的第几个命令
						\$：提示符。如果是root用户会显示提示符为“#”，如果是
							普通用户会显示提示符为“$”
						范例：PS1='[\u@\h \W]\$ '
						
			>> 位置参数变量
				1. $n：n为数字，$0代表命令本身，$1-$9代表第一道第九个参数，十
					以上的参数需要用大括号包含，如${10}
				2. $*：这个变量代表命令行中所有的参数，$*把所有的参数看成一个
					整体]
				4. $@：这个变量也代表命令行中所有的参数，不过$@把每个参数区分
					对待
				5. $#：这个变量代表命令行中所有参数的个数(不包含命令本身)
				
				# 范例：
					写一个脚本，内容为 echo $0 echo $1 echo $2 此时如果没有为
					变量赋值，则执行脚本会显示：路径/脚本名	如果echo $0 echo 
					$1=1 echo $2=2，那么执行：脚本 参数1 参数2 参数3 会显示：
					路径/脚本名 参数1 参数2 参数3
					# $0 为执行此脚本的命令
					
			>> 预定义变量：
				1. $?：最后一次执行命令的返回状态，如果这个变量值为0，证明上一
					个命令正确执行；如果这个变量为非零(具体视哪个数，由命令自己
					决定)，则证明上一个命令执行失败
				2. $$：当前进程的进程号(PID)
				3. $!：后台运行的最后一个进程的进程号(PID)
				
				4. 接收键盘输入
					read [选项] [变量名]
						命令选项：
							-p 提示信息：在等待read输入时，输出提示信息
							-t 秒数：read命令会一直等待用户输入，使用此选项可以
								指定等待时间
							-n 字符数：read命令只接收指定的字符数，就会执行(如果
								不加-n则只有回车才表示输入完毕)
							-s：隐藏输入的数据，适用于机密信息的输入
							
			# 注意：以上的操作重启计算机会失效；如果把变量写在相应的配置文件中，
				则对本台计算机的所有shell环境有效，重启才不失效
		> 随机数
			$(RANDOM)		# 会产生[0,32767)的整数
		> 数组
			>> 格式：
				数组名=(元素1 元素2 元素3 ...)	# 数组名和变量名的定义规则一样
				
			>> 获取元素：
				1. ${数组名[元素索引]}	# 元素索引从 0 开始一直到 元素个数-1
				2. 获取全部元素：${数组名[@]} 或者 ${数组名[*]}
				3. 获取元素个数：
					${#数组名[@]} 或者 ${#数组名[*]}
					
		> 函数
			>> 声明：
				[function] 函数名() {
					函数体...
				}
				
				# 函数要在脚本内容之前声明
			>> 调用：
				1. 无参调用：函数名
				2. 有参数调用：函数名 参数1 参数2 参数3 ...
				
			>> 函数返回值：
				如果没有定义“return”那么函数默认以函数内容最后一条命令运行结果
					作为返回参数；如果有自定义返回值那么返回值应该设定为0~255
					范围的值
					
		> 运算符
			>> 数值及其运算
				1. declare [+/-][选项] 变量名
					加减选项：
						-：给变量设定类型属性
						+：取消变量的类型属性
						---------------------------------------------> 什么叫取消变量的类型属性
					命令选项：
						a：将后面定义的变量定义为数组类型
						i：将变量声明为整数型(integer)
						x：将变量声明为环境变量
						r：将变量设定成为readonly类型，该变量不可被修改，
							也不能被unset
						p：显示指定变量的被声明的类型(declare -p 变量名)
						
						# 注意：r 和 i 的类型不能用+取消
				2. 范例：
					aa=11;bb=22
					declare -i cc=$aa+$bb # 把运算的变量声明为数值型
					echo $cc # 输出33
				2_1. 范例：
					aa=11;bb=22
					dd=$(expr $aa + $bb) 
						# dd的值是aa和bb的和，注意“+”左右
						# 两侧必须有空格
					echo $cc # 输出33
				2_2. 范例(推荐用此方法)：
					aa=11;bb=22
					dd=$(($aa+$bb)) 或者 dd=$[$aa+$bb] 
						# 注意“+”两侧没有空格
						# $(()) 当乐符双括号表示数值运算
					echo cc # 输出33
					
			>> 运算符
				优先级	运算符				说明
				13		-，+				单目负，单目正
				12		!，~				逻辑非、按位取反或补码
				11		*，/，%				乘、除、取模
				10		+，-				加、减
				9		<<，>>				按位左移，按位右移
				8		<=，>=，<，>		小于或等于、大于或等于、小于、大于
				7		==，!=				等于、不等于
				6		&					按位与
				5		^					按位异或
				4		|					按位或
				3		&&					逻辑与
				2		||					逻辑或
				1		=，+=，-=，*=，		赋值、运算且赋值
						/=，%=，&=，^=，
						^=，|=，<<=，>>=
				
		> 变量测试与内容替换
			>> 通过变量x的值判断变量y的情况(即y变量是否存在，如存在值的情况)
			
				变量置换方式	变量y没有设置	变量y为空值		变量y设置值
				x=${y-新值}		x=新值			x为空			x=$y
				x=${y:-新值}	x=新值			x=新值			x=$y
				x=${y+新值}		x为空			x=新值			x=新值
				x=${y:+新值}	x为空			x为空			x=新值
				
				x=${y=新值}		x=新值			x为空			x=$y
								y=新值			y值不变			y值不变
								
				x=${y:=新值}	x=新值			x=新值			x=$y
								y=新值			y=新值			y值不变
								
				x=${y?新值}		新值输出到标准	x为空			x=$y
								错误输出(就是
								屏幕)
								
				x=${y:?新值}	新值输出到标准	新值输出到标准	x=$y
								错误输出		错误输出
								
		> 环境变量配置文件
			>> source 配置文件 或 .配置文件 
				# 强制当前配置文件生效，否则只有重启生效
			
			>> 环境变量配置文件中主要是定义对系统的操作环境生效的系统默认
				环境变量，比如PATH、HISTSIZE、PS1、HOSTNAME等
				
			>> 常见的一些环境变量配置文件
				1. /etc/profile
				2. /etc/profile.d/*.sh 
					# 这里的*通配符表示是以.sh结尾的所有脚本
				3. ~/.bash_profile
				4. ~/.bashrc
				5. /etc/bashrc
			>> 流程图
				/etc/profile --> ~/.bash_profile --> ~/.bashrc --> /etc/bashrc --> 命令提示符
				|													|
				v													|
				/etc/profile.d/*.sh <-------------------------------~				
				|
				v
				/etc/profile.d/lang.sh ---> /etc/sysc config/i18n
				
				1. /etc/profile的作用
					USER变量
					LOGNAME变量：
					MAIL变量：
					PATH变量：
					HOSTNAME变量：
					HISTSIZE变量：
					umask：
					调用/etc/profile.d/*.sh文件
					
		> 其它配置文件和登录信息
			>> ~/.bash_logout # 注销时要执行的，默认为空
			>> ~/bash_history # 历史命令的保存
			>> /etc/issue # 本地终端欢迎信息
				\d：显示当前系统日期
				\s：显示操作系统名称
				\l：显示登录的终端号，这个比较常用
				\m：显示硬件体系结构，例如：i386、i686等
				\n：显示主机名
				\o：显示域名
				\r：显示内核版本
				\t：显示当前系统时间
				\u：显示当前登录用户的序列号
			>> /etc/issue.net # 远程终端欢迎信息，以上的转义符不适用，
				只能用纯文本，是由ssh的配置文件/etc/ssh/sshd_config决
				定，加入“Banner/etc/issue.net”行才能显示(记得重启SSH服务)
			>> /etc/motd # 本地登录，远程登录，都可以显示此欢迎信息，以上
				两个登录是登录前信息，这个是登录后信息
				
	* Shell编程
		> 正则表达式
		
			>> 正则表达式用来在文件中匹配符合条件的字符串，正则是包含匹配
				grep、awk、sed等命令支持正则表达式
				
			>> 通配符用来匹配符合条件的文件名，通配符是完全匹配
				ls、find、cp这些命令不支持正则表达式，所以只能使用
				shell自己的通配符来进行匹配了
				
			>> 元字符：
				*：前一个字符匹配0次或更多次
				.：匹配除了换行符外任意一个字符
				^：匹配行首，例如：^hello会匹配以hello开头的行
				$：匹配行尾，例如：hello$会匹配以hello结尾的行
				[]：匹配中括号中指定的任意一个字符，只匹配一个字符，例如：
					[aoeiu]匹配任意一个元音字母，[0-9]匹配任意一位数字，
					[a-z][0-9]匹配小写字和一位数字构成的两位字符
				[^]：匹配除中括号的字符以外的任意一个字符，例如[^0-9]匹配
					任意一位非数字字符，[^a-z]匹配任意一位非小写字母
				\：转义符，用于取消，将特殊符号的含义取消
				\{n\}：表示前面的字符恰好出现n次，例如：[0-9]\{4\}匹配4位数
					字，[1][3-8][0-9]\{9\}匹配手机号
				\{n,\}：表示其前面的字符出现不小于n此，例如：[0-9]\{2,\}表示
					两位及两位以上的数字
				\{n,m\}：表示前面的字符至少出现n此，最多出现m次，例如：
					[a-z]\{6,8\}表示6到8位的小写字母
					
			>> grep命令是从文件中截取符合条件的行
			
		> 字符串截取
		
			>> cut [选项] 文件名	# 用于截取列数据
				命令选项：
					-f 列号：提取第几列，如果提取多列则用“,”分隔
					-d 分隔符：
						# 按照指定分隔符分开列，默认是用\t制表符来区分列的，即
							列与列之间用\t制表符间隔的，注意默认是一个\t的制表
							符可以自定义以什么为列间隔标准的解析
						# 最好不要用空格作为间隔符，因为不同机器的同一个文件也
							许空格数不同，并且空格不是理想的间隔符
					-c 字符区间		# 以字符的单位去处固定字符区间
							范例：cut -c 3 filename		# 取第三个字符
							
				# 注意，用“,”隔开表示去相应的列，使用了“-”表示范围
				
				范例：cut -d ":" -f 2,3 ~/test.txt	# 表示输出第二行和第三行
				范例：cut -d ":" -f 1- ~/test.txt	# 表示输出第一到最后一行
				范例：cut -d ":" -f 1-3 ~/test.txt	# 表示输出第一到第三行
				
			>> printf '输出类型输出格式' 输出内容
				# 单引号可以改为双引号，并且如果不用引号把输出类型和输出格式包含
					起来，则可能产生歧义，不加引号的情况，在多个输出类型或格式间
					有空格分隔，那么它只认第一个输出类型或格式，其它当做输出内容
				
				命令选项：
					%ns：输出字符串。n是数字指代输出几个字符
					%ni：输出整数。n是数字指代输出几个数字
					%m.nf：输出浮点数。m和n是数字，指代输出的整数位数和小数位数
						如%8.2f代表共输出8位数，其中2位是小数，6位是整数
						
				输出格式：
					\a：输出警告声音
					\b：输出退格键，也就是Backspace键
					\f：清除屏幕
					\n：换行
					\r：回车，也就是Enter键
					\t：水平输出退格键，也就是Tab键
					\v：垂直输出退格键，也就是Tab键
				
				范例：
					1. printf %s 1 2 3 4 5 6 输出 123456 
						# 将6个数据当成了整体
					2. printf %s %s %s 1 2 3 4 5 6 输出 %s%s123456 
						# 第一个 %s 生效
					3. printf '%s %s %s' 1 2 3 4 5 6 输出 1 2 34 5 6
					4. printf '%s %s %s\n' 1 2 3 4 5 6 输出 1 2 3
															4 5 6
					# 注意：以上的1 2 3 4 5 6是六个输出内容，输出内容用空格隔开了
						如果输出内容有空格则应该用双引号包含，因为是6个输出内容，
						所以应该用6个 %s 的输出格式，如果只写了三个 %s 则认为这六
						个输出内容三个输出内容组成为一个输出内容，所以共连个输出内
						容
				注意：
					1. printf 不能用 | 的形式输出 例如：cat test.txt | printf '%s'
						可以用：printf '%s' $(cat test.txt)
					2. awk命令的输出中支持print和printf命令
						print：print 会在每个输出之后自动加入一个换行符(Linux默认没有
							print命令)
						printf：printf 是标准格式输出命令，并不会自动加入换行符，如果
							需要换行，需要手工加入换行符
			>> awk '条件1{动作1} 条件2{动作2}...' 文件名
				# awk命令默认对列的分隔符是空格，多个空格或\t连在一起则总的且连续的当
					做一个空格，不管全是空格或全是\t制表符还是\t制表符和空格的混搭都
					作为一个空格
				# 条件1符合才有条件2的判断，依此类推
				# 它的原理是先读入一行，然后一行分为几个字段，然后在以条件执行动
					作，接着读入第二行依次类推
				# 注意对于非变量的字符串或字符应该用双引号扩起来
				
				其它：
					$0：代表当前这一整行
					NF：当前行拥有的字段总数
					NR：目前awk所处理的是第几行数据
					FS：目前的分隔符，默认是空格或tab
				
				条件：
					# 一般使用关系表达式作为条件
					BEGIN：在所有数据读取之前，有BEGIN的条件则在所欲数据读取钱执行
						指定的动作
					END：在所有数据执行完毕后，在执行END指定的动作
					x==10：x等于10的数据
					x>10： x大于10的数据
					x>=10： x大于等于10的数据
					x<=10 ：x小于等于10的数据
					
				动作：
					格式化输出
					流程控制语句
					FS内置变量：在动作标签里写FS=":"可以用“:”当做列的分隔符，也可指
						定其它
					
					
				范例：
					1. awk '{printf $2"\t"$6"\n"' student.txt	
						# 输出第二和第六列
					2. df -h | awk '{print $1 "\t" $3}'	
						# 输出分区结果的第一和第三列，并且awk中支持print
					3. awk 'BEGIN{FS=":"} {printf $2"\t"$6}' student.txt
						# 输出第二和第六列，并且在数据读入前设置“:”为列分隔符
			
			>> sed 命令
				# 简介：此命令主要是一种就包含在所有unix平台(包括Linux)的轻量级流编辑
					器。sed主要是用来将数据进行选取、替换、删除、新增的命令。它是读取
					一行处理后然后在读取处理下一行依次类推
				sed [选项] ['动作'] 文件名
					命令选项：
						-n：一般sed命令会把所有数据都输出到屏幕，如果加入此选择，则只
							会把经过sed命令处理的行输出到屏幕
						-e：允许对输入数据应用多条sed命令编辑
						-i：用sed的修改结果直接修改读取数据的文件，而不是由屏幕输出
						
						# 如果有多个命令选项则应该是分别都有“-”的符号，而不是全部用一个
							“-”符号，例如：sed -e -n '2p ; 1i kkk' test.txt 而不是
							sed -en '2p ; li kkk' test.txt
					动作：
						a：追加，在当前行后添加一行或多行。添加多行时，除最后一行外，
							每行末尾需要用“\”代表数据未完结
						c：行替换，用c后面的字符串替换原数据行，替换多行时，除最后一
							行外，每行末尾需用“\”代表数据未完结
						i：插入，在当前行插入一行或多行，插入多行时，除最后一行外，每
							行末尾需要用“\”代表数据未完结
						d：删除，删除指定的行
						p：打印，输出指定的行
						s：字符串替换，用一个字符串替换另外一个字符串。格式为
							“行范围s/旧字符串/新字符串/g”(和vim中的替换格式类似)
					
						# 注意：除了s动作，其它几个都是对于行的操作
					范例：
						1. sed '2p' student.txt		# 输出整个文档，并且第二行输出了两遍
						2. sed -n '2p' student		# 输出第二行
						3. df -h | sed -n '2p'		# 输出了分区信息的第二行
						4. sed '2,4d' student.txt	# 输出删除了第二到第四行后的数据
						5. sed '2a kankan' student.txt	# 在第二行后追加了kankan
						6. sed '2c kankan jj' student.txt	
							# 把第二行整行替换为kankan jj
						7. sed -e 's/Liming/lm/g ; s/Gao/gao/g' student.txt
							# 这条命令有两个sed命令，一个是把全文的Liming替换成lm
								还有一个是把全文的Gao替换成gao
						8. sed '2i kkk\
								jjj' student.txt
							# 在第二行之前插入两行，一行是“kkk”，一行是“jjj”
			
			
			>> 字符处理命令
			
				1. sort [选项] 文件名
					命令选项：
						-f：忽略大小写
						-b：忽略最前面的空格符部分
						-M：以月份的名字来排序，列入JAN,DEC等等的方法
						-n：以数值型进行排序，默认使用字符串型排序
						-r：反向排序
						-u：就是uniq，相同的数据中，仅出现一行代表
						-t：指定分隔符，默认是分隔符是制表符
						-k n[,m]：按照指定的列字段范围排序，
							从第n字段开始，m字段结束(默认到行尾)
					
					范例：
						# 注意：假如-k 1,1 进行排序，而恰好有两行数据的第一列各是10和2
							排序也会把10行排在2的前面，因为sort命令是把它当做字符串对待
							的，10和2比较第一个字符，如果要解决这个问题则加上 -n
						1. sort -t ":" -k 3,3 /etc/passwd
							# 指定分隔符是“:”，用第三字段开头，第三字段结尾排序，就是
								只用第三个字段排序
				
				2. wc [选项] 文件名
					命令选项：
						-l：只统计行数
						-w：只统计单词数
						-c：只统计字符数
					# 不加命令选项就默认显示 行数 单词数 字符数
					
				3. uniq [-ic]
					命令选项：
						-i：忽略大小写字符的不同
						-c：进行计数
						
				4. diff [-bBi] from-file to-file
					# 这个命令是将两个文件的内容向同行进行比较(同时这两个文件也可以用
						- 替代，表示standard input的意思
					命令选项：
						-b：忽略一行当中，仅有多个空白的差异(例如"about me"与"about	me"一样
						-B：忽略空白行的差异
						-i：忽略大小写的不同
					
				5. cmp [-l] file1 file2
					# 这个命令是用字节来判断两个文件的差异
					命令选项：
						-l 将所有不同的字节都列出来，因为它预设会输出找到的第一
							个不同点
						
				6. tee [-a] 文件名			# 不仅能够将stdout流输入到某个文件，
												还能够继续处理流
					命令选项：
						-a：以累加的形式加入
					# 范例：ls -ilhnrRStF | tee -a tee.txt | more
					# 作用是不仅将结果输入到tee.txt中还能够在命令行中用more形式查阅
					
				7. tr [-ds] SET1 ...
					命令选项：
						-d	# 删除讯息当中的SET1这个字符串，如果有多个则用空格隔开
						-s	# 取代掉重复的字符
					
					# 说明：
						得通过管道符操作，并且设定是正规表达式处理
					# 范例：
						last | tr '[a-z]' '[A-Z]'		# 将所有小写转为大写
						last | tr -d ":"				# 删除所有的冒号
					
				8. col [-xb]
					命令选项：
						-x	# 将tab键转换成对等的空格键
						
				9. join [-til2] file1 file2		# 通过两个文件的字段对比，如果相同
					则连在一起，如果不相同则不连在一起
					命令选项：
						-t	# join默认以空格符分隔数据，并且比对第一字段的数据如
								果两个文件相同，则将两笔数据联成一行，且第一个字
								段放在第一个
						-i	# 忽略大小写的差异
						-1 数字	# 这个是数字的1，代表第一个文件要用哪个字段来分析的意思
						-2 数字	# 代表第二个文件要用哪个字段来分析的意思
				
				10. paste [-d] file1 file2	# 直接把同一行的连在一起，可以间隔的符号
					命令选项：
						-d	# 后面可以接分隔字字符，预设是以[tab]来分隔的
						-	# 如果file部分写成-，表示来自standard input的资料的意思
						
				11. expand [-t] file			# 将一个[tab]替换成指定数量的空格
					命令选项：
						-t	# 后面可以接数字，一般来说，一个[tab]键可以用8个空格
								取代，我们也可以自定义一个[tab]按键代表多个字符
								
				12. xargs [-0epn] command
					# 可以读入stdin数据，并且以空格符或断行字符作为分辨，将stdin
						数据分隔成为arguments。一般是为那些不支持管线符的命令作
						支持
					命令选项：
						-0：如果输入的stdin含有特殊字符，例如 `、\、空格键等等字
							符时，这个-0参数可以将他还原成一般字符。这个参数可以
							用于特殊状态
						-e：这个是EOF(end of file)的意思。后面可以接一个字符串，
							当xargs分析道这个字符串时，就会停止继续工作。
							
							# 注意-e和字符串间没有空格，并且字符串用单引号包含
								例如 xargs -e'end' command
							
						-p：在执行每个指令的argument时，都会询问使用者的意思
						-n：后面接次数，每次command指令执行时，要使用几个参数的意思
					# 当xargs后面没有接任何的指令时，默认是以echo来进行输出的哦
					
					
		> 条件判断
			>> 单文件测试选项及其作用：
			
				-e 文件：判断文件是否存在(存在为真) # 常用
				-b 文件：判断文件是否存在，并且是否为块设备文件(是块设备文件为真)
				-c 文件：判断文件是否存在，并且是否为字符设备文件(是字符设备文件为真)
				-d 文件：判断文件是否存在，并且是否为目录文件(是目录为真) # 常用
				-f 文件：判断文件是否存在，并且是否为普通文件(是普通文件为真) # 常用
				-L 文件：判断文件是否存在，并且是否为符号链接文件(是符号链接文件为真) # 常用
				-p 文件：判断文件是否存在，并且是否为管道文件(是管道文件为真)，即FIFO(pipe)文件
				-S 文件：判断文件是否存在，并且是否为一个Socket文件
				
				-r 文件：判断该文件是否存在，并且是否该文件拥有读权限(有读权限为真)
					# 所有者所属组其它人只要一个拥有就为真
				-w 文件：判断该文件是否存在，并且是否该文件拥有写权限(有写权限为真)
					# 所有者所属组其它人只要一个拥有就为真
				-x 文件：判断该文件是否存在，并且是否该文件拥有执行权限(有执行权限为真)
					# 所有者所属组其它人只要一个拥有就为真
				-u 文件：判断该文件是否存在，并且是否该文件拥有SUID权限(有SUID权限为真)
				-g 文件：判断该文件是否存在，并且是否该文件拥有SGID权限(有SGID权限为真)
				-k 文件：判断该文件是否存在，并且是否该文件拥有SBit权限(有SBit权限为真)
				-s 文件：判断此文件是否存在，并且是否为非空文件
				
				
			>> 双文件测试选项及其作用：
				文件1 -nt 文件2：判断文件1的修改时间是否比文件2的新(如果新则为真)
				文件1 -ot 文件2：判断文件1的修改时间是否比文件2的旧(如果旧则为真)
				文件1 -ef 文件2：判断文件1是否和文件2的Inode号一致，可以理解为两
					个文件是否为同一个文件。这个判断用于判断硬链接是很好的方法
					
			>> 整数比较测试选项及其作用：
				整数1 -eq 整数2：判断整数1是否和整数2相等(相等为真)
				整数1 -ne 整数2：判断整数1是否和整数2不相等(不相等为真)
				整数1 -gt 整数2：判断整数1是否大于整数2(大于为真)
				整数1 -lt 整数2：判断整数1是否小于整数2(小于为真)
				整数1 -ge 整数2：判断整数1是否大于等于整数2(大于等于为真)
				整数1 -le 整数2：判断整数1是否小于等于整数2(小于等于为真)
			
				
			>> 字符串判断测试选项及其作用：
				-z 字符串：判断字符串是否为空(为空返回真)
				-n 字符串：判断字符串是否为非空(非空返回真)
				字符串1 == 字符串2：判断字符串1是否和字符串2相等(相等返回真)
					# 注意：等等号两侧一定要有空格，否则会出现无论都为真
				字符串1 != 字符串2：判断字符串1是否和字符串2不相等(不相等返回真)
					# 注意：等等号两侧一定要有空格，否则会出现无论都为真
				
				# 注意：经测试如果变量不存在，则把那个变量当做为空进行逻辑判断
			
			>> echo "23*24" | bc		# 用计算器计算字符串内的内容
			
			>> 多重条件判断：
				判断1 -a 判断2：逻辑与，判断1和判断2都成立，最终的结果才为真
				判断1 -o 判断2：逻辑或，判断1和判断2有一个城里，最终的结果就为真
				! 判断：逻辑非，是原始的判断式取反 
					# 注意：这里的感叹号和判断间有空格
					
			>> 判断格式：
				1.test 测试选项 文件名	# 范例：test -e ~/test.txt
				2. [ 测试选项 文件名 ]	# 注意中括号和内容之间必须有空格
				
				
				# 对于判断式在中括号[]内的每个组件都需要有空格
				# 对于判断式在中括号[]内的变量，最好都以双引号扩起来
				# 对于判断式在中括号[]内的常量，最好都以单引号或双引号扩起来
				
				# 范例举例： [空格文件1空格判断符空格文件2空格]，因为中括号可能
					会是正则表达式的意思，为了与正则区分，所以应该加上空格
				# 范例举例：
					name="VBird Tsai"
					[ ${name} == "VBird" ]		# 此句会报错：too many arguments
					因为最后会转为 [ VBird Tsai == "VBird" ] 相当于多个参数和字符
					串比较，那么应该改为 [ "${name}" == "VBird" ]
					
			>> 使用判断：
				1. [ -e ~/test.txt ] && echo yes || echo no
					# 如果为真则输出 yes，为假则输出 no
				2.  范例：[ -n "$name1" -a -n "$name2" -a "$name1" -gt "$name2" ] \
						&& echo yes || echo no
				3. 在使用多条件的时候可以
					[ -n "$name" -a -n "$name2" ]
						或者
					[ -n "$name" ] && [ -n "$name2" ]
					
		> 流程语句
			>> 单分支if语句的两种写法
				if [ 条件判断式 ];then
					程序
				fi
				或者
				if [ 条件判断式 ]
					then
						程序
				fi
				
			>> 双分支if条件语句
				if [ 条件判断式 ]
					then
						条件成立时，执行的程序
						# 可以在结束程序时返回值“exit 值1”
							写了返回值后之后的程序不再执行
				else
					条件不成立时，执行的程序
					# 可以在结束程序时返回值“exit 值2”
						写了返回值后之后的程序不再执行
				fi
				
				# 通常可以通过shell脚本判断一个变量是否为数字：
					把变量用sed命令进行正则表达式判断如果是数字则替换为空字
						符串，最后替换完毕后再判断这个变量是否是空字符串则
						得出结论
				
			>> 多分支if条件语句
				if [ 条件判断式1 ]
					then
						当条件判断式1成立时，执行程序1
						# 如果写了 “exit 值” 则程序退出，
							之后所有的程序就不会执行
				elif [ 条件判断式2 ]
					then
						当条件判断式2成立时，执行程序2
						# 如果写了 “exit 值” 则程序退出，
							之后所有的程序就不会执行
				~# ...省略更多其它判断条件...
					else
					当所有条件都不成立时，执行的程序
				fi
				
			>> 开关语句
				case $变量名 in
					"常量值1")
						如果变量的值等于常量值1，执行程序1
						;;
					"常量值2")
						如果变量的值等于常量值1，执行程序2
						;;
					"常量值3")
						如果变量的值等于常量值1，执行程序3
						;;
					.
					.
					.
					此处省略一万字
					.
					.
					.
					*)
						以上值都不等的情况下，执行此程序
						;;
				esac
				
			>> for循环语句 
				1.
					for 变量A in 值1 值2 值3...
						do
							程序
						done
						
					# 此种方法有多少个值执行多少次循环，没辞循环把当前值传
						给变量A
				2.
					for (( 初始值; 循环控制条件; 变量变化 ))
						do
							程序
						done
						
					# 范例：for(( i=1; i<=100; i=i+1 ))
								do
									echo "$i"
								done
				
			>> while循环与until循环语句
				1.
					while [ 条件判断式 ]
						do
							程序
						done
				2. 
					until循环跟while循环相反，即只要条件判断式不成立则进行
					循环，并执行循环程序，一旦循环条件成立，则终止循环
					untile [ 条件判断式 ]
						do
							程序
						done
						
						
						
						
** Linux服务的分类

	* 源码 --> 编译后的目标文件 --函式库(动态函式库/静态函式库)--> 可执行文件
	
	* 在编译过程中并不简单，因为主程序和所有子程序都需要有个编译的过程指令，而且
		在编译后每个目标文件还要建立链接程序，如果程序一多必然很困扰。此时就有
		make 指令使这个过程简单化
		
		make 执行时会在当前目录下搜寻 Makefile(或者是 makefile)。而Makefile 里面
		记录了原始码怎么编译的详细信息。make 会自动判别原始码是否变动过，而自动
		更新执行档。
		
		make 是一支程序，去找 Makefile，通常开发商都会写一支侦测程序来侦测用户作
		业环境，以及该环境是否有需要的其它功能。侦测完毕后就自动建立这个 Makefile
		的规则文件！通常这支侦测程序的文件名文 configure 或 config

	* Tarball 软件
		由于源码一般很占空间，所以把源码进行tar打包再压缩得到软件包，成为Tarball
		一般是用gzip打包,后缀可能为*.tar.gz或者简写是*.tgz;用bzip2打包，后缀可能
		是*.tar.bz2；用xz打包，后缀可能是*.tar.xz
		
		> 解压后文件通常有：
			1. 源代码文件
			2. 侦测程序文件(可能是 configure 或 config 等档名)
			3. 本软件的简易说明与安装说明(INSTALL 或 README)
			
		> Tarball 安装方式
			1. 将 Tarball 由厂商网页下载下来；
			2. 将 Tarball 解压缩，产生很多源码文件；
			3. 开始用 gcc 对源码编译(会产生很多目标文件 object files)；
			4. 用 gcc 进行函式库、主、子程序链接，形成主要的 binary file；
			5. 将上述的 binary file 以及相关的配置文件安装到主机
			
			# 上面 3,4 步骤中，可以透过 make 指令来简化它
			
		> gcc 教程
			gcc hello.c					# 会生成 binary program 的 a.out
			gcc -c hello.c				# 会生成目标文件 hello.o
			gcc -o hello hello.o		# 会生成可执行文件
			gcc -O -c thanks.c thanks2.c	# -O产生优化的参数
			gcc -Wall -c thanks.c thanks2.c	# -Wall产生更详细的编译过程，因为这
												样编译更严谨所以可能会有警告讯息
			
			范例：
			A.c 内容是
			#include<stdio.h> 
			int main(void) 
			{ 
				printf("Hello Linux\n"; 
				customerPrint();
				reutrn 0;
			}
			B.c 内容是
			#include<stdio.h>
			void customerPrint()
			{
				printf("this is B.c\n");
				return;
			}
			
			编译过程：
				gcc -c A.c B.c			# 生成 A.o B.o
				gcc -o Final A.o B.o	# 生成可执行文件 Final
				
	* 安装升级
		> 如果厂商有对软件升级，那么可以通过两种方式进行升级
			1. 直接以源码透过编译来安装与升级
			2. 直接以编译好的 binary program 来安装升级(有Linux distribution 限制)
		> 对于 binary program 主要有两种：
			>> dpkg(针对 Debian 和 Ubuntu)
			>> RPM(针对 red Hat 和 Centos)
		> 对于在线升级主要有两种：
			>> APT(针对 Debian 和 Ubuntu)
			>> yum(针对 red Hat 和 Centos)
		
	
	* 链接函式库
		> 在 C 语言中的<math.h>的库文件中的函数会主动去调用数学函式库，而调用的往往是
			libm.so这个函式库，这个函式库默认放在/lib，/lib64文件夹中。所以一般不用
			“-L”去查找这个函式库所在位置。在libm.so的编译的写法上，使用的是“-lm”(lib
			简写为 l )，
			
			范例为：gcc sin.c -lm -L/lib -L/lib64
				-l：是加入某个函式库(library)的意思
				m：是libm.so这个函式库，其中，lib与扩展名(.a 或 .so)不需要写
			
			# -lm 表示使用 libm.so(或 libm.a) 这个函式库，至于 -L 后面接路径。表
				示我要的函式库 libm.so 到 /lib 或 /lib64 文件夹下查找
	
	
		> 在 C 语言中的<stdio.h> 是凡在 /usr/include/stdio.h 中的，如果不是放在这个目
			录下则要指定路径
			
			范例为：gcc sin.c -lm -I/usr/include
			
			# -I/path路径 表示根据这个路径查找<stdio.h>需要的函式库
				
	
	
	* make 宏编译
	
		> makefile 文件语法格式：
			target:目标文件1 目标文件2
			<tab> gcc -o 欲建立的执行文件名 目标文件1 目标文件2
	
		> 手动创建文件名为 makefile 的文件
		
			范例 #### START ####
			main:main.o main1.o main2.o
				gcc -o main main.o main1.o main2.o
				
			clean:
				rm -rf *.o
			范例 #### END ####
		
			>> 基本规则
				# 文件中 以 “#” 开头的都是注释
				# 第二行之前的是<tab>按键产生的，<tab>需要在命令行的第一个字符
				# 目标与相依文件用“:”隔开
				# 执行 make makefile main 会去读取 makefile 的内容根据内容直接给他编译
					相关的文件，然后执行第二行命令(如果没有 clean 部分则可以直接执行 make makefile
				# 执行 make makefile clean 会去删除以“.o”结尾的文件
		
		> makefile 的变量设定
		
			范例 #### START ####
			LIBS = -lm
			OBJS = main.o main1.o main2.o
			main:${OBJS}
				gcc -o main ${OBJS} ${LIBS}
			clean:
				rm -f main ${OBJS}
			范例 #### END ####
			
			>> 基本规则2
				# 变量与变量值之间用 “=”隔开，但是“=”两边可以有空格
				# 变量名左边不可以有<tab>
				# 变量与变量值在“=”两边不能具有“:”
				# 在习惯上，变量最好是用大写字母为主
				# 运用变量时，以${变量} 或 $(变量) 使用
				# 在该 shell 的环境变量是可以被套用的，例如提到的 CFLAGS 这个变数
				# 在指令列模式也可以给予变量
			
		> 变量的取用
			由于 gcc 在进行编译的行为时，会主动读取CFLAGS 这个环境变量的值，你可以
			在 shell 中定义出这个环境变量
			也可以在 makefile 文件里定义
			也可以在指令列中定义变量值
			
			范例：
				指令：CFLAGS="-Wall" make clean main
				makefile文件中：CFLAGS = -Wall
				环境变量中：CFLAGS=-Wall
				
			变量取用优先级顺序：
				1. 指令后面加上的环境变量为第一
				2. malefile 里面指定的环境变量第二
				3. shell 原本具有的环境变量第三
				
		> makefile 里面的特殊变量
			$@ 指的是当前的目标
			范例：
				main: main.o main1.o
					gcc -o $@ main.o main1.o
					
				# 这里的 $@ 就是 main 到时候编译过后的执行文件名就是 main
	
	* Tarball 安装基本步骤
	
		1. 取得原始压缩包，一般将压缩包放在 /usr/local/src 目录下再解压缩
		2. 取得步骤流程，进入解压的目录里，查阅 INSTALL 与 README 等相关文档(很重要)
		3. 相依属性软件安装：根据 INSTALL/README 的内容查看并安装好依赖软件(非必要)
		4. 建立 makefile：以自动侦测程序(configure 或 config)侦测作业环境，并建立 Makefile 文件
		5. 编译：以 make 这个程序并使用该目录下的 Makefile 作为他的参数配置文件，进行编译动作
		6. 安装：以 make 程序，并以 Makefile 这个参数配置文件，依据 install 这个目标的指定来
			安装到正确的路径
			
		> 大部分 tarball 软件安装指令下达方式：
			>> ./configure	# 这个步骤是建立 Makefile 这个文件,通常开发商会写一个侦测程序检查当前
				linux环境信息。在安装编译好的软件的时候应该参考 README 或 INSTALL
			>> make clean	# 清除他认为可以去除的目标文件
			>> make	# 会依据 Makefile 当中的预设工作进行编译行为，编译后的可执行文件会放在当前目录
				下而并未安装
			>> make install	# make指令会根据 Makefile 这个文件里的关于install的项目进行将编译后的
				软件安装到系统
				
			>> 如果安装成功并且是安装在一个独立的目录，例如 /usr/local/packages 这个目录中，那么就
				必须手动将这个软件的的 man page 给它写入 /etc/man_db.conf 里面去
	
			# 在预设情况下 Linux 软件一般都安装在 /usr 里的，但是用户自行安装的软件则建议放置在
				/usr/local 里面，这是考虑到管理用户所安装软件的便利性
				
			# 在预设情况下 man 会去搜寻 /usr/local/man 里面的说明文件，因此，如果软件安装在 /usr/local
				底下的话，那么自然安装完成之后，该软件的说明文件就可以被找到
				
			# 至于原始码则建议放到 /usr/local/src(src 为 source 的缩写)底下
	
	* 一般 Tarball 软件安装建议事项(如何移除？升级？)
	
		> 一般 Linux 释出安装的软件都是在 /usr 里的，所以用户自己安装的软件建议安装在 /usr/local 里
			一般软件的内容在安装路径下一般有以下几个：
				/usr/etc/			# 软件配置文件
				/usr/lib/			# 函式库
				/usr/bin/			# 执行档
				/usr/share/man/		# 联机帮助档
			
			所以如果你安装在 /usr/local/ 下，则最后的生成信息为：
				/usr/local/etc
				/usr/local/bin
				/usr/local/lib
				/usr/local/man
				
			如果每个软件都直接安装在 /usr/local 下则会造成管理麻烦，删除和升级困难，一般建议
			一个独立的软件有自己独立的文件夹，但是独立的文件夹都应该放在 /usr/local 下
			范例一个叫做 apache 的软件安装在 /usr/local/apache/ 的文件夹下范例：
				/usr/local/apache/etc
				/usr/local/apache/bin
				/usr/local/apache/lib
				/usr/local/apache/man
				
			# 这样 /usr/local/apache/bin 应该加入 PATH 中，同时 /usr/local/apache/man 应该加入
				man page 的搜索路径(易于管理维护，但是缺点是一些帮助文档和执行档不在系统默认扫
				描的路径范畴内)
				
			# 既然有man查出来的文档信息，通常这个文档信息是保存在某个目录里面的，通常是放在
				/usr/share/man这里的，然而可以修改它的搜寻路径来改善这个目录的问题往往是修改
				/etc/man_db.conf(有的版本为man.conf或manpath.conf或man.config等)

		> 建议的安装方式
		
			1. 将 tarball 的源码包解压缩到 /usr/local/src/ 当中
			2. 安装时，安装到 /usr/local 这个默认路径下
			3. 考虑到反安装以及可维护，最好安装在 /usr/local/软件名独立文件名
			4. 安装到单独目录的软件的 man page 加入 man page 以提搜索，范例：
				如果安装到 /usr/local/software/ 下，那么 man page 设定中应该
				在 /etc/man_db.conf(有可能是其它名字) 里加入相应的行
				MANPATH_MAP /usr/local/software/bin /usr/local/software/man
	
	* 函式库管理
	
		# 函式库根据是否被编译到程序内部而分为动态(Dynamic)与静态(Static)函式库
		
		> 静态函式库特点
			>> 扩展名为：*.a 这类函式库通常扩展名为 libxxx.a 的类型
			>> 编译行为：编译时候会直接整合到执行程序中，所以这样编译的文件较大
			>> 独立执行状态：编译成功后可以独立执行，不需要向外读取函式库内容
			>> 升级难易度：因为函式库是直接整合到执行档中，所以如果函式库升级，
				则必须对执行档重新编译，所以用到这个函式库的软件都需要重新编译
				升级不便
			
		> 动态函式库特点
			>> 扩展名为：*.so 这类函式库通常扩展名为 libxxx.so 的类型
			>> 变异性为：动态函式库在编译的时候在程序里只有一个指向(Pointer)的
				位置，也就是说，动态函式库内容没有被整合到程序里而是执行档需要
				时才读取函式库来使用，所以通过如此编译的软件会小一些
			>> 独立执行状态：不能独立执行，因为我们使用到函式库时，回去读取函式
				库，所以函式库必须存在才行，而且函式库所在目录不能改变。因为我们
				的可执行文件里面有指标指向动态函式库。程序会去相应路径下读取。所
				以动态函式库不能随意移动或删除
			>> 升级难易度：当升级函式库后，执行档不需要重新编译，因为执行档会直
				接指向新的函式库文件(前提是函式库新旧版本的档名和位置相同)
				
		# 目前 Linux 比较倾向于使用动态函式库，因为如果用静态函式库的软件增多，
			如果函式库变动则会对系统造成很大冲击
			
		# 绝大多数函式库放在 /lib 和 /lib64 目录下，Linux 系统的很多函式库其实
			kernel 已经提供了，kernel 的函式库放在 /lib/modules 里面
			
		
	* RPM SRPM
	
		> 现 Linux distrubution 主流软件包
			>> dpkg：适用于 Debian 和 Ubuntu
			>> rpm：适用于Red Hat 以及 Centos
		
		> 相关指令
			distribution 代表		软件管理机制		使用指令		在线升级机制(指令)
			Red Hat/Fedora			RPM					rpm,rpmbuild	YUM(yum)
			Debian/Ubuntu			DPKG				dpkg			APT(apt-get)
			
		> 软件包
			>> rpm
				1. 扩展名为 ****.rpm
				2. 在相应平台机器上编译后的可执行软件,所以软件传输很方便，不需要重编译
				3. 安装后相应软件信息都记录在 Linux 主机数据库上
				4. 软件文件的安装环境应该与打包时的环境需求一致
				5. 需要满足软件的相依属性需求
				6. 卸载时，底层软件不可先移除，否则造成系统问题
					例如 A depend B depend C depend D
					不能先卸载 D ,如果要卸载 D 则应该由 A 到 D 卸载
			>> srpm
				1. 通常扩展名是 ***.src.rpm
				2. 它也提供了 configure 与 makefile 同事还有软件相依性说明以及源码
		

		> rpm 安装原理
			rpm 安装会先检验本机是否有安装的环境条件，检测不通过则无法安装(可以强制安装)，安装完毕会
			将软件信息写入 /var/lib/rpm/ 目录下的数据库文件中，之后的 rpm 查询以及软件的签名都是在这
			个数据库中的
		
		> rpm 指令
			>> 安装
				rpm -ivh package_name
					命令参数：
						-i	# install 的意思
						-v	# 查看更详细的安装信息画面
						-h	# 显示安装进度
			
			>> 卸载
				rpm -e 包名
						
			>> 升级
				rpm [-Uvh | -Fvh] package_name
					命令参数：
						-Uvh	# 如果后面接的软件没有安装过，则系统将予以直接安装；若后面接的软件有
									安装过则系统使之自动更新至最新版
						-Fvh	# 如果后面接的软件并未安装，则系统不会予以安装
					特殊选项：
						--nodeps		# 当发生软件属性相依问题而无法安装时，强制安装
						--replacefiles	# 在安装过程中出现了某个文件已经被安装在系统上了或者发现版本
											不一样时直接覆盖安装(此覆盖后无法还原)
						--replacepkgs	# 如果软件已经安装在您的系统上则重新安装
						--force			# 相当于 --replacefiles 与 --replacepkgs 的综合
						--test			# 测试该软件是否可安装到当前环境，只是测试情况不会安装，由此
											可以检测软件相依性问题
											范例：rpm -ivh pkgname.i386.rpm --test
						--justdb		# 由于 RPM 数据库破坏或者某些缘故产生错误时，可使本命令更新
											本软件在数据库内的相关信息
						--nosignature	# 略过数字签名时的检查
						--prefix 新路径	# 将软件安装到自定义目录
						--noscripts		# 不让该软件在安装过程中自行执行某些系统命令(软件安装完毕后
											可能执行某些前置作业命令，比如更新软件数据库信息，此命令
											可禁止掉)
							
			>> RPM 查询
				rpm [命令参数] [package_name]
				
					命令参数：
						-q		# 仅查询，后面接的软件名称是否有安装
						-qa		# 列出所有的，已经安装在本机 Linux 系统上面的所有软件名称
						-qi		# 列出该软件详细信息(information)，包含开发商，版本与说明等
						-ql		# 列出该软件所有的文件与目录所在完整文件名(list)
						-qc		# 列出该软件的所有配置文件(超出在 /etc/ 底下的档名)
						-qd		# 列出该软件的所有说明文件(找出与 man 有关的文件而已)
						-qR		# 列出与该软件有关的相依软件所含的文件(Required 的意思)
						-qf		# 由后面接的文件名，找出该文件属于哪一个已安装的软件
						-q --scripts	# 列出是否含有安装后需要执行的脚本文档，可用以 debug
						
						# 查询某个 RPM 文件内含有的信息：
							-qp[icdlR]：注意 -qp 后面接的所欲参数以上面的说明以致，大用途仅在于
								找出某个 RPM 文件内的信息，而非已安装的软件信息
					
					
						# 查询安装的软件可以不加版本号，系统会自动在 /var/lib/rpm 数据库里查找
						# 查找关于 RPM 的信息的时候需要些完整的档名才行
					
			> RPM 验证数字和签名
			
				rpm [命令选项] [已安装的软件名称 | 某个 RPM 文件档名 | 系统上面得某个文件]
					命令选项：
						-V	# 后面接的是软件名称，若该软件所含的文件被更动过，才会列出来
						-Va	# 列出目前系统上面所有可能被更动过的文件
						-Vp	# 后面加的是文件名，列出该软件内可能被更动过的文件
						-Vf	# 列出某个文件是否被更动过
						
				基本范例：
					rpm -Va
					rpm -V 已安装的软件名称
					rpm -Vp 某个 RPM 文件的档名
					rpm -Vf 在系统上面得某个文件
						
				范例：
					如果有个富案件的配置文件为 /etc/logrotate.conf 并且已经做了修改
					rpm -V logrotate
					# 结果为：..5....T. c /etc/logrotate.conf
					
					# 发现在档名之前有个 c ，代表 configuration 的意思。至于前面几个信息
						为：
						S	# (file Size differs)文件的容量大小是否被改变
						M	# (Mode fiffers)文件的类型或文件的属性(rwx)是否被改变？如是否可执行参数
								被改变
						5	# (MD5 sum fiffers)MD5 这一种指纹码的内容已经不同
						D	# (Device major/minor number mis-match)装置的主/次代码已经改变
						L	# (readLink(2) path mis-match)Link路径已经被改变
						U	# (User ownership differs)文件的所属人已被改变
						G	# (Group ownership differs)文件的所属组已经被改变
						T	# (mTime differs)文件的建立时间已经被改变
						P	# (caPabilities differ)功能已经被改变
					# 如果一个配置文件所有的信息都被更动过，那么他的显示就是：SM5DLUGTP c filename
						至于那个c代表的意思就是 Config file 的意思，也就是文件类型，文件类型有以下几
						条：
						c	# 配置文件(config file)
						d	# 文件数据文件(documentation)
						g	# 鬼文件~通常是改文件不被某个软件所包含，较少发生(ghost file)
						l	# 许可证文件(locense file)
						r	# 自述文件(read me)
					
	* yum 安装
		> yum 机制
			yum 在当用户有升级、安装需求时，yum会向软件库更新清单，清单更新到/var/cache/yum 后，就会利用
			清单和 rpm 数据库比较就知道该下载什么软件了
			
		> yum 的查询功能
			>> yum [option] [查询工作项目] [相关参数]
			
				选项与参数[option]：
					-y：当 yum 要提示用户输入时，自动提供 yes 响应(谨慎使用！！)
					-installroot=/some/path：将该软件爱你安装在 /some/path 而不适用默认路径
				
				[查询工作项目] [相关参数]：
					earch：搜寻某个软件名称或是描述的重要关键字
					list：列出目前 yum 所管理的所有软件名称与版本，有点类似 rpm -qa
					info：同上，但类似 rpm -qai 的执行结果
					provides：从文件去搜寻软件！类似 rpm -qf 的功能
					
		> yum 的 安装 升级
			>> yum [option] [安装与升级的工作项目] [相关参数]
				选项与参数：
					install：后面接要安装的软件
					update：后面接升级的软件，若要整个系统都升级，后面可什么都不跟
							(谨慎！！)
							
		> yum 的卸载
			>> yum remove 软件包名
				
					
		> 江湖秘诀：
			1. 安装：yum install(你的软件)
			2. 启动：systemctl start(你的软件)
			3. 开机启动：systemctl enable(你的软件)
			4. 防火墙：
				firewall-cmd --add-service="(你的服务)";
				firewall-cmd --permanedt --add-service="(你的服务)"
			
	* 其它基本简介：
		Linux服务 .---> 源码包安装服务
				  |
				  ~---> RPM包默认安装的服务 --.----> 独立的服务
											  |
											  ~----> 基于xineted服务
		
		# 独立的服务：直接在内存中，有访问时直接响应。速度快但耗费资源
		# 基于xineted服务：可以认为这个服务有系列子服务，当有请求要访问相关
			的子服务时，需要先访问这个服务，通过这个服务找到它对应的子服务
			当相应的时候则从子服务到此服务再到访问者。速度不如独立的服务
	
	* 查询已经安装的服务的运行状态(Centos 6 才有)
	
		> RPM包安装的服务：
			chkconfig --list	
				# 查看RPM安装服务的自启动状态，可以看到所有RPM包安装的服
					务及其自启动状态，查看到的是计算机几种运行级别的状态
					(不能看源码包，并且不代表此时已处于运行状态，因为它
					只代表开机时被要求的启动状态)
		> 源码包安装的服务：
			查看服务安装位置，一般是/usr/local/下(源码包安装位置可以自定
				义，但是规定是要求在此目录下)
	
	* RPM包安装服务的管理
		> 独立服务的管理
			>> 目录关注：
				/etc/init.d/：启动脚本位置(针对于独立服务)
				/etc/sysconfig/：初始化环境配置文件位置
				/etc/：配置文件位置
				/etc/xinetd.conf： xinetd配置文件
				/etc/xinetd.d/：基于xinetd服务的启动脚本
				/var/lib/：服务产生的数据放在这里
				/var/log/：日志
			>> 独立服务的操作
				1. /etc/init.d/独立服务名 start|stop|status|restart
					# 分别表示：启动、停止、查询状态、重启
					# 范例：etc/init.d/apache start	# 启动apache服务
				2. service 独立服务名 start|stop|status|restart
					# 同理
					# service是Red Hat专用，相当于在/etc/init.d/目录下
						寻找对应的独立服务名
					# service --status-all	# 查询所有独立服务的状态
				3. 独立服务的自启
					3_0：chkconfig --level 级别 独立服务名 on|off
							# on表示启动自启，off表示关闭自启
							# 最后如果是off尚不清楚，待解决
							# httpd服务的2、3、4、5的级别会自动启动
							范例：chkconfig --level 2345 httpd on
							
					3_1：修改/etc/rc.d/rc.local文件，在里面添加启动独立
						服务的脚本内容即可。这个脚本会在系统全部服务启动完
						毕后，用户输入进入系统的密码前执行
						
						# 建议使用修改这个文件的自启动方案
					3_2：ntsysv命令管理自启动
						# 此命令不仅支持 独立服务 也支持 基于xineted服务
						# 此命令仍然是Red Hat专有命令，慎用
						
		> 基于xinetd服务与telnet服务
			>> 前言
				telnet服务是基于xinetd服务的
				
			>> xinetd服务
				简介：
					随着linux版本的更新换代，xinetd已经逐渐隐退与市场，默
					认是没有安装的，所以要学习应该先安装
					yum -y install xinetd
					yum -y install telnet-server
			
			>> telnet服务
				简介：
					Linux默认没有安装，此服务是不安全的，所以学习后应该删除服务
					安装：
						yum -y install telnet
						yum -y install telnet-server
				相关文件：
					vi /etc/xinetd.d/telnet
					内容如下：
						service telnet			<-服务的名称为telnet
						{
							flags =REUSE		<-标志位REUSE，设定TCP/IP socket可重用
							socket_type =stream <-使用TCP协议数据包
							wait =no			<-是否允许多个连接同时连接
							user =root			<-启动服务的用户名为root
							server =/usr/sbin/in.telnetd <-服务的启动程序
							log_on_failure +=USERID		 <-登录失败后，记录用户的ID
							disable =no					 <-是否服务不启动(这个改为no则为启动)
						}
						
					重启服务：service xinetd restart 
						# 没有telnet服务，因为telnet服务是基于xinetd
					自启方法：
						1. chkconfig telnet on|off	# on表示开启自启，off表示关闭自启
							或者
						2. ntsysv 命令设定自启
						
						注意：正常情况自启动状态变化不会影响当前计算机此刻的服务状态，因为自
							启动时下次开机时状态的变化，可是telnet的自启动更改后，当前状态服
							务状态也会改变
	

	* 源码包安装服务的管理
		> 前言
			源码包的安装的路径是可以默认和自定义的，一般不建议修改。如果没有修改则可以看安装文
			档。源码包的程序时通过绝对路径取得执行程序
			
		> 源码包启动
			根据源码包的安装帮助文档进行启动，通过绝对路径找到程序启动
			
		> 源码包自启动
			vi /etc/rc.d/rc.local 文件	# 在里面添加你启动服务的脚本即可
			
		> 让源码包服务被服务管理命令识别(即用独立服务的方式管理源码包服务)
			>> 十分不建议这么做，因为会让系统维护变得麻烦和歧义
			>> ln -s 源码包服务程序绝对路径 /etc/init.d/自定定义的启动名字
			
		> 让源码包服务能被chkconfig与ntsysv命令管理自启动
			>> 十分不建议这么做，因为会让系统维护变得麻烦和歧义
			>> ln -s 源码包服务程序绝对路径 /etc/init.d/自定义的启动名字
			>> 修改文件
			>> chkconfig --add 软连接自定义的启动名 
				# 加入chkconfig命令管理，删除是 chkconfig --del 名字
				
			范例：让源码包的apache服务被这两个命令自启动
				vi /etc/init.d/apache
				内容增加：
					# chkconfig: 35 86 76
					# 指定httpd脚本可以被chkconfig命令管理。格式是：
						chkconfig: 运行级别 启动顺序 关闭顺序
					# 注意启动顺序和关闭顺序不能和系统的现有启动服务一样	
					# description: source package apache
					# 说明，内容随意
				
			注意：
				vi /etc/rc.d/ # 可以得到一些rcn.d/ 的目录，n是数字，代表级别
				如果vi /etc/rc.d/rcn.d 可以得到一些 字母数字 命名的文件，这些
				会按照字母数字进行相应的启动级别
				
				
				
				
** Linux系统管理

	* 系统进程的管理
		> 简介：
			一个正在执行的一个程序或命令，每个进程都是一个运行的实体，都有自己
				的地址空间，并占用一定的系统资源
		> 作用：
			>> 判断服务器健康状态
			>> 查看系统中所有进程
			>> 杀死进程
		> 命令：
			>> ps [命令选项]
				命令选项：
					-A	# 所有的process均显示出来，与-e具有同样的效果
					-a	# 不与terminal有关的所有process
					-u	# 有效使用者(effective user)相关的process
					x	# 通常与 a 这个参数一起使用，可列出完整信息
				输出格式规划：
					l	# 较长，较详细地将该PID的信息列出
					j	# 工作的格式(jobs format)
					-f	# 做一个更为完整的输出
					
				# 查看自己的详细进程 ps -l
				# 查看系统运作的所有进程(这里没有“-”) ps aux
				# 查看系统中所有进程，使用BSD操作系统格式(此种方案是unix的方法)
					此处的a：查看所有前台进程，u：显示这个进程是由哪个用户产生的
					x：查看所有后台进程
			
					查询结果的列表信息：
						F：代表这个进程的旗标(process flag)，说明这个进程的总结进程，常见
							号码有：
								4：表示此进程的权限为root
								1：表示此子进程仅进行复制(fork)而没有实际执行(exec)
						
						S：代表这个进程的状态(STAT)，主要状态有：
							R：该进程正在运行中(Running)
							S：该进程目前正在睡眠状态(idle)，但可以被唤醒(signal)
							D：不可被唤醒的睡眠状态，通常这支程序可能在等待I/O的情况(ex>打印机)
							T：停止状态(stop)，可能是在工作控制(北京暂停)或除错(traced)状态
							Z：僵尸状态(Zombie)，进程已经终止，但却无法被移除至内存外
							
						UID/PID/PPID：代表该UID所哟精油/进程的PID号码/次京城的父进程PID号码
						
						C：代表CPU使用率，单位为百分比
						
						PRI/NI: Priority/Nice：Priority/Nice 的缩写，代表此进程被CPU所执行的优先级
							，数值越小代表该进程越快被cpu执行
							
						ADDR/SZ/WCHAN：都与内存有关，ADDR是kernel function 支出该进程在内存的哪个部分
							如果是个running的进程，一般就会显示 - ，/SZ 代表此进程用掉多少内存 /WCHAN
							表示该进程是否运行中，同样的，若为 - 表示正在运行中
						
						TTY：登入者的终端机位置，若为远程登录则使用动态终端接口(pts/n)
						
						TIME：使用掉的CPU时间，注意，是此进程实际花费CPU运作时间，而不是系统时间
						
						CMD：就是command的缩写，造成此进程的触发程序之指令为何
						
					
						USER：该进程是由哪个用户产生的
						PID：进程的ID号
						%CPU：该进程占用CPU资源的百分比，占用越高，进程越耗费资源
						%MEM：该进程占用物理内存的百分比，占用越高，进程越耗费资源
						VSZ：该进程占用虚拟内存的大小，单位KB
						RSS：该进程占用实际物理内存的大小，单位KB
						TTY：该进程是在哪个终端中运行的。其中tty1-tty7代表本地控制台终端，
							tty1-tty6是本地的字符界面终端，tty7是图形终端。pst/0-256代表
							虚拟终端(远程终端)
						STAT：进程状态，常见的状态有：R：运行、S：睡眠、T：停止状态、
							s：包含紫禁城、+：位于后台
						START：该进程的启动时间
						TIME：该进程占用CPU的时间，注意不是系统时间
						COMMAND：产生此进程的命令名
				
			>> ps -le	
				# 查看系统中所有进程，使用Linux标准命令格式
					此处的 l：显示详细进程，e：显示所有进程
			
			>> 查看系统健康状态
			
				# ps是截取一个时间点的进程状态，top则可以持续侦测进程运作的状态
			
				1. top [命令选项]
				
					命令选项：
						-d 秒数：指定top命令每隔几秒更新。默认3秒，那么每隔这么多秒刷新一次
							预设是 5 秒
						-b：以批次的方式执行top，还有更多的参数可以使用，通常会搭配数据流重导
							向来将批次的结果输出为文件
						-n：与-b搭配，意义是，需要进行几次top的输出结果
						-p：指定某些个PID来进行观察侦测而已
							在top执行过程当中可以使用的按键指令：
						
								# ?或h：显示交互模式的帮助
								# 大写的也可以shift+小写字母)
							
								?：显示在toop当中可以输入的按键指令
								P：以CPU的使用资源排序显示(也是默认情况，如果要按了其它的排序，要恢复
									的时候可以按 P)
								M：以Memory的使用资源排序显示
								N：以PID来排序
								T：由该Process使用的CPU时间累积(TIME+)排序
								k：给予某个PID一个讯号(signal)
								r：给予某个PID重新制定一个nice值
								q：离开top
								
					# 范例：
						top -b -n 2 > ~/top.txt		# 将两次刷新的记录写入到top.txt文件中
						
					
				2. 查询结果分析
					2_0. 第一行信息为任务队列信息
						12:26:46	
							# 系统当前时间(这里只是举例的时间)
						up 1 day, 13:32	
							# 系统的运行时间，本机已经运行1天13小时32分钟
						2 users		
							# 当前登陆了两个用户
						load average: 0.00, 0.00 ,0.00
							# 系统在之前1分钟，5分钟， 15分钟的平均负载。
								一般认为小于1时，负载较小，如果大于1，系
								统已经超出负荷(如果是单核即超过1，如果是
								多核心，则按经验来说是核心数是几就超过几
								算超出负荷)
								
					2_1. 第二行信息为进程信息
						Tasks: 95 total		# 系统中的进程总数
						1 running			# 正在运行的进程数
						94 sleeping			# 睡眠的进程
						0 stopped			# 正在停止的进程
						0 zombie			# 僵尸进程。如果不是0，需要手工检查僵尸进程
												一般是正在终止，但还未终止完毕的进程，如
												果过段时间这个僵尸进程数未变，则要手工检
												查进程情况
					2_2. 第三行信息为CPU信息
						Cpu(s): 0.1%usb		# 用户模式占用的CPU百分比
						0.1%sy				# 系统模式占用的CPU百分比
						0.0%ni				# 改变过优先级的用户进程占用的CPU百分比
						99.7%id				# 空闲CPU的CPU百分比
						0.1%wa				# 等待输入/输出的进程的占用CPU百分比
						0.0%hi				# 硬中断请求服务占用的CPU百分比
						0.1%si				# 软中断请求服务占用的CPU百分比
						0.0%st				# st(Steal time) 虚拟时间百分比。就是当虚拟机
												时，虚拟CPU等待时机CPU的时间百分比
												
					2_3. 第四行为物理内存信息
						Mem: 625344k total	# 物理内存的总量，单位KB
						571504k used		# 已经使用的物理内存数量
						53840k free			# 空闲的物理内存数量，我们使用的是虚拟机，总共
												只分配了628MB内存，所以只有53MB的空闲内存了
						65800k buffers		# 作为换红的内存数量
						
					2_4. 第五航为交换分区(swap)信息
						Swap: 524280k total	# 交换分区(虚拟内存)的总大小
						Ok used				# 已经使用的交换分区的大小
						524280k free		# 空闲交换分区的大小
						409280k cached		# 作为缓存的交互分区的大小
						
			>> pstree [选项]		# 查看进程树
				命令选项：
					-A：各进程树之间的连接以ASCII 字符来连接
					-U：各进程树之间的连接以万国码的字符来连接，在某些终端接口
						下可能会有错
					-p：显示进程的PID(此选项同时可以查看具体哪几个子进程)
					-u：显示进程的所属用户
					
				# 当有 -p -u 选项的时候，在每个进程中会有进程的 PID 和 owner，
					并且两者之间使用逗号隔开，如果那个进程与父进程的所有者相同则
					不会显示所有者
					
	
		> 系统进程的系列讯号
		
			# 用 man 7 signal 可以查询到工作管理的 signal
	
			1 SIGHUP 启动被终止的进程，可以该PID重新读取自己的配置文件，类似重新启动
			2 SIGINT 相当于用键盘输入ctrl+c来终端一个进程的进行
			9 SIGKILL 代表强制终端一个进程的进行，如果该进程进行到一半，那么尚未完成的
				部分可能会有半产品的缠身个，类似vim会有.filename.swp保留下来
			15 SIGTERIM 以正常的结束进程来终止该进程，由于是正常的终止，所以后续的动作会
				将他完成。不过，如果该进程已经发生问题，就是无法使用正常的方法终止时，
				输入这个signal也没有用
			19 SIGSTOP 相当于用键盘输入ctrl + z 来暂停一个进程并放入后台
					
		> 把进程放入后台
			>> 命令 &
				# 在命令语句后加“&”符号再运行即可，此种方案在后台仍然在运行
			>> 命令执行过程中，按 ctrl+z 快捷键
				# 此种方案放入后台后会暂停，除非重新唤起这个进程才能运行
				
		> 查看后台的工作
			jobs [-l]
				命令选项：
					-l：显示工作的PID
					-r：仅仅列出在背景执行(run)的进程
					-s：仅仅列出在背景暂停(stop)的进程
			
			# 查询所得结果分析
				第一列：工作号和“+”或“-”号	
					# 工作号就是第几个放入后台的，“+”代表最近一个放入后台的工
						作，也是工作恢复时，默认恢复的工作。“-”号代表倒数第二
						个放入后台的工作，第三个放入后台的就没有加减号
				第二列：状态
				第三列：进程命令
				
		> 将后台暂停的进程恢复到前台执行 
			# 注意是恢复到后台执行
			# 后台恢复执行的命令，是不能和前台有交互的，否则不能恢复到后台执行
				即不会生效。例如 top 命令。它是显示系统健康状况并且要和前台有
				交互才能运行，如果仅仅是在后台运行则无实际意义，所以 fg 命令对
				top 无效
			
			fg %工作号
				参数：
					%工作号：%号可以省略，但是注意工作号和PID的区别
			范例：fg %3 和 fg 3 同理；fg 则表示恢复带“+”的进程
			
		> 将进程放在背景执行
			bg %工作号
			
		> 因为bg或者 command & 是基于当前bash环境然后产生的子进程进行执行的，所以
			如果在脱机后则后台进程就不能执行
		
		> 解决脱机问题的后台进程
			>> 使用 at 或者 crontab 命令的排程命令
			>> nohup [指令与参数]		# 在终端机前景中工作
			>> nohup [指令与参数] &		# 在终端机后台中工作
			范例：
				nohup find / -name "*.txt" &	# 将这个查找命令在终端机后台工作
			
		> 杀死进程
			kill signal [%工作号 | PID号]
			
				# kill 后面默认跟的是PID，所以如果要用工作号来处理则要在工作号
					前面加上“%”,如果写成了 kill signal 1 那么是很危险的，因为
					默认1的PID是systemd的，所以如果杀掉了系统的根进程则系统会当掉
			
				signal参数：
					-l # 这个是L的小写，列出目前kill能够使用的讯号(signal)有哪些
						signal代表给予后面接的那个工作什么样的指示，用man 7 signal可知
						
					一些signal讯号：	
						-1 SIGHUP	# 重新读取一次参数的配置文件(类似reload)
						-2 SIGNT	# 代表由键盘输入ctrl c 同样的动作
						-9 SIGKILL	# 立即强制删除一个工作
						-15 SIGTERM # 以正常的进程方式终止一项工作，与-9不一样
						-19 SIGSTOP # 相当于用键盘输入 ctrl + z 来暂停一个进程
					
		> 杀死进程(通过进程名字)
			killall [-iIe] [command name]
				命令参数：
					-i：interactive 的意思，交互式，若需要删除时，会出现提示字符
						给用户
					-e：exact 的意思，表示后面接的command name要一致，但整个完整
						的指令不能超过15个字符
					-I：指令指令名称(可能含有参数)忽略大小写
					
				范例：
					1. killall -1 rsyslogd	# 给予rsyslogd这个指令启动的 PID 
						一个SIGHUP的讯号，如果用 ps aux 仔细看一下，若包含所有
						参数，则 /usr/sbin/rsyslogd -n 才是最完整的
						
					2. killall -9 httpd		# 强制终止所有以 httpd 启动的进程(其
						实并没有此进程在系统内)
						
					3. killall -i -9 bash
						Signal bash(13888) ? (y/N)		# 这个不杀
						Signal bash(13928) ? (y/N)		# 这个不杀
						Signal bash(13970) ? (y/N)		# 这个不杀
						Signal bash(14836) ? (y/N)		# 这个杀掉
						
						# 具有互动的功能！可以询问你是否要删除bash这个程序，要注
							意，若没有-i参数，所有bash都会被这个root杀掉，包括
							root自己的bash
		
		> 进程的优先级
			# 由于Linux会给予进程一个所谓的优先级(Priority,PRI)，这个值越小代表
				越有限，不过这个是由核心动态调整，所以无法修改。而系统提供了一个
				Nice作为用户可修改的优先级，最后系统会结合Priority以及Nice然后得
				出最后的优先级
				
			# PRI(new) = PRI(old) + nice
			>> nice可调整范围为 -20~19
			>> root可随意调整自己或他人的nice值，且范围为 -20~19
			>> 一般使用者仅可调整自己的进程nice值为 0~19(避免一般用户抢占系统资源)
			>> 一般使用者仅可将nice值越挑越高，列入本来nice为5，则未来仅能够调整
				到大于5
				
			>> nice [-n 数字] command	# 为某个新执行命令设定优先级
				-n 后面接一个数值，范围在 -20 ~ 19
				
			>> renice [number] PID		# 为某个PID的进程设定优先级，top命令也可以
											修改优先级
		
	
		
		> 显示开机时内核检测信息
			# 系统只要在开机的时候，核心会去侦测系统的硬件，不管是开机的时候，还是
				在运作的时候，只要是核心产生的讯息就会保存到内存中的保护区段。dmesg
				能够把这个保护区段中的信息读取出来，因为信息太多，建议联合管线符使用
				
			dmesg
			
		> vmstat [刷新延时 刷新次数]	# 监控系统资源
			vmstat [-a] [延迟 [总计侦测次数]]	# CPU/内存等信息
			vmstat [-fs]						# 内存相关
			vmstat [-S 单位]					# 设定显示数据的单位
			vmstat [-d]							# 与磁盘有关
			vmstat [-p 分区槽]					# 与磁盘有关
			
			命令选项：
				-a：使用 inactive/active(活跃与否) 取代 buffer/cache的内存输出信息
				-f：开机到目前为止，系统复制(fork)的进程数
				-s：将一些事件(开机至目前为止)导致的内存变化情况列表说明
				-S：后面可以接单位，让显示的数据有单位，例如K/M取代bytes的容量
				-d：列出磁盘的读写总量统计表
				-p：后面列出分区槽，可显示该分区槽的读写总量统计表
				
			范例：vmstat 1 3	# 监控三次系统资源，每次间隔1秒钟
			
			结果字段意义：
				进程字段(procs)细目分别为：
					r：等待运作中的进程数量;b：不可被唤醒的进程数量;
						# 这两项如果太多，代表系统越忙，因为系统忙所以有很多进程处于
							无法被执行或抑制在等待而无法被唤醒
							
				内存字段(memory)项目分别为：
					swpd：虚拟内存被使用的容量;free：未被使用的内存容量;buffer：用于缓存存储器;
					cache：用于高速缓存;
					
				内存置换空间(swap)的项目分别为：
					si：由磁盘中将进程取出的量;so：由于内存不足而将没用到的进程写入磁盘的swap容量
						如果si/so数值太大，表示内存内的数据常常得在磁盘与主存储器之间传来传去，系
						统效能会很差
						
				磁盘读写(io)的项目分别为：
					bi：由磁盘读入的区块数量;bo：写入到磁盘去的区块数量，如果这部分的值越高代表I/O
						非常忙碌
				
				系统(system)的项目分别为：
					in：每秒被终端的进程次数;cs：每秒钟进行的时间切换次数;这两个数值越大，代表系统与
						接口设备的沟通非常频繁，这些接口设备当然包括磁盘、网络卡、时间钟等
						
				
				CPU的项目分别为：
					us：核心层的CPU使用状态;sy：核心层所使用的CPU状态;id：闲置的状态;wa：等待I/O所耗
						费的CPU状态;st：被虚拟机(virtual machine)所盗用的CPU使用状态(2.6.11以后才支持)
						
		> 查看系统资源健康状况
		
			free [命令选项]
				命令选项：
					-b：以字节为单位显示，我们也可以使用 b(bytes),m(Mbytes),k(Kbytes)
						g(Gbytes)来显示单位，也可以直接让系统自己制定单位(-h)
					-k：以KB为单位显示，默认就是以KB为单位显示
					-m：以MB为单位显示
					-g：以GB为单位显示
					-t：在输出的最终结果，显示物理内存与swap的总量
					-s：可以让系统每秒钟输出一次，不间断的一直输出，可用于对系统
						实时观察
					-c：与-s同时处理，让free列出几次的意思
					
	
			# 缓冲和缓存区别：
				缓存(cache)：用来加速数据从硬盘中“读取”的
				缓冲(buffer)：用来加速数据“写入”硬盘的
	
		> 查看CPU信息
			cat /proc/cpuinfo
			
		> uptime
			# 显示系统的启动时间和平均负载，也就是top命令的第一行。
				w 命令也可以看到这个数据
				
		> 查看系统与内核相关信息
			uname [选项]
				命令选项：
					-a：查看系统所有相关信息
					-r：查看内核版本
					-s：查看系统名称
					-m：查看系统的硬件名称，例如 i686 或 x86_64等
					-p：CPU的类型，与-m类似，只是显示的是CPU的类型
					-i：硬件的平台(ix86)
					
		> 判断当前系统的位数
			file /bin/ls
			
		> 判断当前Linux系统的发行版
			lsb_release -a
			
		> 列出进程打开或使用的文件信息
			
			
			fuser [-umv] [-k [i] [-signal]] file/dir
			
				# 有时候在卸载软件时候提示 device is busy证明软件有文件被进程
					使用，此时可以通过命令查出有什么文件打开了
					
				命令选项：
					-u：除了进程的PID外，同时列出该进程的拥有者
					-m：后面接的那个档名会主动的上提到该文件系统的最顶层，对 umount
						不成功很有效
					-v：可以列出每个文件与进程还有指令的完整相关性
					-k：找出使用该文件/目录的PID，并试图以SIGKILL这个讯号给予该PID
					-i：必须与-k配合，在删除PID之前会先询问使用者意愿
					-signal：例如 -1 -15等等，若不加，预设是 SIGKILL(-9)
					
				结果分析：
					范例：fuser -uv /root/
						USER	PID		ACCESS 	COMMAND
						root	13888	..c..	(root)bash
						root	31743	..c..	(root)bash
						
					分析：
						ACCESS下的意义：
						c：此进程在当前的目录下(非次目录)
						e：可被触发为执行状态
						f：是一个被开启的文件
						r：代表顶层目录(root directory)
						F：该文件被开启了，不过在等待回应中
						m：可能为分享的动态函式库
						
					如果你要查询某个文件系统低下有多少进程正在占用文件系统时，
					-m 的选项就有帮助了。
		
			lsof [选项] [+d]
			
				# 根据进程查询进程打开的文档
				
				命令选项：
					-a 多项数据需要同时成立才显示出结果时(相当于 & 的条件)
					-U 列出Unix like 系统的socket文件类型
					-c 字符串：只列出以字符串开头的进程打开的文件
					-u 用户名：只列出某个用户的进程打开的文件
					-p pid：列出某个PID进程打开的文件
					+d 后面接目录：亦即找出某个目录底下已经被开启的文件
					
					
			pidof [-sx] program_name
			
				# 找出某支正在执行的程序的PID
			
				命令参数：
					-s 仅列出一个PID而不列出所有的PID
					-x 同时列出该 program name 可能的PPID那个进程的PID
					
				范例：
					pidof systemd	# 找出这个程序执行的 PID
					
	* 系统定时任务
	
		> 准备工作：
			>> service crond restart	# 启动crond
			>> chkconfig crond on	# 自启crond
			# 由于crond 服务是在系统开机时就自动启动了所以正常情况下不需要
				以上两个执行命令去启动服务，只是在未启动时需要先启动以便设
				定定时任务
				
		> 两种列行安排简介
			>> at		# at是个可以处理仅一次就结束排程的指令，不过要执行at时，
							需要atd服务支持，在某些版本中atd没有启动，centos默
							认是启动的
			>> crontab	# 这是一个循环一直执行下去的，可循环的为分钟，小时，周，
						月，年
						

		> at教程
			systemctl restart atd	# 重新启动 atd 这个服务
			systemctl enable atd	# 让这个服务开机就自动启动
			systemctl status atd	# 查询 atd 服务的状态
			
			at 命令产生的工作安排会以文本的方式写入/var/spool/at目录内
			
			at权限设置
				/etc/at.allow这个文件，写在这个文件的使用者才能使用at，没有在这里
					的用户则不能使用at(即时没有卸写在at.deny当中)
				/etc/at.deny这个文件，如果/etc/at.allow不存在，就寻找/etc/at.deny，
					若写在这个at.deny的使用者则不能使用at，而没由在这个at.deny文件
					中的使用者，就可以使用at
		
				如果这两个文件都不存在，那么只有root才可以使用at命令
				
				由于假设系统上的所有用户都是可信任的，因此系统通常会保留一个空的/etc/at.deny
				文件，意思是允许所有人使用at指令，如果你不希望有某些用户使用at的话，将禁止的
				用户账号写入/etc/at.deny即可，一个账号写一行
			
			at 命令
				atq					# 查询排程工作号
				atrm 排程工作号		# 移除相应的排程
				at -c 工作号		# 查看相应工作详情，用 -V 可以查看部分信息
				at [-mldv] TIME		# 排程设置
				at -l				# 工作查看，root可以查看全部的工作排程
					命令选项：
						-m	# 当at的工作完成后，计时没由输出讯息，亦以email通知使用者该
								工作已经完成
						-l	# at -l 相当于 atq，列出目前系统上面得所有该用户的at排程
						-d	# at -d 相当于atrm，可以取消一个在at排程中的工作
						-V	# 可以使用较明显的时间格式栏出at排程中的任务栏表
						-c	# 可以列出后面接的该项工作的实际指令内容
						
					TIME	时间格式，这里可以定义出什么时候要进行at这项工作的时间，格式如下：
						HH:MM					ex> 04:00
							# 在今日的HH:MM时刻进行，若该时刻已超过，则明天的HH:MM进行此项工作
						HH:MM YYYY-MM-DD		ex> 04:00 2015-07-30
							# 强制规定在某年某月的某一天天的特殊时刻进行该工作
						HH:MM[am|pm] [Month] [Date]		ex> 04pm July 30
							# 也是一样，强制在某年某月某日的某时刻进行
						HH:MM[am|pm] + number [minutes|hours|days|weeks|years]	ex> now + 5 minutes ex > 04pm + 3days
							# 就是说，在某个时间点再加几个时间后才进行
							
				范例：
					at now + 5 minutes									# 记得加 s
					a> /bin/mail -s "kkk" root < /root/.bashrc			# 这里是输入指令
					at> <EOT>											# 这里输入ctrl+d就出现这个字样代表结束
					job 2 at Thu Jul 30 19:35:00 2015					# 表示第二个at工作日在2015/07/30的19:35执行
					
					# 执行at会进入所谓的at shell 环境，让你下达多重指令
						可以指定多个指令在一个排程里，只要在按回车即可，
						每个语句就有“at>”符号
					
					at -c 2												# 查看刚刚的第二个工作排程
					
				注意：
					at指令会进入一个at shell环境让用户下达工作指令，建议最好用绝对路径
					下达指令，由于指令下达与PATH变量有关，同事与当时的工作目录也有关联
					所以用绝对路径保险些
					
				注意2：
					如果有输出信息，则在终端机无法显示，因为at的执行与终端机环境无关，
					而所有standard output/standard error output都会传送到执行者的mailbox
					去，所以终端机看不到，那么只有输出到终端机才能显示，如果是用tty1登入
					那么可以 echo "Hello" > /dev/tty1
					
				注意3：
					如果at shell内的指令并没有任何讯息输出，那么at默认不会发送email告诉
					执行者，如果一定要发送一封email告诉执行者，那么可以在 at 指令中加入
					“-m”的命令选项
					
						
	
		> crontab教程
	
			>> cron命令基本会每分钟去读取/etc/cron文件内容和/var/spool/cron目录
				内的排程文件信息
				
			>> 主要目录和文件详情
			
				/etc/crontab		# 此文件一般是系统级别的排程任务
					内容信息：
						SEHLL=/bin/bash							# 使用哪种shell接口执行脚本
						PATH=/sbin:/bin:/usr/sbin:/usr/bin		# 执行文件搜索路径
						MAILTO=root								# 若有额外STDOUT，以email将数据送给谁
						* * * * * 用户名 命令					# 相应用户在对应时间点执行相应命令
				
				/etc/cron.d/			# 此目录下记录了一系列执行脚本文件，一般用于个人开发
					软件，软件有需要用到排程功能的
					
					范例：/etc/cron.d/Ohourly 文件内容为
						SHELL=/bin/bash
						PATH=/sbin:/bin:/usr/sbin:/usr/bin
						MAILTO=root
						* * * * * 用户名 命令
						
					范例2：01 * * * * root run-parts /etc/cron.hourly
						# run-parts 命令是 shell script，这个脚本内容会在大约5分
							钟内随机选一个时间来执行 /etc/cron.hourly 目录内的所
							有执行文件。因此在/etc/cron.hourly/目录内的文件，必
							须是能够被直接执行的指令脚本，而不是分、时、日、月、
							周的设定值
							
							因此可以用 run-parts 脚本执行给予指定的路径下的脚本，
							它会在 5 分钟内随机时间点执行指定的文件夹下的脚本
							
							对应的还有：
							/etc/cron.hourly		# 每小时执行的
							/etc/cron.daily			# 每日执行的
							/etc/cron.monthly		# 每月执行的
							/etc/cron.weekly		# 每周执行的
							
							注意：
								以上四个的最后三个是由 anacron 命令执行的，anacron命令
								在/etc/cron.hourly/Oanacron里面
							
							
				
				/var/spool/cron/		# 此目录记录用户有关排程文件

					用户如有排程，那么此目录下只有一个以他用户名命名的文件，记录他
					所有的排程信息
					建议不要用vim或vi去编辑，应该用crontab -e去编辑，因为可能会产生
					语法错误以致功能错误
					
					格式：
					
					* * * * * 命令			# 在对应时间点执行命令
					
					范例：/var/spool/cron/user1
					
				
				/var/log/cron				# 排程执行的每一项工作都会记录再这个登录档
					里，相当于排程日志
					
			
				/etc/cron.allow		# 此文件将能够使用crontab的账号写入其中，
					如果不在这个文件内的账号则不能够使用定时任务
				/etc/cron.deny		# 此文件将不可使用crontab的账号写入其中，
					若未记录到这个文件当中的使用者就可以使用crontab
					
				# 这两个文件的规则是一个账号一行	
				# /etc/cron.allow比/etc/cron.deny优先级高，而在判断上选择一个来限制
					而已，因此建议只保留一个即可，系统默认是保留/etc/cron.deny
				# 当用户使用crontab指令建立工作排程之后，该项工作就被被记录到/var/spool/cron
					里去，而且是用账号来作为判别的。举例来说user1使用了crontab指令后，它的
					工作排程会记录到/var/spool/cron/user1里头去。所有的排程记录都会被记录到
					/var/spool/cron
				
			
			>> crontab [-u username] [-l|-e|-r]
			
				此命令完整路径：/usr/bin/crontab
			
				命令选项：
					-u:	只有root才能进行这个任务，亦即帮其他使用者建立/移除crontab工作排程
					-e：编辑crontab定时任务
					-l：查询crontab任务
					-r：删除当前用户所有的crontab任务
				
			如果是编辑定时任务需要按照特定的格式书写脚本即可(并且编辑模式是vi)
			格式如下：
				* * * * * 命令或脚本
			格式解析：
				第一个“*”：一小时当中的第几分钟(范围：0-59)
				第二个“*”：一天当中的第几小时(范围：0-23)
				第三个“*”：一个月当中的第几天(范围：1-31)
				第四个“*”：一年当中的第几月(范围：1-12)
				第五个“*”：一周当中的星期几(范围：0-7,0和7都代表星期日)
				
				# “*”代表不设定具体时间或日期单位，表示每那时间或日期单
					单位都执行，如果分钟设为“*”表示每分钟执行
					
			特殊符号：
				*	代表任何时间，比如第一个“*”就代表一小时中每分钟都执行
						一次的意思
						
				,	代表不连续的时间。比如“0 8,12,16 * * * 命令”，就代表
						每天的8点0分，12点0分，16点0分都执行一次命令
						
				-	代表连续的时间范围。比如“0 5 * * 1-6 命令”，代表在周
						一到周六的凌晨5点0分执行命令
						
				*/n	代表每隔多久执行一次。比如“*/10 * * * * 命令”，代表
						每隔10分钟就执行一遍命令，这里的这个*/10和0-59/10
						同意思
						
			范例：
				45 22 * * * 命令：在22点45分执行命令
				0 17 * * 1 命令：每周1的17点0分执行命令
				0 5 1,15 * * 命令：每月1号和15号凌晨5点0分执行命令
				40 4 * * 1-5 命令：每周1到周五的凌晨4点40分执行命令
				*/10 4 * * * 命令：每天的凌晨4点，每隔10分钟执行一次命令
				0 0 1,15 * 1 命令：每月1号和15号，每周1的0点0分都会执行命
					令。注意：星期几和几号最好不要同时出现，因为他们定义
					的都是天。非常容易让管理员混乱
				

			>> 注意负载事项：
				有时候一系统的cron来进行例行性工作建立时候，如果有四个工作都
				要5分钟进行一次，那么这四个工作不能分别在同一个时间点上开始
				执行，应该岔开执行。减少系统资源消耗
				
				范例：
					vim /etc/crontab 的内容如下：
					1,6,11,16,21,26,31,36,41,46,51,56 * * * * root command
					2,7,12,17,22,27,32,37,42,47,52,57 * * * * root command
					3,8,13,18,23,28,33,38,43,48,53,58 * * * * root command
					4,9,14,19,24,29,34,39,44,49,54,59 * * * * root command
					
					# 这些逗号隔开并且逗号左右没有空格符，刚好时间都是5分钟
						一次轮询，并且时间都岔开了
					# 1/5 * * * * root command
					# 2/5 * * * * root command
					# 3/5 * * * * root command
					# 4/5 * * * * root command
					# 这种范例不知可否实行？
			
			
		> 注意周月日冲突
			周字段与月和日只能择其一或都不选进行搭配，周不能同时和月日
			这三个并存，会造成系统误解
			范例：
			30 12 11 9 5 root echo "just test"
			会让系统个人为每年的9月11号执行或者每周5也执行
			
		> 可唤醒性停机期间工作任务(anacron)
		
			# cron 服务每个小时执行 anacron，然后 anacron 以预设一天、七天
				一个月为期去侦测相关的排程有没有执行，如果有超过期限的工作
				，就执行该排程，执行完毕后无须执行任何排程时 anacron 就停止
				
			# anacron 其实是一支程序而不是一个服务，这个程序在CentOS中已经
				进入crontab的排程，同时anacron会每个小时被主动执行一次，所
				以anacron的配置脚本应该放在/etc/cron.hourly中
				
				通过 cat /etc/cron.hourly/Oanacron 查看脚本内容
			
			语法：
				anacron [-sfn] [job]...
				anacron -u [job]...
					命令选项：
						-s	# 开始一连续的执行各项工作(job)，会依据时间记录文件
								的数据判断是否进行
						-f	# 强制进行，而不去判断时间记录文件的时间戳
						-n	# 立刻进行未进行的任务，而不延迟(delay)等待时间
						-u	# 仅更新时间记录文件的时间戳，不进行任何工作
						job	# 由/etc/anacrontab定义的各项工作名称
						
			
	* SELinux 运作模式
	
		# 由于在某些有权限身份的用户在没有维护性质的使用系统造成资源问题以及系统
			问题，SELinux 给予其权限限制的功能
		
		> 两种权限验证模式		
			>> DAC(Discretionary Access Control) 自主式访问控制，当某个进程想对资源
				进行存取时，系统会根据该进程的拥有者/群组，并比对文件的权限，通过检
				验而决定执行与否
				风险：
					1. 如果不小心某只进程被有心人士取得，该进程刚好属于 root 的权限，
						那么这个进程可以任意更改东西
					2. 不小心将某个目录或文件的权限设置为了 777，由于对任何人都有任意
						权限，因此这个目录或文件可能被不法利用
			>> MAC(Mandatory Access Control) 委任访问控制，即使是 root 在使用不同进
				程时取得的权限也不一定是 root。要看当时进程设定而定。如此一来控制的
				主题变成了进程而非使用者。此外这个主题进程也不能任意使用系统文件资源
				啊。因为每个文件资源有针对主题进程设定可取用权限。
				
		> SELinux 运作概况
			>> 主体(Subject)
				SELinux 主要看管理的进程，可以将主题跟 process 划上等号
			>> 目标(Object)
				主体进程能够取得[目标资源]一般就是文件系统，因此这个目标项目可以
				跟文件系统划等
			>> 政策(Policy)
				由于进程与文件数量庞大，因此根据服务指定安全政策，政策内还有详细
				的规划(rule)指定不同服务开放不同的资源，Centos7.x仅仅提供三个主要
				政策：
				1. targeted：针对网络服务限制较多，针对本机限制较少，与预设政策
				2. minimum：由 target 修订而来，仅针对选择的进程来保护
				3. mls：完整的 SELinux 限制，限制方面较为严格
			>> 安全性文本(security context)
				主体与目标的安全性必须一致才行，这个安全性文本类似为 rwx
				
		> 示意图:
			主体(Subject)就是程序 -- 要求 --.--> SELinux --> 安全性文本比对--.-- YES --> 目标(Object)资源存取(能否存取还要看rwx)
											|								 |
											分析政策						 NO
											规则							 |
											|								 |
											v								 v
									政策(Poliy)								AVC
										Rule1								拒绝存取
										Rule2								的讯息说明
										...
		
		
		
		
** 系统服务

	# 服务成为 service ，达成 service 服务的程序成为 daemon
	# 在厂商开发服务的时候，通常这个服务都会在名字后面加上一个 d,例如：
		crond，atd分别是 crontab 命令和 at 命令的服务
		
	* init 管理服务机制	
		> 服务的启动、关闭与观察等方式
			>> 所有服务启动脚本通通放置于 /etc/init.d/ 目录下，基本都是 bash script
				所写的脚本，需要启动、关闭、重启、观察状态时可以如下方式处理：
				启动：/etc/init.d/daemon start
				关闭：/etc/init.d/daemon stop
				重启：/etc/init.d/daemon restart
				状态观察：/etc/init.d/daemon status
		
		> 服务启动分类
			>> 独立启动模式(stand alone)：服务独立启动，该服务常驻于内存里，提供本机
				或用户的服务行为，反应速度快
			>> 总管程序(super daemon)：由特殊 xinetd 或 inetd 这两个总管程序提供 
				socket 对应或 port 对应的管理。对于用户要求的某 socket 或 port 时，
				才由 super daemon 管理帮助开启，结束时帮助停止。一切有 super daemon
				管理。缺点是环形服务需要时间的延迟
				
		> 服务的依赖性
			>> 服务与服务之间很有可能有依赖性，所以有依赖的服务，如果被依赖的服务
				没有开启，那么对应的依赖于它的服务也就无法实行
	
		> 执行等级
			init 是开机后核心主动呼叫的，等级有 7 个
				0：
				1：单人维护模式
				2：
				3：纯文本模式
				4：空置(为以后作要求)
				5：图形界面
				6：
			各个执行等级的启动脚本是透过 /etc/rc.d/rc[0-6]/SXXdaemon 连接到 
			/etc/init.d/daemon 的。连接档名(SXXdaemon)的功能为：S 为启动该服务，XX是
			数字，为启动的顺序。由于有SXX 的设定。因此在开机时可以依序执行所有需要的
			服务，同时也能够解决相依服务的问题
		
			# Linux 的 CentOS7 已经不支持由 init 管理启动了
		
		> 指定执行等级默认要启动的服务
			透过指令可以处理默认启动、预设不启动、观察预设启动与否的行为：
			预设启动：chkconfig daemon on
			预设不启动：chkconfig daemon off
			观察预设启动与否：chkconfig --list daemon
			
		> 执行等级切换行为
			当从文本界面 runlevel 3 切换到图形界面 runlevel 5,不需要手动启动、
			关闭该执行等级相关服务，只要 init 5 即可。它会中东分析 /etc/rc.d/rc3.d/
			和 /etc/rc.d/rc5.d/ 这两个目录内的启动切换
	
	* systemd 使用的 unit 分类
	
		# 从 CentOS 7.x 开始改用 systemd 启动服务管理机制
		
		> 平行处理所有服务，加速开机流程
			旧的init 启动脚本是一项一项任务依序启动，不管是否有依赖都是一个一个
			的等待并启动，现在的 system的可以并发处理启动
			
		> 已经要求就相应的 on-demand 启动方式
			systemd 全部就只有 systemd 服务搭配 systemctl 指令处理。无须其它指令
			不想 systemV 的要init,chkconfig,service...等等指令。因为 systemd常驻
			于内存，因此任何要求都可以立即处理后续的 daemon 启动任务
		
		> 服务相依自我检查
			自动检查依赖性，去启动依赖但未开启的服务
			
		> 一个服务定义为一个服务单位(unit)，并将该 unit 归类到不同的服务类型(type)去。
		
		> 将多个 daemons 集合成一个群组，即所谓的 target 项目。这个项目主要在设计操作系统环境的设定，
			是集合了许多 daemons，亦即是执行某个 target 就相当于执行了好多个 daemon 的意思
		
		> 向下兼容旧有的 init 服务脚本(但是无法完全取代 init)
		
		# 注意
			1. 在 runlevel 对应上，大概只有 runlevel 1，3，5对应到 systemd 的某些 target 类。
			2. 全部的systemd 都用 systemctl 这个管理程序管理，而 systemctl 支持的语法有限制，
				不可自定义参数
			3. 如果某个服务是管理员自己手动执行启动，而不是 systemctl 去启动的，那么 systemctl
				无法侦测到这个服务
			4. systemd 启动过程中无法与管理员透过 standard input 传入讯息，因此自行设定启动的时
				候应该取消互动机制
	
	* systemd 的配置文件放置目录
	
		/usr/lib/systemd/system/	# 每个服务的主要启动脚本目录，类似于以前的/etc/init.d/底下的文件
		/run/systemd/system/		# 系统执行的过程中所产生的服务脚本，这些脚本的优先级比 
										/usr/lib/systemd/system/ 高
		/etc/systemd/system/		# 管理员依据主机系统需求所建立的执行脚本，这个目录类似于以前的
										/etc/rc.d/rc5.d/Sxx 之类的功能，优先级比 /run/systemd/system/
										高
										
		# 系统开机是否执行的某些服务决定于 /etc/systemd/system/ 底下的脚本设定，这里面的脚本才连接相
			应的服务执行脚本，即 /usr/lib/systemd/system/
			
		# ls /usr/lib/systemd/system/ | grep -E '(vsftpd|multi|cron)'
			-rw-r--r--. 1 root root 284 7月 30 2014 crond.service
			-rw-r--r--. 1 root root 524 3月 6 13:48 multi-user.target
			
			对结果的扩展名解析：
				.service	# 一般服务类型，主要是熊服务
				.socket		# 内部程序数据交换的插槽服务，主要是 IPC
				.target		# 执行环境类型的 unit 的集合，相当于执行这一个服务就执行了很多 daemon
				.mount		# 文件系统挂载相关服务(automount unit / mount unit)
				.automount	# 同上
				.path		# 侦测特定文件或目录类型
				.timer		# 循环执行的服务，有点类似 anacrontab 不过是 systemd 主动提供的，比
								anacrontab 更加有弹性
	
	* systemd 指令
	
		> 对单一服务操作
			systemctl [command] [unit]
				command 主要有：
					start		# 立即启动后面的服务
					stop		# 立即关闭后面的服务
					restart		# 立即关闭后再启动后面的服务
					reload		# 不关闭服务，但是重载配置文件，让设定生效
					enable		# 设定开机自启
					disable		# 设定开机不自启
					status		# 查询服务状态，会列出是否正在执行，开机是否预设登录等信息
					is-active	# 目前是否运行中
					is-enable	# 开机是否自启
				unit 主要有：
					都是 /usr/lib/systemd/system/ 文件夹下的系列服务
					
				# 通过查询出来的 dasemon 的状态包括
					active(running)：运行中
					active(exited)：进执行一次就正常结束的服务
					active(waiting)：正在执行中，不过正等待其它事件完成后才能继续
					inactive：这个服务目前没有运作
				# dasemon 的预设状态
					enabled：开机自启
					disabled：开机不自启
					static：这个 dasemon 不可以自己启动(enable 即是不可)，可能会被其它 enabled 服务唤醒
					mask：这个 daemon 无论如何都无法被启动，因为已经被强制注销(非删除)，可投过
							systemctl unmask 方式改回原来状态
			
		> 对系统上所有服务的操作
			systemctl [command] [--type=TYPE] [--all]
				command：
					list-units			# 依据 unit 列出目前有启动的 unit。若加上 --all 才会列出没启
											动的
					list-unit-files		# 依据 /usr/lib/systemd/system/ 内的文件，将所有文件列表说明
					
				--type=TYPE：
					TYPE 就是之前提到的 unit type ，主要有 service, socket, target 等
					
				# systemctl 命令不加热河参数，相当于是 list-units 的意思	
					
				# systemctl 命令查询出的项目意义：	
				
					UNIT：项目名称，包括各个 unit 的类别(查看扩展名)
					LOAD：开机是否加载，默认 systemctl 显示的是由加载的项目
					ACTIVE：目前状态，须后续的 SUB 搭配，就是用 systemctl status 观察时，
								active的项目
					DESCRIPTION：详细描述
					
		> systemctl 管理不同环境服务
		
			>> systemctl 默认有 26 个 target 类型的服务,主要的有如下：
				1. graphical.target：图形界面服务，包含了 multi-user.target
				2. multi-user.target：纯文本模式
				3. rescue.target：在无法使用 root 登入情况下，systemd 在开机时会多加一个额外的暂时系
					统，与原本系统无关。可以使用这个系统取得 root 的权限来维护系统。因为是额外的系统
					可能需要动到 chroot 方式来取得原来的系统
				4. emergency.target：谨记处理系统错误，还是需要 root 登入的情况，在无法使用 
					rescue.target 的情况下可以使用这个模式
				5. shutdown.target：关机流程
				6. getty.target：设定需要几个 tty 之类的，如果要降低 tty 的项目，可以修改这个东西的
					配置文件
					
			>> 正常模式是 multi-user.target 以及 graphical.target；救援模式主要是 recue.target 以及
				更严重的 emergency.target。如果要修改可提供登入的 tty 数量，则修改 getty.target 项目
				
			>> systemctl [command] [unit.target]
			
				command：
					get-default		# 取得目前的 target
					set-default		# 设定后面接的 target 成为默认的操作模式
					isolate			# 切换到后面接的模式
					
				范例：
					systemctl get-default					# 查看当前的 target 模式
					systemctl isolate multi-user.target		# 切换到 multi-user.target 模式
			
			>> systemtcl 的简单工作切换模式
				systemctl poweroff		# 系统关机
				systemctl reboot		# 重启系统
				systemctl suspend		# 进入暂停模式
				systemctl hibernate		# 进入休眠模式
				systemctl rescue		# 强制进入救援模式
				systemctl emergency		# 强制进入紧急救援模式
	
				# supend	暂停模式会将系统的状态数目保存到内存中，关闭大部分的系统硬件，并不会关机
							当用户唤醒及其时，系统数据会重内存中恢复，然后重新驱动被关闭的大部分硬件
							就开始正常工作！唤醒速度快
				# hibernate	休眠模式是将系统状态保存到硬盘中，保存完毕后将计算机关机。当用户尝试唤醒
							系统时，系统会开始正常运作。然后将保存在硬盘中的系统状态恢复回来，因为数
							据是由硬盘读出，因此唤醒的效能与硬盘速度有关
					
			>> 通过 systemctl 分析各服务之间的依赖性
				systemctk lisi-dependencies [unit] [--reverse]
					命令选项：
						--reverse：反向追踪谁使用这个 unit 的意思
						
					# 不加 --reverse 是指定 unit 依赖了哪些 unit,
						加了以后就是 指定 unit 被谁依赖	
						
			>> systemd 的 daemon 御座过程相关的目录简介
				/usr/lib/systemd/system/	# 默认服务启动脚本配置文件位置
				/run/systemd/system/		# 系统执行过程中产生的服务脚本，这些脚本优先级比删一个要
												高
				/etc/systemd/system/		# 管理员依据主机系统的需求所建立的执行脚本，这个目录类似
												于以前的 /etc/rc.d/rc5.d/Sxx 之类的功能，优先级比上
												一个要高
				/etc/sysconfig/*			# 几乎所有的服务都会价格初始化的一些选项设定写入到这个目
												录
				/var/lib/					# 一些会产生数据的服务都会将数据写入到 /var/lib 目录中。
												例如数据库 mysql 就是将数据写入 /var/lib/mysql 中
				/run/						# 放置很多 daemon 的暂存档，包括 lock file 以及 PID file
				
				systemctl list-sockets		# 查看关于 socket 服务产生的服务文件放置的地方
				
			>> 网络服务与端口号简介
				cat /etc/services			# 可以查看每个服务和对应端口号的信息，当然也可以更改对应
												的端口号，但是不建议这么做，有可能会造成协议错误

** 日志管理
	
	* 系统发生的系列信息会记录在登录档文件中，常见的登录档档名有以下这些：
	
		/var/log/boot.log	# 开机时系统核心回去侦测与气动硬件，接下来开始各种核心支持的功能启动
			。这个文件只记录本次开机时的信息，前次开机的信息不会记录
		
		/var/log/cron		# crontab 排程有没有实际进行，以及进行的情况都会记录在这里
		/var/log/dmesg		# 记录开机时的核心侦测过程产生的各项信息，这些信息默认是显示的，所以就记
								录在这里了
		/var/log/lastlog	# 可以记录系统上面所有的账号最近一次登入系统时的相关信息
		/var/log/maillog 或 /var/log/mail/*	# 记录邮件的往来信息，其实主要是邮件接收方以及邮件发送
												方的信息
		/var/log/messages	# 这个文件相当重要，几乎系统发生的错误讯息都会记录在这个文件中国系统发生
								莫名的错误的时候，可以查看这个文档以查看错误信息
		/var/log/wtmp , /var/logfaillog		# 这两个文件可以记录正确登录(wtmp)系统的账户信息与错误登
												入(faillog)时所使用的账户信息,						
		/var/log/httpd , /var/log/samba/*	# 不同的网络服务也会使用它们自己的登录文件来记载它们自己
												成圣的各项讯息，上述目录内则是个别服务所指定的登录档										
	
		
	* 针对登录文件所需要的服务与程序有：
	
		> systemd-journald.service	# 主要的讯息收受者，由 systemd 提供的
		> rsyslog.service			# 主要登录系统与网络服务的讯息
		> logrotate					# 主要在进行登录文件的轮替功能(日志文件会越来越大，所以会根据情
										况分开存或者覆盖以前的文档)
			
		> 所有经由 aystemd 启动或结束的过程发生的问题或正常的讯息会经由 system-journald.service 以二
			进制的方式记录下来，之后再将这个讯息发送给 rsyslog.service 作进一步的记载
			
			
		> 服务类型可以查看 man 3 syslog 或者查看 syslog.h
			主要有以下几个：
			0 kern(kernel)
			1 user
			2 mail
			3 daemon
			4 auth
			5 syslog
			6 lpr
			7 news
			8 uucp
			9 cron
			10 authpriv
			11 ftp
			16~23 local0 ~ local7
			
		> 登录档记录日志必须符合某种规范，规范是 rsyslogd 这个 daemon 的配置文件的内容要求
			/etc/rsyslog.conf
			
			要求格式：
				服务名称[.或=或!]讯息登记	讯息记录的文件名或装置或主机
			连接符：
				“.”		# 代表比指定等级高(包含指定等级)的日志才记录下来
				“.=”	# 代表等级必须等于指定的等级才记录下来
				“.!”	# 代表不等于指定的等级才记录下来
				“.none”	# 根本不输出任何日志
			
		> 日志输出目的
			>> 文件的绝对路径：通常放在 /var/log 里头的文件里
			>> 打印机或其它：例如 /dev/lp0 这个打印机装置
			>> 使用者名称：显示给用户
			>> 远程主机：例如 @study.vbird.tsai ，对应的对方主机也要能支持才行
			>> *：代表目前在在线的所与人，类似 wall 这个指令的意思
			
		> 范例：
			mail.*		-/var/log/maillog
			cron.info	/var/log/cron
			
			解析：
				第一行表示邮件的日志输出在 /var/log/maillog ，在地址钱有一个“-”是应为
				邮件日志很多，先存在缓冲区，等到容量比较大的时候再存入。当然这是存在内存中
				如果当机会有部分数据损失
				
				得二行表示关于 cron 的信息等级要大于等于 info 才保存在 /var/log/cron 中
		
		> rsyslogd 本身就具有文件服务器的功能。只是默认没有启动该功能。 可以透过 man rsyslogd
			查询相关的选项就知道详情了，既然是登录详情那么就肯定有监听的端口了，那个端口就是
			UDP 或 TCP 的 514 端口
			
			案例：有 10 台 Linux 主机，但是都需要记录他们的日志信息，那么可以将一台主机作为 Service
				端，其它九台作为 Client 端，并且 Client 端的日志发送到 Service 端进行记录即可
			
			服务器会启动监听的端口，客户端则将登录档在传出一份送到服务器去。既然是登录档服务器，所以
			当然有服务器与客户端！这两者的设定分别是这样的：
			
				Server 端：修改 rsyslogd 的启动配置文件，在 /etc/rsyslog.conf 内
					找到底下这几行：
						# Provides UDP syslog reception
						#$ModLoad imudp
						#$UDPServerRun 514
						
						# Provides TCP syslog reception
						#$ModLoad imtcp
						#$InputTCPServerRun 514
						
						# 上面的是 UDP 端口，底下的是 TCP 端口，如果你的网络状态很稳定，就用 UDP
							如果你想要让数据比较稳定传输，那么建议使用 TCP ，所以只需要解开其中一种
							注释即可
							
							修改完配置文件后要让 rsyslog.service 重新启动
							
							透过以上的配置那么这台机器就可以接收其它主机的登录讯息了。
							
				Client 端：只要设定某个信息传送到这部主机即可，举例以上那个服务端的 ip 为 192.168.1.100
					而 client 端希望所有的数据都传送给主机，所以修改 /etc/rsyslog.conf
					
						*.*		@@192.168.1.100
						#*.*	@192.168.1.100		# 若用 UDP 传输，设定要设置成这行来设定
						
						# 注意修改完配置文件之后要重新启动服务
						
	* 日志的轮替(logrotate)
	
		* 在规定时间的时候进行日志轮替，那么这个 logrotate 程序当然就是挂在 cron 
			底下进行的。/etc/cron.daily/logrotate 就是记录每天要进行轮替的行为
			
			第一次：messages -- 1 --> messages.1
			第二次：messages -- 2 --> messages.1 -- 1 --> messages.2
			第三次：messages -- 3 --> messages.1 -- 2 --> messages.2 -- 1 --> messages.3
			第四次：messages -- 4 --> messages.1 -- 3 --> messages.2 -- 2 --> messages.3 --> 删除
			
			# 把以前的 messages 信息用数字递增，然后创建一个空的 messages 供新的日志记录
			
		* logrotate 的配置文件：
			/etc/logrotate.conf
			/etc/logrotate.d/
			
			# /etc/logrotate.conf 是主要的参数文件，至于 logrotate.d 是一个目录，这个目录里面的文件
				会主动的读入 /etc/logrotate.conf 当中来进行！另外，在 /etc/logrotate.d/ 目录里的文件
				没有规定到的一些细部设定，则以 /etc/logrotate.conf 这个文件的规定来指定为默认值
				
				vim /etc/logrotate.conf
				
				# 底下设定是 "logrotate 的预设值" ，如果个别的文件设定了其它参数
				# 则将以个别的文件设定为主，若该文件没有设定到的参数则以这个得内容为默认值
				
				keekly		# 预设每个礼拜对登录档进行一次 rotate 的工作
				rotate 4	# 保留几个登录档，预设是保留四个
				create		# 由于登录档被更名，因此建立一个新的来继续存储
				dateext		# 就是这个设定值，可以让被轮替的文件加上日期作为档名
				#compress	# 被更动的登录档是否需要压缩？如果登录档太大则考虑此参数启动
				
				include /etc/logrotate.d
				# 将 /etc/logrotate.d/ 这个目录中的所有文件都读进来执行 rotate 的工作
				
				/var/log/wtmp {					# 仅针对 /var/log/wtmp 所设定的参数
					monthly						# 每个月一次，取代每周
					create 0664 root utmp		# 指定信件文件的权限与所属账号/群组
					minisize 1M					# 文件熔炼公钥超过 1M 后才进行 rotate (略过时间参数)
					rotate 1					3 仅保留一个，亦即仅有 wtmp.1 保留而已
				}
			
				# 这个 wtmp 可记录登入者与系统重新启动时的时间与来源主机及登入期间的时间
				# 由于具有 minsize 的参数，因此不见得每个月一定会进行一次，要看文件容量
				# 由于仅保留一个登录档而已，不满意的话可以将他改成 rotate 5
				
		* 如果每个服务都有自己的设定，都去修改 /etc/logrotate.conf 是不合理的，所以每个服务有
			自己的设定。设定格式为：
			登录文件的绝对路径文件名 {
				个别参数设定值，如 monthly, compress 等等
			}
			
			
	
** 日志管理

		* 简介：
			在CentOS 6.x 中日志服务已经由rsyslogd取代了原来的syslogd服务。
			rsyslogd日志服务更加先进，功能更多。但是不论该服务的使用，还是
			日志文件的格式其实都是和syslogd服务相兼容的，所以学习起来基本
			和syslogd服务一致
		
			> 特点：
				>> 基于TCP网络协议传输日志信息
				>> 更安全的网络传输方式
				>> 有日志消息的及时分析框架
				>> 后台数据库
				>> 配置文件中可以写简单的逻辑判断
				>> 与syslog配置文件相兼容
				
			> 确定服务启动
				>> ps aux | grep rsyslogd	# 查看服务是否启动
				>> chkconfig --list | grep rsyslog	# 查看服务是否自启动
				
			> 常见日志的作用
				>> /var/log/cron	# 记录了系统定时任务想孤单的日志
				
				>> /var/log/cups/	# 记录了打印信息的日志
				
				>> /var/log/dmesg	# 记录了系统在开机时内核自检的信息，也
					可以使用dmesg命令直接查看内核自检信息
					
				>> /var/log/btmp	# 记录错误登录的日志。这个文件是二进制
					文件，不能直接vi查看，而要使用lastb命令查看，命令如下：
					[root@localhost log]# lastb
					root	tty1	Tue Jun 4 22:38 - 22:38 (00:00)
					# 有人在6月4日22:38使用rooot用户，在本地终端1登录错误
					
				>> /var/log/lastlog	# 记录系统中所有用户最后一次的登录时间
					的日志。这个文件也是二进制文件，不能直接vi，而要使用
					lastlog命令查看
					
				>> /var/log/message	# 记录系统重要信息的日志。这个日志文件
					中会记录Linux系统的绝大多数重要信息，如果系统出现问题，
					首先要检查的就应该是这个日志文件
					
				>> /var/log/secure	# 记录验证和授权方面的信息，只要涉及账
					户和密码的程序都会记录。比如说系统的登录，ssh的登录，su
					切换用户，sudo授权，甚至添加用户和修改用户密码都会记录
					在这个日志文件中
					
				>> /var/log/wtmp	# 永久记录所有用户的登录、注销信息，同时
					记录系统的启动、重启、关机事件。同样这个文件也是一个二进
					制文件，不能直接vi，而需要使用last命令来查看
					
				>> /var/run/utmp	# 记录当前已经登录的用户的信息。这个文件
					会随着用户的登录和注销而不断变化，只记录当前登录用户的信
					息。同样这个文件不能直接vi，而要使用w，who，users等命令
					查询。
				
				# 采用RPM方式安装的系统服务也会默认把日志记录在/var/log目录中
					(源码包安装的服务日志是源码包指定目录中)。不过这些日志不是
					由rsyslogd服务来记录和管理的，而是各个服务自己使用自己的日
					志管理文档来记录自身的日志
					
		* rsyslogd日志服务
			> 日志文件格式
				>> 事件产生的时间
				>> 发生事件的服务器的主机名
				>> 产生事件的服务名或程序名
				>> 时间的具体信息
		
			
					
			> /etc/rsyslog.conf 配置文件
			
				>> 范例：authpriv.*					/var/log/secure
					# 服务名称[连接符号]日志等级	日志记录位置
					# 认证相关服务.所有日志等级		记录在/var/log/secure日志中
		
					# “*”如果卸载日志等级处代表所有日志等级，比如：“authpriv.*”
						代表authpriv认证信息服务产生的日志，所有的日志等级都记录
						(这个其实不是连接符，只是特殊符号)
						
					# “*”如果卸载服务名称位置代表所有服务	
				>> 服务名称：
					auth：安全和认证相关消息(不推荐使用authpriv替代)
					authpriv：安全和认证相关消息(私有的)
					cron：系统定时任务cront和at产生的日志
					daemon：和各个守护进程相关的日志
					ftp：ftp守护进程产生的日志
					kern：内核产生的日志(不是用户进程产生的)
					local0-local7：为本地使用预留的服务
					lpr：打印产生的日志
					mail：邮件收发信息
					news：与新闻服务器相关的日志
					syslog：有syslogd服务产生的日志信息(虽然服务名称已经
						改为rsyslogd，但是很多配置都还是沿用了syslogd的
						，这里并没有修改服务名
					user：用户等级类别的日志信息
					uucp：uucp子系统的日志信息，uucp是早期linux系统进行数
						据传递的协议，后来也常用在新闻组服务中
						
				>> 连接符号：
					
					“.”代表只要比后面的等级高的(包含该等级)日志都记录下来
						比如：“coron.info”代表cron服务产生的日志，只要日志
						等级大于等于info级别，就记录
					“.=”代表值记录所需等级的日志，其它等级的都不记录。比如
						“*.=emerg”代表认和日志服务产生的日志，只要等级是
						emerg等级就记录。这种用法极少见，了解就好
					“.!”代表不等于，也就是除了该等级的日志外，其它等级的日
						志都记录
				
				>> 日志等级
				
					none：表示没有等级
					
					debug：一般的调试信息说明
					info：基本的通知信息
					notice：普通信息，但是有一定的重要性
					warning：警告信息，但是还不会影响到服务或系统的运行
					err：错误信息，一般达到err等级的信息以及可以影响到服务或
						系统的运行了
					crit：临界状况信息，比err等级还要严重
					alert：警告状态信息，比crit还要严重，必须立即采取行动
					emerg：疼痛等级信息，系统已经无法使用了
	
					
					# 以上等级从上往下是从低到高，等级越高纪录的信息越少，优先
						处理的级别却更高，危害也更大
						
				>> 日志纪录位置
					1. 日志文件的绝对路径，如“/var/log/secure”
					2. 系统设备文件，如“/dev/lp0”
					3. 转发给远程主机，如“@192.168.0.210:514”
					4. 用户名，如“root”
					5. 忽略掉丢弃日志，如“~”
					
		* 日志轮替
			> 简介：
				日志会因为记录越来越大，为了解决这个问题所有的方法：
				>> 日志切割
					# 按照一定的时间或大小设定，到了时间或大小改为下一个文件记录
				>> 日志轮替
					# 满了多少时间或大小，删除旧日志记录，从而记录新日志信息
			
			> Linux日志轮替规则
			
				>> 如果配置文件中拥有“dateext”参数，那么前一天的日志会用日期来作
					为文件后缀，并且今天的日志用原名命名
					范例：
						如果2016-01-01有一个日志叫做“secure”，那么第二天时，这个
						日志名为“secure-20160101”，那么几天的日志名为“secure”，
						再过一天则之前都以时间做后缀，当日的用原名命名
						
				>> 如果配置文件中不拥有“dateext”参数，当过了一天后，当日用原名命
					名，前一天以“.1”作为后缀，再前一天的用“.2”作后缀，依次类推
					范例：
						如果2016-01-01有一个日志叫做“secure”，那么第二天的日志名
						为“secure”，前一天的名字改为了“secure.1”，到了第三天时，
						当天的为“secure”，之前的“secure”改为了“secure.1”，
						“secure.1”变为了“secure.2”
			
				>> rpm包安装的不需要手动轮替，只有源码包的需要手动指定轮替，因为
					源码包的日志目录是rpm管理不到的
					
			> 配置文件
				>> /etc/logrotate.conf
					解析：
						daily：日志的轮替周期是每天
						weekly：日志的轮替周期是每周
						monthly：日志的轮替周期是每月
						rotate 数字：保留的日志文件的个数。0指没有备份
						compress：日志轮替时，旧的日志进行压缩
						create mode owner group：建立新日志，同时制定新日志的权限与
							所欲这和所属组。如 create 0600 root utmp
						mail address：当日志轮替时，输出内容通过邮件发送到指定的邮件
							地址。如mail shenc@lamp.net
						missingok：如果日志不存在，则忽略该日志的警告信息
						notifempty：如果日志为空文件，则不进行日志轮替
						minsize 大小：日志轮替的最小值。也就是日志一定要达到这个最小
							值才会轮替，否则就算时间达到也不轮替
						size 大小：日志只有大于指定大小才进行日志轮替，而不是按照时间
							轮替。如size 100k
						dateext：使用日期作为日志轮替文件的后缀。如secure-20130605
						
			> 命令轮替
				>> logrotate [选项] 配置文件名
					命令选项：
						# 如果没有选项则会按照配置文件中的条件进行日志轮替
						-v：显示日志轮替过程。加了-v选项，会显示日志的轮替的过程
						-f：强制进行日志轮替。不管日志轮替的条件是否已经符合，强制配置
							文件中所有的日志进行轮替



							
** 启动管理
	* CentOS6.x 启动管理
		> 系统运行级别
			0：关机
			1：单用户模式，可以想象为windows的安全模式，主要用于系统修复
			2：不完全的命令行模式，不含NFS服务(NFS是unix和linux文件共享的服务)
			3：完全的命令行模式，就是标准字符界面
			4：系统保留
			5：图形模式
			6：重启动
		
		> runlevel
			# 查询当前级别，结果有两个字段，第一个字段是数字或N，第二个字段
				表示当前级别，即从前面的字段的级别到当前的级别，如果有N表示
				空级别，即没有级别
			
		> init 级别		
			# 改变运行级别，这种级别不安全，相当于是断点不会保存相应信息	
			
		> 系统默认运行级别
			/etc/inittab	# 此文件有默认运行级别
			
		> 系统启动过程
			BIOS--加载-->MBR--加载-->MBR中启动引导程序--系单系统直接启动-->加载内核----------------------------------------------
												 |																				|
												 |																				|
												 --多系统-->调用其它分区启动山区中的启动引导程序--启动不同的操作系统-->加载内容--
																																|
																																|
			挂载真正系统根目录<----加载驱动<----建立伪真根目录<----找到initramfs<--搜索--内核解压并自检--------------------------									                                                                                
			|									 
			调用
			|
			v
			/sbin/init--调用-->/etc/init/rcS.conf--调用-->/etc/rc.d/rc.sysinit---->系统初始化
			|
			--调用-->/etc/inittab--传入运行级别-->/etc/init/rc.conf--调用-->/etc/rc.d/rc--按照运行级别调用---->/etc/rc[0-6].d
																															|
																															|
			进入系统<--输入用户名密码--登录界面<----/etc/rc.d/rc.local中的程序<--启动和关闭--按照优先级启动和关闭相应脚本<---																												
			
			# linux把常见的驱动都写入内核，不常见驱动放在硬盘下的lib中，
				所以当要运行内核中没有的驱动就要从硬盘中的/lib中取驱动。
				
			# 注意IDE硬盘驱动是linux内核中的，但是SATA以及SCSI是相当于
				额外的，即放在lib中的，那么会存在下述问题：
				1. 如果使用SATA或SCSI接口的硬盘
				2. 因为SATA和SCSI驱动是存放于在硬盘中而非内核
				3. 要认识SATA和SCSI硬盘必须加载驱动，驱动又在硬盘中，则
					造成了取硬盘取驱动方可认识硬盘，要取得驱动在硬盘中，
					现目前又不认识硬盘的矛盾
					
				# 所以linux的解决方案是通过initramfs-->建立伪真根目录-->加载驱动
					initramfs文件存在于/boot，即加载系统引导程序的时候就加载了。
					
					也就是说通过创建的伪真目录去寻找到了硬盘的真驱动
					
		> 有/etc/rc.d/rc.sysinit文件初始化
			1. 获得网络环境
			2. 挂载设备
			3. 开机启动画面Plymouth(取替了国王的RHGB)
			4. 判断是否启用SELinux
			5. 显示于开机过程中的欢迎画面
			6. 初始化硬件
			7. 用户自定义模块的加载
			8. 配置内核的参数
			9. 设置主机名
			10. 同步存储器
			11. 设备映射器及相关的初始化
			12. 初始化软件磁盘阵列(RAID)
			13. 初始化LVM的文件系统功能
			14. 检验磁盘文件系统(fsck)
			15. 设置磁盘配额(quota)
			16. 重新以可读写模式挂载系统磁盘
			17. 更新quota(非必要)
			18. 启动系统虚拟随机数生成器
			19. 配置及其(非必要)
			20. 清楚开机过程当中的临时文件
			21. 创建ICE目录
			22. 启动交换分区(swap)
			23. 将开启信息写入/var/log/dmesg文件中
			
		> /etc/rc.d/rc文件
			运行级别参数传入/etc/rc.d/rc这个脚本之后，由这个脚本文件按照
			不同的运行级别启动/etc/rc[0-6].d/目录中的相应的程序
			>> /etc/rc3.d/k??开头的文件(??是数字),会按照数字顺序依次关闭
			>> /etc/rc3.d/S??开头的文件(??是数字),会按照数字顺序依次启动
	* 启动引导程序grub
		> 提前基础：
			硬盘分		分区			Linux中设备文件名		Grub中设备文件名
			第			第一个主分区	/dev/sda1				hd(0,0)
			一			第二个主分区	/dev/sda2				hd(0,1)
			块			扩展分区		/dev/sda3				hd(0,2)
			SCSI		第一个逻辑分区	/dev/sda5				hd(0,4)
			硬盘
			
			第			第一个主分区	/dev/sdb1				hd(1,0)
			二			第二个主分区	/dev/sdb2				hd(1,1)
			块			扩展分区		/dev/sdb3				hd(1,2)
			SCSI		第一个逻辑分区	/dev/sdb5				hd(1,4)
			硬盘
			
			# IDE硬盘设备文件名识别为hd，SATA和SCSI硬盘识别为sd
			# 不管是IDE还是SATA还是SCSI硬盘，Grub都是别为hd
	
		> Grub配置文件
			
		> Grub加密与字符界面分辨率调整
		
	* 系统修复模式
