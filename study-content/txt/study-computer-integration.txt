
## 计算机组成原理 ##

- 层次结构
   - 计算机系统：软件，硬件
   - 系统的功能划分层次结构：
   - 高 -> 低
   - L5(M5)   | L4(M4)   | L3(M3)   | L2(M2)   | L1(M1)   | L0(M0)
   - 应用语言 | 高级语言 | 汇编语言 | 操作系统 | 传统机器 | 微程序
   - M0 微程序（固件）实现
   - M1 硬件实现
   - M2~M5 软件实现
      - 虚拟机器：以软件为主实现的机器
      - 实际机器：以硬件或固件实现的机器

* 进度
   - 清华大学 20 集
   - 哈尔滨工业大学 15 集
   - 10/ 25,26,27,28,29
   - 需要重新看的视频
      1. 哲学家通信的几种方式未记录 10
      2. 进程间的通信重新看 11

## 操作系统原理 ##

* 技术交流地址
   - Wiki： http://os.cs.tsinghua.edu.cn/oscourse/OS2015
   - 学堂在线： https://www.cuetangx.com/courses/TsinghuaX/30240243X/2015T1/about
   - 在线交流： https://piazza.com/tsinghua.edu.cn/spring2015/30240243x/home

* 内容大纲
   1. 操作系统结构
   2. 中断及系统调用
   3. 内存管理
   4. 进程及线程
   5. 处理机调度
   6. 同步互斥
   7. 文件系统
   8. I/O子系统

* 启动规范
   - BIOS
      - 固化到计算机评析上的程序
      - 包括系统设置、自检程序和系统自启动程序
      - BIOS-MBR，BIOS-GPT，PXE（这是一种通过网络下载内核并启动的方式）
   - UEFI
      - 接口标准
      - 在所有平台上一致的操作系统启动服务

* 中断，异常和系统调用
   - 概述
      - 中断（hardware interruput）：来自硬件设备的处理请求
      - 异常（exception）：非法指令或者其他原因导致当前指令执行失败（如：内在出错）后的处理请求
      - 系统调用（system call）：应用程序主动向操作系统发出的服务请求
   - 源头
      - 中断：外设
      - 异常：应用程序意想不到的行为
      - 系统调用：应用程序请求操作提供的服务
   - 响应方式
      - 中断：异步
      - 异步：同步
      - 系统调用：同步或异步
   - 处理机制
      - 中断：持续，对用户应用程序是透明的
      - 异步：杀死或者重新执行意想不到的应用程序指令
      - 系统调用：等待和持续

* 操作系统内核特征
   - 并发，共享，虚拟，异步

* 操作系统的五大功能
   - 资源管理
      - 处理机管理（硬件）（第一）
      - 存储器管理（硬件）（第二）
      - 设备管理（硬件）（第三）
      - 文件管理（软件）（第四）
   - 用户接口（第五）
      - 命令接口
      - 图形接口
      - 程序接口

* 微内核
   - 内存管理
   - I/O子系统
   - 网络协议栈
   - 设备驱动
   - 文件系统

* BIOS启动固件
   - CS:IP = 0Xf000:fff0（CS：代码寄存器；IP：指令指针寄存器）
   - 系统处于实模式
   - PC = 16*CS+IP
   - 20位地址空间：1MB

* 进程的特征
   - 进程结构：PCB进程控制块，程序段，数据段
      - PCB 是常驻内存的，且是进程存在的唯一标志，OS专门开辟PCB区将PCB组成队列或链表
   - 进程是由系统进行资源分配和调度的基本单位，进程也是竞争资源的基本单位
   - 进程的基本状态
      - 说明
         - 就绪状态和执行状态可以互相转换，执行状态可以到阻塞状态，阻塞状态只能到就绪状态
         - 状态的改变可以根据操作和时间片判断
      - 基本状态
         - 就绪状态：已经获取除了处理器但已经分配好了所有资源的状态，许多个就绪进程在一个就绪队列中等待cpu调用
         - 阻塞状态：进程在执行由于某些原因而等待下一步执行的情况，比如分配内存，I/O请求
         - 执行状态：进程在cpu正在处理的状态
      - 洐生状态
         - 引起原因
            1. 终端用户请求
            2. 父进程请求
            3. 负何调节需要
            4. 操作系统的需要
         - 挂起状态（静止的）
         - 非挂起状态（非静止的）
         - 最终线路转换图
         ```
                  ******执行状态
                  *     ^        *
                  *     *         *挂起
                  *     *          *
          I/O请求 *     *           *************|
                  *     *                 挂起   v
                  *     活动就绪（在内存）-----> 静止就绪（在外存，当前情况需要的资源都拥有了）
                  *       ^                            ^          
                  *       *               <-----       *  
                  *       * 释放          激活         * 释放      
                  *       *                            *   
                  v       *               激活         *   
                  活动阻塞（在内存） <--------------- 静止阻塞（在外存）
                                                   
                                     --------------->                       
                                          挂起                   
          活动阻塞到静止阻塞一般是负载过大而把一些不常用的放在外存并作为阻塞
         ```
   - 处理机的寄存器
      - 通用寄存器 8-32 个，暂存信息用（可以放数据也可以放指令）
      - 指令计数器，要访问的下一条指令地址
      - 程序状态字 PSW 条件码、执行方式、中断屏蔽标志
      - 用户栈指针，用户进程拥有的系统栈，存放过程和系统调用参数调用地址

   - 临界
      - 临界资源：一个时刻只能有一个进程，例如：打印机，磁盘，磁带
      - 临界区：每个进程中访问临界资源的那段程序，进程必须互斥进入临界区

   - 访问临界区的循环进程描述
      - 进入区：检查临界资源是否能访问
      - 临界区：让临界资源执行的程序
      - 退出区：将临界区标志设为未访问
      - 剩余区：
   - 同步机制遵循的原则
      - 空闲让进
      - 忙则等待
      - 有限等待
      - 让权等待
   - 信号量
      0. mutex 是通用信号量
      1. 整型信号量
         - 用 S 表示整型数（小于等于0表示不可用，大在于0才表示可用）
         - P操作（wait）原语，V操作（signal）原语
         - 结构和分析
            ```
            Wait 原语：先等待，再循环检测S是否小于或等于0,是则继续检测，否则让S减一
            Wait(S):
               while S<=0 do no-op
                     S:=S-1;

            Signal 原语：释放
            Signal(S):
                     S:=S+1;
            ```
         - 优点和缺点
            - 优点：wait(s) 和 signal(s) 是原子操作
            - 缺点：要信号量S<=0就不断测试，不满足让权等待
      2. 记录型信号量
         - 包含两个数据项：包含两个数据项
         - 结构和分析和处理
            - 一些名词
               - s 表示某一个资源的信号量，比如表示打印机，磁盘等
               - S 为信号量的名字
               - S.value 为资源信号量其初值：某类资源的数目
                  - 大于等于零时，代表系统当中可用资源的数目
                  - 小于零时，绝对值代表等待使用资源的进程个数
               - S.list 表示阻塞链表，当进程申请使用资源的时候申请不到就进入这个链表
               - wait操作：申请一个单位资源
               - signal操作：释放一个单位资源
            - 结构和分析
               ```
               一个数据结构：结构里有一个整型和一个PCB链表
               type semaphore=record
                             value:integer;
                             L:list of process;
                             end

               申请资源的流程
               Procedure wait(s) // s 表示哪一个类资源的信号量，比如打印机，磁盘等
               Var S:semaphore; // 声明一个变量S为信号量类型
               begin
                  S.value:=S.value-1;
                  If S.value<0 then block(S,L) // 如果S.value<0时执行block原语，
                                                  block原语表示把一个进程放入阻塞队列，
                                                  s表示信号量（即哪类资源，是打印机还是硬盘等），
                                                  L是阻塞链表（等待信号s的链表）
               end

               释放一个单位资源
               Procedure signal(s)
               Var S:semaphore;
               begin
                  S.value:=S.value+1;
                  If S.value<=0 then wakeup(s,L) // 因为S.value<=0 表示有阻塞进程，但是又因为这个处理逻辑
                                                    是释放逻辑，所以一个释放后需要让阻塞中唤醒一个进程
               end
               ```
            - 缺点：如果有两个资源S1与S2，两个进程A与B，A按顺序占S1,S2；B按顺序占S2,S1，那么可能引发死锁
      3. AND 型信号量
         - 将进程在整个运行中需要的所有资源，一次性全部分配给进程，待进程使用完后一起释放
         - 在 wait 中加入 AND 条件，又称 AND 同步或同时wait操作：Swait
         ```
         申请资源
         当发现第一个Si<1就把该进程放入等待队列并将其程序计数器置于 Swait 操作的开始位置
         Swait(S1,S2,...Sn)
         If S1>=1 and S2>=1 and ... Sn>=1 then
            for i:=1 to n do
            Si:=Si-1;
            endfor
         else
         endif

         释放资源
         将所有等待Si的进程由等待队列取出放入到就绪队列
         Ssingal(S1,S2,...Sn)
            for i:=1 to n do
               Si:=Si+1;
            Endfor;

         ```
      4. 信号量级
         - 通用信号量，可以根据参数不同改变为以上的几种信号量

   - 信号量实现互斥
      - 模型
      ```
      Var mutex:semaphore:=1; // 设置初始值，互斥的意思

      进程1执行的过程
      Begin
         Parbegin 部分开始
         Process1:begin
                 repeat // 循环
                    wait(mutex);       // 申请资源，进入区
                    critical section   // 进入临界区代码
                    signal(mutex);     // 释放资源，退出区
                    remainder section  // 剩余区代码
                 until false;
                  end;

      进程2执行的过程
      Process2:begin
               repeat
                  wait(mutex);
                  critical section
                  signal(mutex);
                  remainder section
               until false;
               end;
      parend
      ```

- 进程的一些问题
   - 互斥问题
      - 互斥指进程与进程之间对资源申请的唯一，资源在被一个进程使用时不允许其它进程使用
      - 在实现互斥时应注意 wait(mutex) 和 signal(mutex) 必须成对地出现，缺wait(mutex)将会引起系统混乱，不能保证对临界资源的互斥访问
   - 生产者一消费者问题
      - 生产者和消费者是指，数据在放入和取出时的唯一，取出时不能放入；放入不能取出；不能取空缓冲池；不能放入到满缓冲池且未被取出的缓冲池
      - 有一个缓冲池作为信息的处理和放入，生产者不能对一个已经满了且没有取走的池放数据，消费者不能对一个空池取数据
      ```
      Var mutex:semaphore:=1; // 设置初始值，互斥的意思
      empty:信号量=n;      // 表示缓冲区中空的个数
      full:信号量=0;        // 表示缓冲区中非空的个数

      // 生产者
      Procedure:begin
               repeat
               ...
               procedure an item nextp; // 生产一个产品数据
                  ...
                  wait(empty);          // 申请数据，将空个数减一
                  wait(mutex);          // 判断能不能往缓冲区放数据
                  Buffer(in):=nextp;    // 把生产的数据放到缓冲区池中下标是in的位置（临界区）
                  in:(in+1) mod n;      // 指针移动，指向下一个准备放数据的位置（临界区）
                  signal(mutex);        // 释放缓冲池
                  sinal(full);          // 将非空个数加一
               until false;
                 end;

      // 消费者
      Consumer:begin
               repeat
                  wait(full);           // 判断非空缓冲区个数
                  wait(mutex);          // 判断有没有生产者进程在放数据
                  nextc:=Buffer(out);   // 取出下标是out的非空缓冲区的数据(临界区）
                  out:=(out+1) mod n;   // 指针移动，指向下一个准备取数据的位置（临界区）
                  signal(mutext);       // 释放缓冲池，允许进程放数据
                  signal(empty);        // 取出来了，空的缓冲区数需要加一
            Consumer the item in nextc; // 剩余区
               until false;
              end;
      ```
   - 哲学家进餐问题

   - 进程之间的通信
      - 通信的分类
         - 低级通信：进程的互斥和同步
         - 高级通信：指用户可直接利用OS提供的一级通信命令，高效地传送大量数据的一种通信方式。对用户透明 
      - 高级通信的解析
         - 分类
            - 共享存储器系统
               - 共享数据结构的通信方式：进程间通过某种数据结构，如缓冲池进行通信（属于低级通信方式）
               - 共享存储区通信方式：为了传递大量信息，在存储器中划出一块共享存储区，进程通过这个区域进行通信
            - 消息传递系统
               - 信息交换的单位是消息或报文
                  1. 直接通信方式
                     - 通过发送方和接收方提供给对方标识符，来直接地发送和接收信息
                  2. 间接通信方式
                     - 需要通过中间实体交互信息，一个存放暂时需要发送给对方的实体，消费者从这个实体取消息
            - 管道通信
               - 建立在文件系统上，用于连接一个读进程和一个写进程的共享文件来连接两个相互通信的进程

* 线程
   - 线程中的实体基本上不拥有系统资源，独立调度和分派的基本单位线程的切换非常迅速、开销小，可并发执行，共享进程资源

* 处理机的调度
   1. 高级调度/作业调度/长程调度/接纳调度
      - 作用：把外存上处于后备队列中的作业调入内存，并为它们创建进程，分配资源，排在就绪队列上，准备执行（分时系统，实时系统，通常不需要作业调度）
   2. 低级调度/进程调度/短程调度
      - 作用：决定就绪队列中的哪个进程应获得处理机（这里的就绪队列是指活动就绪），然后由分派程序执行把处理机分配给该进程的具体操作（OS中都必须配置，是最基本的调度）
      - 进程的抢占
         - 抢占：当把进程分配给cpu后，只有当这个进程执行完毕或发生阻塞时才给其它进程占用cpu（发生阻塞时比如进程通信或同步过程中执行了某种原语操作，如P操作，BLOCK原语，WAKEUP原语等）
         - 非抢占：允许暂停某个正在执行的进程，将已分配给该进程的处理机分配给另一个进程
            - 抢占原则：
               1. 优先权原则，优先权高的进程抢占处理机的概率大
               2. 短作业优先原则：短作业抢占当前较长作业的处理机
               3. 时间片原则，各进程按时间片运行，当一个时间片用完后重新调度
      - 队列模型
         - 低级调度队列模型（纯先FIFO原则）
            - 如果在时间片内完成了进程，则进程的状态为完成，cpu切换到另一个进程
            - 如果在时间片内未完成 ，则进程为就绪且加入到就绪队列队尾，cpu切换到另一个进程
            - 如果在时间片内发生了阻塞，则进程为阻塞状态并加入到阻塞队列队尾，cpu切换到另一个进程
         - 有高级和低级调度队列模型（有优先权的FIFO及有多个阻塞队列）
            - 批处理系统中最常用的是优先权队列也采用无序链表方式（如果队列是插入到就绪队列中，根据优先权决定插到靠前的位置，优先级越高则越靠近队头）
            - 设置多个阻塞队列，不同的阻塞队列表示不同的阻塞原因，阻塞的进程阻塞完毕后插入到就绪队列中
         - 有三级调度的调度队列模型
            - 调出时，可使进程状态由内存就绪转变为外存就绪，由阻塞转变为外存阻塞
            - 在中级调度使外存就绪转变为内存就绪
   3. 中级调度/对换：
      - 目的：提高内在利用率和系统吞率
      - 作用：使暂时不能运行的进程从内在调至外存，进入就绪驻外存状态或挂起状态，把外存上又具备运行条件的就绪进程，重新调入内存，并修改为就绪状态，挂在就绪队列上


* 选择调度的方式和调度算法的准则
   - 两大种调度方式
      - 面向用户的原则
         1. 周转时间：从作业被提交给系统开始，到作业完成为止的这段时间间隔称为作业周转时间，包括四部分时间
            1. 在外存后备队列上等待调度的时间
            2. 进程在就绪队列上等待调度的时间
            3. 进程在cpu上执行的时间
            4. 进程等待I/O操作完成的时间
         2. 平均周转时间：对n个周转时间的累加起来除以n
         3. 带权周转时间（响应比）：W=T/Ts，T作业的周期时间，Ts系统为它提供服务的时间（真正运行时间）
         4. 平均带权周转时间，把所有进程的带权周转时间累加再除以n
      - 面向系统的原则
         1. 响应时间
         2. 截止时间
         3. 吞吐量：单位时间内系统所完成的作业数，评价批处理系统性能的重要指标
   - 调度算法
      - 先来先服务调度算法（FCFS，first come first serve）有利于cpu繁忙，不利于I/O繁忙，cpu繁忙型带权周转时间接近1，I/O繁忙型带权周转时间远远大于1
      - 短作业（进程）优先法
         - 短作业优先法（SJF）从后备队列中选择一个或若干个估计运行时间最短的作业调入内存运行
         - 短进程优先法（SPF）从就绪队列中选出一估计运行时间最短的进程，分配处理机使它立即执行直到完成，或发生某事件而被阻塞放弃处理机时，再重新调度
         - 优缺点
            1. 对长作业不利，如果有一长作业进入系统的后备队列，由于总是优先调度那些短作业（进程），将导致长作业长期不被调度
            2. 完全未考虑作业的紧迫程序，不能保证紧迫性作业（进程）会被及时处理
            3. 作业（进程）的长短根据用户所提供的估计执行时间而定的不一定能真正做到短作业优先调度
      
      - 高优先权优先调度算法
         - 非抢占式优先权算法
         - 抢占式优先权调度算法
   - 优先权
      - 类别
         - 静态优先权
            - 在创建进程时确定，在进程的整个运行期间保持不变，在PCB里的一个整数
            - 确定优先权依据
               - 进程类型：系统进程高于用户进程
               - 进程对资源的要求：要求少的进程应赋予较高优先权
               - 用户要求：这是由用户进程的紧迫程度及所付费多少来确定
         - 动态优先权
            - 优先权随进程推进或承受其等待时间的增加而改变的，以便获得更好的高度性能
            - 优先权的变化规律
               - 优先权 = Rp =（等待时间+要求服务时间）/要求服务时间 = 响应时间/要求服务时间
      - 算法
         - 时间片轮算法
            - 把就绪进程组织成FIFO队列，把cpu分配给队首进程，规定它执行一个时间片，时间片完时排在就绪队列的末尾
         - 多级反馈队列调度算法
            - 为多个就绪队列赋不同的优先级，第一个队列的优先级最高其余逐个降低，各个队列中进程执行时间片也不同，优先权愈高的队列中时间片愈小
            - 新进程进入内在后，首先放入第一队列的末尾，按FCFS原则排除等待调度。到该进程执行时，如果能在该时间片内完成，便准备撤离系统，如果未完成，转入第二队列的末尾，再同样地按FCFS原则等待调度执行如此下去，当一个长作业从第一队列依次降到第N队列后，在第N队列中便采取按时间片轮转的方式运行
            - 仅当第1~(i-1)队列均空时，才会调度第i队列中的进程运行。如果处理机正在第i队列中为某进程服务时，又以有新进程进入优先权较高的队列，则新进程将抢占处理机，即由调度程序把正在运行的进程放回到第i队列的末尾，把处理机分配给新到的高优先权进程





********************************************* 电子科技大学 *********************************************

1 ~ 27 集 讲进程的概念，调度算法，死锁的问题（重看）
28 ~ 36 集 计存储管理技术（重看）
37 ~ 42 集 I/O技术和磁盘阵列技术（重看）
43 ~ 50 集 文件存储方式

视频进度 46 集

* 历史过程产生的操作系统和其它的概念
   - 概念
      - 处理机自动切换
         - 当某位个程序战胜处理机执行过程中遇到了输入/输出语句，可以启动专门负责输入/输出的系统服务程序完成输入/输出操作，而处理机切换到另一个程序执行
   - 不同的系统
      1. 单道批处理系统
         - 由程序员将命令和数据以汇编写或FORTRAN语言写在卡片上，最后将卡片用穿孔机连好再交给操作员处理
         - 卡片读到输入磁带，磁带由计算机处理将结果放到输出磁带，然后重复利用办理入磁带到另一个卡片程序
         - 每个时刻只有只有一个任务在内存，且不方便控制
      2. 多道批处理系统
         - 多道：允许多个程序存在于主存当中，按照某个原则分派处理机，逐个执行
         - 批处理：用户提交的作业首先存放在外存，并排成一个队列，然后由作业调度程序按照一定的算法从该队列中一次选取一个或若干个作业装入内存执行
         - 提高了资源的利用率和吞量交互性很差
      3. 分时系统系统
         - 为了改进响应时间和性能提供交互式操作环境，导致了分时系统的出现，在多道程序技术的基础上，为多个用户配置一个联机终端
         - 多道分时系统：允许 在内存中同时存放多道作业，并把具备运行条件的所有作业排成一个队列，让它们依次轮流地获得一个时间片来运行，与单道分时系统相比，由于作业数据都在内存，不需要调入、调出开销，所以多道分时系统具有较好的系统性能
      4. 实时系统系统
      5. 微机操作系统
      6. 网络操作系统

* 操作系统接口
   - 用户接口
      - 用户命令：指计算机用户要求计算机系统为其工作的指示
      - 命令的表示形式：
         1. 字符形式：较灵活但因繁琐而难记
         2. 菜单形式
         3. 图形形式：因直观而易记但不灵活
      - 命令的使用方式：
         1. 脱机使用方式（off-line）
         2. 联机使用方式（on-line）
   - 程序接口
      - 以系统调用的形式供用户编程时使用。几乎各种操作系统都提供了系统调用，供程序设计

* 目录大纲
   * 处理机管理
      1. 进程控制
      2. 进程同步
      3. 进程通信
      4. 进程调度
   * 存储器管理任务
      1. 为多道程序的并发执行提供良好的环境
      2. 便于用户使用存储器
      3. 提高存储器的利用率
      4. 为尽量多的用户提供足够大的存储空间
   * 设备管理
      1. -------
   * 文件管理任务
      1. 管理用户文件和系统文件
      2. 管理文件的存储空间
      3. 保证文件数据的安全
      4. 方便用户使用文件

* 进程
   - 概念
      - 可并发执行的程序，在一个数据集合上的运行过程
      - 申请/拥有资源 ~ 调度（线程）
      - 程序：静态概念，是指令和数据的集合，可长期存储
      - 进程与程序对应关系
         - 一个程序可以对应一个进程或多个进程
         - 一个进程可以对应一个程序，或者一段程序

   - 进程的结构
      - 组成（进程映像）：程序、数据集合、进程控制块PCB（Process Control Block）
      - PCB 是进程存在的唯一标志。创建进程时，创建PCB；进程结束时，系统将撤销其PCB
         - 进程标识信息：进程的内部和外部标识符
         - 处理机状态信息：通用寄存器值、指令计数器值、程序状态字PSW值、用户栈指针值
         - 进程高度信息：进程状态、进程优先权、进程调度的其它信息
         - 其它信息：程序及数据地址、进程同步和通讯机制、资源清单、链接指针
      - PCB的集合结构
         - PCB的单一队列：所有的PCB连成一个链表或队列
         - PCB的表格结构：对不同状态的PCB形成不同的队列，队列的值为PCB的地址，提高查询的效率（提高了查询效率，但是空间利用了较多）
         - PCB的多级队列：对不同状态的PCB形成不同的队列，即一个PCB指向下一个相同状态的PCB（减少了空间的利用，但是查询较慢）

   - 进程的状态
      - 基本状态
         - 执行状态（Running）：战胜处理机（单处理机环境中，某一时刻仅一个进程战胜处理机）
         - 就绪状态（Ready）：准备执行
         - 阻塞状态（Blocked）：等待某事件发生才能执行，如等待I/O完成等
         - 新状态（New）：进程已经创建，但未被OS接纳为可执行进程
         - 终止状态（Terminated）：因停止或取消，被OS从执行状态释放
   
      - 挂起
         - 把进程的部分数据或程序放到外存的情况是“挂起”，注意是进程的数据和程序而不是整个的进程，因为进程是系统调度的基本单位，所以不能放到外存
         - 挂起的原因
            - 进程全部阻塞，处理机空闲（以此来项腾出空间让新掋进程能够是动态就绪的状态让CPU繁忙起来）
            - 系统负荷过重，内存空间紧张
            - 操作系统的需要，操作系统可能需要挂起后台进程或一些服务进程，或者某些可能导致系统故障的进程
            - 终端用户的请求，父进程的需求
            - （通常是挂起阻塞状态的进程，但也有挂起就绪状态的进程的情况）
         - 被挂起进程的特征
            1. 不能立即执行
            2. 可能是等待某事件发生，若是，则阻塞条件独立于挂起条件，即使阻塞事件发生，该进程也不能执行
            3. 使之挂起的进程为：自身、其父进程、OS
            4. 只有挂起它的进程才能使之由挂起状态转换为其他状态
         - 4种状态组合
            1. 就绪（动态就绪）：进程在内存，准备执行
            2. 阻塞（动态阻塞）：进程在内存，等待事件
            3. 就绪/挂起（静态就绪）：进程在外存，只要调入内存即可执行
            4. 阻塞/挂起（静态阻塞）：进程在外存，等待事件
         - 注意问题
            - 当存储不够时的解决方案
               - 每个进程只能装入一部分程序和数据（存储管理部分）
               - 换出一部分进程的数据和程序到外部内存空间（一般是用的交换技术，Swapping）
                  - swapped in（外存到内存）
                  - swapped out（内存到外存）
            - 处理机可调度执行的进程有两种
               1. 新创建的进程
               2. 或换一个以前挂起的进程（通常为避免增加系统负载，系统会换入一个以前挂起的进程执行）
         - 转换图
            ```
            新建              分派/调度                   终止
            |  |          *---------------*               ^  
            |  |          |               |               |  
            |  |接纳      |               v               |完成/故障  
            |  *------>就绪               执行------------*
            |          ^^ ^               |  |
            |接        || |               |  |
            |纳        || *---------------*  |
            |          ||     时间片完       |
            v          ||                    |
            就绪/挂起--**------------------* |
            ^                 事件发生     | |事
            |                              | |件
            |事                            | |等
            |件                            | |待
            |发               激活         | |
            |生     *---------------------*| |
            |       |                     || |
            |       |                     v| v
            阻塞/挂起                     阻塞                 
                    ^                     |
                    |                     |
                    *---------------------*
                              挂起
            ```
         - 状态描述
            - 阻塞->阻塞/挂起：OS通常将阻塞进程换出，以腾出内存空间
            - 阻塞/挂起->就绪/挂起：当阻塞/挂起进程等待的事件发生时，可以将其转换为就绪/挂起
            - 就绪/挂起->就绪：OS需要调入一个进程执行
            - 就绪->就绪/挂起：一般，OS挂起阻塞进程。但有时也会挂起就绪进程，释放足够的内存空间
            - 新->就绪/挂起（新->就绪）：新进程创建后，可以插入到就绪队列或就绪，挂起队列。若无足够的内存分配给新进程，则需要新->就绪/挂起
      
            - 阻塞/挂起->阻塞：当阻塞/挂起队列中有一个进程的阻塞事件可能会很快发生，则可将一个阻塞/挂起进程换入内在，变为阻塞
            - 执行/就绪/挂起：当执行进程的时间片用完时，会转换为就绪。或，一个高优先级的阻塞/挂起进程正好变为非阻塞状态，OS可以将执行进程转换为就绪/挂起状态
            - 所有状态->终止：通常，执行->终止。但某些OS中，父进程可以终止其子进程，使任何状态的进程都可转换为退出状态
   
   - 进程的控制
      - 进程创建的步骤
         1. 为进程创建唯一的标识号id：主进程表中增加一个新的表项
         2. 为进程分配空间：用户地址空间，用户栈空间、PCB空间。若共享已有空间，则应建立相应的链接
         3. 初始化PCB：进程标识、处理机状态信息、进程状态
         4. 建立链接：若调度队列是链表，则将新进程插入到就绪或就绪/挂起链表中
         5. 建立或扩展其它数据结构
      - 进程的终止
         - 批处理作业执行到“结束”语句
         - 交互式用户“注销”
         - 停止进程（应用程序）的执行
         - 遇到错误或故障
      - 进程切换
         - 作用于进程之间的一种操作，当分派程序收回当前进程的CPU并准备把它分派给某个就绪进程时，该操作将被引用
         - 进程切换的原因
            - 时钟中断：进程执行完一个时间片
            - I/O中断：
            - 内存访问出错：虚拟存储中，需要的指令或数据不在内存
            - 陷阱：执行遇到错误；可能使进程转换到终止状态
      - 进程的执行模式
         - 系统模式（又称为系统态）、控制模式或内核模式
            - 具有较高的特权，运行系统特定的指令，包括读/写控制寄存器的指令，基本I/O指令以及与存储器管理有关的指令，及一些特定的内存区，内核模式下的处理机及其指令、寄存器和内存都受到完全控制和保护
         - 用户模式（或用户态）
            - 具有较低的特权
            - 用户程序一般运行在用户模式
         - 模式切换
            - 是进程内部所引用的一种操作。当用户程序转入系统调用，或相反时，该操作将被引用
            - 进程切换一定引发模式切换，反之则不然

   - 进程的调度
      - 调度是指，在一个队列中，按照某种方法（算法），选择一个合适的个体过程，调度的关键是需要某种方法或算法，好的调度算法有利于选择到合适的个体
      - 调度目标
         1. 公平性：防止进程长期不能获得调度而饥饿
         2. 处理机利用率：尽量提高处理机的利用率
         3. 提高系统吞量
         4. 尽量减少进程的响应时间
      - 调度原则
         - 面向的对象
            - 满足用户的要求：响应时间，周围时间，截止时间
            - 满足系统的需求：系统吞吐量，处理机利用率，各类资源的平衡使用，公平性及优先级
         - 时间解析
            - 响应时间：是指，用户通过键盘提交一个请求开始，直到系统首次产生响应为止的时间（常用于评价分时系统的性能）
               - 输入的请求传送到处理机的时间+处理机对请求信息进行处理的时间+将响应结果发送到输出终端的时间
            - 周转时间：指从作业提交给系统开始，到作业完成为止的这段时间间隔（常用于评价批处理系统的性能）
               - 作业在外存排队等待调度的时间+进程在就绪队列中等待调度的时间+进程被处理机执行的时间+等待I/O操作完成的时间
            - 截止时间：（常用于评价实时系统的性能）
               - 指实时系统中，某任务必须开始执行的最迟时间，或必须完成的最迟时间
         - 吞吐量
            - 指单位时间内系统所完成的作业数（常用于评价批处理系统的性能）
         - 处理机利用率
            - 大、中型多用户系统，由于处理机价格昂贵，处理机利用率是衡量系统性能的一个重要指标，单用户微机或某些实时系统，则并非很重要
         - 公平性：对所有进程公平，不偏袒任何进程

   - 进程调度的方式
      - 剥夺
         - 非剥夺方式（只能自己释放资源）
            - 执行进程只有在执行完毕，或因申请I/O阻塞自己时，才中断其执行，释放处理机，调度新的土星执行
            - 不利于“即时性”要求较高的分时和实时系统，主要用于批处理系统
         - 剥夺方式
            - 操作系统可以在新进程到来时，或某个具有较高优先权的被阻塞进程插入就绪队列时，或在基于时间片调度的系统中，时间片用完而中断当前进程的执行，调度新的进程执行
            - 产生较多的中断，主要用于实时性要求较高的实时系统及性能要求较高的批处理系统和分时系统
      - 长程调度，中程调度，短程调度
         - 长程调度/高级调度
            - 又称高级调度，或作业调度，它为被调度作业或用户程序创建进程，分配必要的系统资源，并将新创建的进程插入就绪队列，等待短程调度
            - 某些采用交换技术的系统将新创建的进程插入到就绪/挂起队列，等待中程调度
         - 中程调度/中级调度
            - 当内存空间非常紧张时，或生机找不到一个可执行的就绪进程时，需要选择一个进程（阻塞或就绪状态）换出到外存，释放出内存空间给别的进程使用；当内存空间较充裕时，从外存选择一个挂起状态的进程调度到内存（换入）
         - 短程调度/低级调度
            - 在就绪队列中选取一个或多个作业进入CPU执行

   - 进程调度的算法（主要讲的是低级调度的算法）
      1. 先来先服务（FCFS First come first Server）
         - 概念
            - 该方法按照进程到达的先后顺序排除，每次调度队首的进程
            - FCFS算法属于非剥夺调度方式，实现简单，看似公平
            - 但，对于那些后进入队列而运行时间较短的进程，或I/O型的进程而言，可能需要长时间等待
         - 对短进程不公平，不利于I/O型进程，未有效利用系统资源
      2. 短进程优先 
         - 概念
            - 当需要调度进程（或作业）时，通过计算判断就绪进程队列中哪一个进程的预期执行时间最短，或后备作业队列中哪一个或几个作业的预期执行时间最短，就调度谁
         - 与 FCFS 算法比较，短进程优先调度算法改善了系统的性能，降低了系统的平均等待时间，提高了系统的吞吐量。但是，该算法也存在一些问题
            - 很难准确预测进程的执行时间
            - 可能导致长进程饥饿，这对长进程不公平
            - 采用非剥夺调度方式，未考虑进程的紧迫程度，不适合于分时系统和事务处理系统
      3. 时间片轮转调度法
         - 概念
            - 在一个分时联机系统中，同时有n个人通过各自的终端共享一台主机（服务器）。终端完成输入/输出操作，主机负责处理从终端发来的请求
            - 为之建立进程、协调各进程的运行、调度各个进程等，并尽量满足每个终端用户对响应时间的要求
         - 缺点
            - 目标是为了让80%左右的进程在一个时间片内完成，但对于短的、计算型的进程较有利。不适合于批处理系统的进程调度，不利于I/O型的进程
            - 改进的方法之一，可以将I/O阻塞事件完成的进程单独组织一个就绪队列，该队列进程的时间片可以设置的小一些，且优先调度
      4. 基于优先级的调度算法
         - 概念
            - 基于时间片轮转调度法循环式地为每个被调度的进程分配一个时间片，对每个进程都是公平的
            - 然而，实际应用中，进程的性质可能是不同的，例如，一个与用户进行交互的前台进程急迫地需要对用户的输入作出响应，而一个后台打印进程的迫切性也许就不那么重要
            - 因此，可以为每个进程定义一个优先级，优先级越高的进程将优先获得处理机的调度
            - 如何设定进程的优先级
               - 进程完成功能的重要性
               - 进程完成功能的急迫性
               - 为均衡系统资源的使用，指定进程（作业）优先级
               - 进程对资源的战胜程序，例如，可以为短进程（或作业）赋予较高的优先级
            - 静态优先级和动态优先级
               - 静态优先级：一旦确定，则进程运行期间优先级一直不变
               - 动态优先级：系统首先赋予进程一个初始优先级，该优先级将随着进程的运行而改变
                  - 典型的动态优先级变化方式为：
                     1. 优先级随着进程运行的剩余时间的减少而上升，使将要执行结束的进程尽快完成（剩余时间最短者优先）
                     2. 或随着进程排除等待时间的增长而上升，使等待时间越长的进程优先得到调度。不至于长时间饥饿（响应比高者优先）
                  - 剩余时间最短者优先的分析
                     - 与短进程优先调度算法一样，该调度算法很难准确估计进程的剩余执行时间
                     - 由于长进程在未执行时，或刚开始执行的一段时间内，其剩余执行时间都不会最短，所以该算法对长进程不公平
                     - 但是，它不象FCFS算法偏袒长进程，也不象轮转调度算法会产生很多中断而增加系统负担
                     - 由于短进程提前完成，故采用剩余时间最短者优先的调度算法获得的平均周转时间比采用短进程优先算法短
                  - 响应比高者优先分析
                     - 将进程的等待时间和进程的预期执行时间纳入优先级的计算，进程（预期执行时间）越长优先级越低，而承受眷进程的等待时间增长优先级上升，
                     - 即进程的优先级与等待时间成正比，与进程执行时间成反比。令w表示等待时间，s表示预期执行时间，则响应比：R= (w+s)/s = w/s + 1
      5. 反馈调度法
         - 就绪队列从0到n依次降低，新的队列先放到0队列，如果一个时间片执行完还未完毕，则放到第二个队列惦念降低它的优先级
         - 分析
            - 该方法有利于交互型短进程或短批处理作业，因为它们一般只需要一个或很少的几个时间片即可完成，
            - 但可能使长进程的周转时间急剧增加
            - 如果不断地有新进程到来，还可能出现长进程长期饱现象
            - 为此，可以各队列设置不同的时间片优先级愈低时间片愈长

      6. 实时系统的调度算法
         - 指，能及时响应外部事件的请求，在规定的时弊偿完成对该事件的处理，并控制所有实时任务协调一致地运行的计算机系统
         - 类别
            1. 实时控制系统：
               - 主要用于生产过程的控制，实时采集现场数据，并对所采集的数据进行及时处理，进而自动地控制相应的执行机构，使某些（个）参数（如温度、压力、方位等）能按预定的规律变化，
               - 以保证产品的质量和提高产量
            2. 实时信息处理系统
               - 指能信息进行实时处理的系统，该系统由一台或多台主机通过通信线路连接成百上千个远程终端，计算机接收从远程终端发来的服务请求，根据用户提出的问题，
               - 对信息进行检索和处理，并在很短的时间内为用户做出正确的回答，典型的有飞机订票系统，情报检索系统等
         - 周期性
            1. 周期性实时任务，要求按指定的周期循环执行，惦念便周期性地控制某个外部事件
            2. 非周期性实时任务，任务的执行无明显的周期性，但都必须联系眷一个截止时间
         - 截止时间
            1. 开始截止时间：任务在某时间以前，必须开始执行
            2. 完成截止时间：任务在某时间以前必须完成
         - 速度单调调度算法
            - 根据任务的周期大小赋予优先级，最短周期的任务具有最高优先级，其中
               - 任务周期（period），指一个任务到达至下一任务到达之间的时间范围
               - 任务速度（rate），即周期（以秒计）的倒数，以赫兹为单位
            - 任务周期的结束，表示任务的硬截止时间，任务的执行时间不应超过任务周期

   - 线程
      - 为了减少程序并发执行时系统所付出的额外开销，使操作系统具有更好的并发性
      - 将进程的资源申请和调度属性分开，即进程作为资源的申请和拥有者，但不作为调度的基本单位，这样，就产生了线程的概念
         - 纯种是进程中的一个实体，是独立调度和分派的基本单位
         - 线程自身基本上不拥有系统资源，只拥有少许运行中必不可少的私有资源，线程可与同属一个进程的其它纯种共享进程的全部资源
      - 线程具有三种基本状态：就绪，执行，阻塞
         - 一般不具有挂起状态，因为线程共享进程的资源，包括存储空间，如果挂起一个进程，其所属的全部进程必将被挂起。
         - 而单独挂起某进程中的一个线程，必然会影响同一进程中的其它线程的执行，这是没有任何意义的
      - 注意
         - 线程阻塞不一定会引起整个进程的阻塞，否则，引入线程带来的并发性就不会提高
         - 同一进程中的线程切换时不会引起进程切换，但当一个进程中的线程切换到另一个进程中的线程时，将会引起进程切换
   
   - 进程互斥和同步的解决策略
      - 临界资源是指一次只允许一个进程访问使用的资源
      - 任何时刻只允许一个进程进入临界区，临界区是指访问临界资源的代码
      - 过程：进入区->临界区->退出区
         - 在进入区判断是否可以进入临界区
         - 如果不能正常进入临界区，则把当前进程阻塞
         - 如果可以进入则设置临界区使用标志（防止其它进程获取临界资源），在退出区修改临界区使用标志，并唤醒阻塞队列的一个进程让其进入临界区
      - 临界区使用原则
         - 每次只允许一个进程牌临界区（忙则等待）
         - 进程只能在临界区内逗留有限时间，不得使其它进程在临界外无限期等待（有限等待）
         - 如果临界区空闲，则只要有进程申请就立即让其进入（空闲让进）
         - 进入临界区的进程，不能在临界区内长时间阻塞等待某事件，必须在一定期限内退出临界区（让权等待）
         - 不能限制进程的执行进度及处理机的数量
      - 解决进程互斥与同步的方法
         1. 软件方法
            - 指由进程自己，通过执行相应的程序指令，实现与别的进程的同步与互斥，无须专门程序设计语言或操作系统的支持
            - 该方法很验证正确控制进程间同步与互斥，而且可能会大大地增加系统的额外开销
         2. 硬件方法
            - 为了解决软件方法存在的不足，有人提出了硬件解决方法，通过屏蔽中断或采用专门的机器指令控制同步与互斥
            - 减少了系统额外开销，由于需要太强硬件约束条件，以及可能导致进程饥饿与死锁
         3. 信号量方法
            - 由操作系统或专门的程序设计语言提供的特别支持，包括信号量方法，管程方法和消息传递方法
            - 其中信号量方法已经成为控制进程同步与互斥的通用方法
            - 过程和问题
               1. 互斥与生产者与消费者：进程应该先获取资源信号量，再获取互斥信号量
               2. 读和写的互斥问题：有读取优先，还有写入优先
         4. 管程方法
            - 由过程，变量及数据结构等组成的集合，典型的管程包括三个部分：
               1. 对局部于的共享数据结构的说明
               2. 对该数据结构进程操作的一组过程
               3. 对该数据结构初始化的语句
            - 有自己的名字，中的各个过程可以带有自己的形式参数，与过程调用一样进行参数替换执行
         5. 消息传递方法
            - 进程之间同步与互斥是一种低级通信，用来控制进程执行速度
            - 分类
               - 低级通信：进程之间交换控制信息的过程
               - 高级通信：进程之间交换批量数据的过程
   
   - 进程的通信
      1. 基于共享存储区方式
      2. 消息传递
      3. 邮箱机制
   
   - 产生死锁的必定条件（非充分条件）
      1. 互斥：竞争的资源一次只能被一个进程使用
      2. 占有且等待：当一个进程占有一些资源，同时又申请新的资源。如果新的资源申请失败，进程将占有资源且阻塞等待
      3. 非剥夺：进程已占有的资源不能被其它进程强行剥夺

* 存储管理
   - 大纲
      1. 存储管理的任务
      2. 内在划分与分配技术
      3. 程序装入技术
      4. 简单存储管理技术
      5. 虚拟存储管理技术

   - 概念
      - 存储分配
         - 基本任务：管理内存空间的分配与回收
         - 分配基本内存空间
         - 增加新的内存空间，动态申请或释放内存空间
         - 回收内存空间
      - 静态重定位
         - 地址映射：程序装入内存以后，由操作系统将逻辑地址改为逻辑地址加上起始地址，得到实际的物理地址
         - 重定位：对目标程序中的指令和数据地址进行修改的过程
         - 静态映射实现简单，地址变换只在程序装入时一将领完成，程序运行时不再改变
         - 但不适合多道程序系统；不允许系统的碎片整理；无法实现虚拟存储
      - 动态映射：动态重定位
         - 操作系统将程序装入内存以后，并不立即把目标程序中的逻辑地址转换为物理地址，而是在处理机执行每一指令时进行地址转换
         - 复杂且费时
         - 为了系统效率，处理机中设置了专门的调整硬件，自动完成地址转换，这样的硬件被称作地址管理部件
      - 存储保护：防止越权，防止越界
      - 地址映射
         ```
         逻辑地址，或相对地址：一般从0开始编址
         物理地址，或绝对地址：标识内存中的每个存储单元
         进程控制信息----->***************
                           * 进程控制块  *
         程序入口点------->***************
                     |     * 程序        *
                 指针移动  ***************
                     v     * 数据        *
         当前栈点--------->***************
                           * 栈          *
                           ***************
         ```

   - 解析
      1. 存储管理的任务
         - 静态划分
            - 必须事先进行，一旦划分完毕，分区的大小和数目将不再改变，可以划分：大小相同/不同的分区，如固定分区和分页
            1. 固定分区：根据系统管理员的经验和一些统计规律，事先将内存空间划分为若干个固定大小的分区，称为分区（Partitioning）。当进程申请存储空间时，系统为之分配一个大小合适的空闲分区
               - 所有分区大小相同
               - 无法运行超过分区大小的程序
               - 无法精确确定分区的大小
               - 进程大小不超过分区大小，就可以装到任何一个分区中运行，因为为进程分配的分区，分配的空间中多余的称为浪费空间，称内零头（internal fragmentation）
               - 记录方式
                  1. 分区使用表：包含：分区号，状态
            2. 异长分区
               - 将内存空间划分为若干个长度不同的分区，以适合于不同大小的进程需要
               - 既提高存储空间的利用率，减少浪费，又使长进程能装入运行
               - 但是，确定每个分区的大小也是一件十分困难的事情
               - 记录方式
                  1. 分区使用表：包含：分区号，大小，起始地址，状态
            3. 分页式划分
               - 为了提高内存资源的利用率，可以考虑将分区长度缩小，减少内零头浪费的空间
               - 但是，这样做必须有一个前提，即进程可以分配若干不连续的存储空间，否则，小分区可能使更多的进程无法装入内存
               - 分页划分：系统预先将内存空间划分为若干较小的，固定大小的页框
                  - 页框较小，有效地减少了内零头的浪费，每个进程平均浪费0.5页框大小，页框大小固定，简化了存储分配，但是需要记录内存页框的分配和使用情况
               - 记录方式
                  1. 位示图：是一个由0,1构成的向量，其中每一位（bit）表示一个页框的使用状态。一般规定，0表示页框空闲，1表示页框已被分配
                     - 所有页框依次编号为0,1,2,...n-1，则记录所有页框的使用状态的位示图例如：000...1
                  2. 空闲页框表：以表格形式记载内存页框的使用情况
                     - 为每一个空闲页框设置一个表项是不合理的，这将导致页框表太大，可以为一组连续的空闲页框设置一个表项，其中主要包括：首页框号和页框个数
                     - 如：
                     ```
                     首页框号  页框个数
                     50        100
                     220       30
                     300       80
                     450       210
                     ```
                  3. 空闲页框链表：是将内存中所有的空闲页框通过其内的链接指针连成一个链表，系统只需要记录链表头的位置
                     - 为进程分配存储空间时，从链表头开始取所需的页框，同时更新链表头，回收进程释放的存储空间时，将新产生的空闲页框链接到空闲页框链表中

         - 动态划分
            - 根据进程的实际需要，动态地划分内存空间，并分配给进程，彻底解决了内零头问题（并不是完全解决，而是可能让内零头达到极小）
            - 空闲分区表：空闲分区首地址，长度
            - 三种典型的分区分配方案
               1. 首次适应算法（FFA: First Fit Algorit）
                  - 概念
                     - 总是从内存的某一端（一般从低地址端）开始查找，选择一个超过进程申请大小的空闲分区
                     - 若找到的空闲分区恰好与进程申请的存储空间大小相等，或分配给该进程以后，仅剩下一个非常小的空间（小于系统设置的阈值），则此分区全部分配给进程
                     - 否则，系统将该分区划分为两个分区，一个分区长度等于进程申请的空间大小，并分配给进程，另剩下的链接到空闲分区中
                     - 为此，可以将空闲分区表中登记的空闲分区按照其起始地址由小到大地次序依次排序，系统查找空闲分区时，从表头开始查找，取第一个满足要求的分区分配给进程
                  - 外零头：紧凑
                     - 动态划分技术解决了静态划分技术的内零头
                     - 可能产生很多较小的分区：外零头（External Fragment）
                     - 紧凑（Compaction）：把内存中的所有空闲分区拼接成一个较大的空闲分区，即把内存中的所有进程移到内存的某一端；所有空闲分区移到另一端
               2. 下次适应算法（NFA：Next-Fit Algorit）
                  - 下次适应算法能记住上次分配分区的位置，下一将领实施分配时，从上次空间的分配位置之后的位置开始查找，选择一个大小足够的空闲分区，如果不合适则循环查找？？？
                  - 该算法常常会导致内存中缺乏大分区，因为它会均衡地利用空闲分区，包括分割较大的空闲分区，从而使得进程无法装入内存运行
                  - 下次适应算法可能会导致大量的外零头，需要较频繁地实施紧凑操作
               3. 最佳适应算法（BFA：Best Fit Algorit）
                  - 概念
                     - 总是选择满足申请要求且长度最小的空闲分区
                     - 为了提高查找效率，可以将所有的空闲分区按照长度由小到大的次序依次排列在空闲分区表中
                     - 为进程分配存储空间时，从表头开始查找，第一个满足进程申请存储空间大小的分区就是最适合的分区
                  - 优缺点
                     - 优点：尽量不分割大的空闲分区
                     - 缺点：可能会形成大量较小的，难以再分配的分区--大量的外零头
                     - 并非好的算法
               4. 最差适应算法（Word Fit Algorit）
                  - 概念
                     - 选择满足申请要求且长度最大的空闲分区，使分割出来的剩余空闲分区较大
                     - 为了提高系统效率，可将系统中所有的空闲分区按照长度由大到小的次序依次排列在空闲分区表中
                     - 为进程分配存储空间时，从表头开始查找，选择第一个满足进程需要的分区
                     - 如果第一个空闲分区小于进程申请空间的大小则不能立即为进程分配存储空间
                  - 优缺点
                     - 可以避免形成大量较小外零头
                     - 但它总是分割大的空闲分区，当遇到大进程申请大空间时，无法找到一个足够大的空闲分区
                     - 换句话说，在大进程面前，内存中所谓的较大空闲分区也是外零头了
               5. 伙伴系统（Buddy System）
                  - 概念
                     - 概念1
                        - 结合了静态划分和动态划分
                        - 伙伴系统内存的用户可用空间为 2^u
                     - 概念2
                        - 数学公式：2^i-1 = (2^i)/2
                        - 伙伴系统内存的用户可用空间为 2^u
                        - 系统总是为进程分配大小为 2^i 的一个空闲分区，其中 m<=i<=u，2^m 是系统允许的最小分区尺寸
                        - 如果进程申请的存储空间大小为k，且 2^i-1 < k <= 2^i，则将整个 2^i 大小的分区分配给它
                        - 否则，该分区被分割成大小相等（2^i-1）的两个分区。再判断k是否满足条件：2^i-2 < k <= 2^i-1，若满足条件，则将两个伙伴中的任何一个分配给进程
                        - 否则，将其中一个伙伴又平均分成两个分区，此过程一直继续进行，直到产生的分区大于或等于k，将其分配进程
                     - 举例
                        - 进程申请大小为 k 的空间，系统为之分配一个 2^i 的空闲分区，其中，2^i-1 < k <= 2^i
                           - 若 2^i > 2^u，即进程 > 内存空间，失败；
                           - 若当前无尺寸为 2^i 的空闲分区，则：
                              1. 将 i 变为 i+1，查找一个尺寸为 2^i+1 的空闲分区，若存在，转步骤2. 执行，否则，继续执行步骤1.
                              2. 等分 2^i+1 空闲分区；产生两个 2^i 的伙伴分区；
                              3. 把其中一个 2^i 的伙伴分区作为空闲分区；
                              4. 另一个 2^i 空闲分区分配给进程，结束；
                     - 回收
                        - 当进程执行完毕，释放一个尺寸为 2^i 的分区时，系统用下面的算法回收该分区：
                           - 如果被回收分区的伙伴分区非空闲，那么保留该分区为一个独立的空闲分区，否则
                              1. 合并回收分区及其伙伴分区，从而得到一个尺寸为 2^i+1 的空闲分区
                              2. 系统再次调用本算法回收上一步得到的尺寸为 2^i+1 的空闲分区

* 程序的装入
   - 可执行程序的生成步骤
      ```
         | 编辑
         v
      源程序
         | 编译
         v
      目标模块 ....... 目标模块   库函数
         *                *         *  
         ****************************  
                     *                 
                     * 链接              
         *************                 
         v                             
      装入模块
         | 执行
         v
        内存
      ```
   - 可执行程序的装入
      - 装入方式
         1. 绝对装入
         2. 重定位装入
         3. 运行时动态装入
      - 分析
         1. 绝对装入
            - 程序运行之前，按照程序的逻辑地址将程序和数据装入内存指定的地方，实现简单，无须进行逻辑地址到物理地址的变换
            - 缺点
               1. 程序每次必须装入同一内存区
               2. 程序员必须事先了解内存的使用情况，根据内存情况确定程序的逻辑地址
               3. 程序的修改（增加或删除指令）将引起整个程序中指令地址的变动
               4. 程序中的所有存储引用，例如函数调用或过程调用等，在装入之前都必须转换为物理地址，这不利于存储共享
         2. 重定位装入
            - 允许将程序装入逻辑地址不同的物理内存空间，即程序可以装入到内存的任何位置，其逻辑地址与装入内存后的物理地址无直接关系
            - 但是，必须进行地址映射，将逻辑地址转换为物理地址
            - 有利于代码的存储共享，但是是不支持程序在内存当中的移动，不利于内存交换和共享，只适合于单道程序
            - 静态重定位技术：地址映射在程序装入时进行，以后不再更改程序地址
         3. 运行时动态装入
            - 指，程序的地址转换不是在装入时进行，而是在程序运行时动态进行
            - 运行时动态装入需要硬件支持，即重定位寄存器，用于保存程序在内存中的起始地址
            - 程序被执行时，通过重定位寄存器内的起始物理地址和指令或数据的逻辑地址计算其物理地址
            - 运行时动态装入有利于多道程序环境下，进程的换进/换出及实现紧凑技术
            - 可执行程序的链接形成
               - 目标模块如何链接成装入模块呢
                  - 静态链接
                     - 指，程序被装入内存之前，必须完全链接成一个装入模块，将其中的存储引用全部转换为相对地址中转语句，并将多个目标模块链接成为一个模块，使装入模块中的每一条指令具有相对于整个模块的第一条语句的逻辑地址
                     - 静态链接生成的装入模块可以采用重定位装入或运行时动态装入方式
                     - 静态链接需要花费大量的处理机时间，而其中的很多模块将不会运行，浪费存储空间和处理机时间
                  - 动态链接：装入时动态链接和运行时动态链接
                     - 不用事先链接所有目标模块形成一个完备的装入模块，而是生成一个含有未被链接的外部模块引用的装入模块,这些外部模块可以在装入时链接，或运行时链接
                     - 装入时动态链接
                        - 指，当系统装入含有未链接的外部模块引用的装入模块时，每当遇到一个外部模块引用，则查找相应的目标模块，将其装入内存，并将模块内的指令地址转换为相对于整个装入模块起始地址的相对地址
                        - 优点：有利于目标模块的更新与升级；有利于代码；有利于扩充软件的功能，可以将扩充部分作为动态链接模块
                        - 缺点：可能链接一些不会执行的模块，浪费存储空间和处理机时间
                     - 运行时动态链接
                        - 指，外部模块引用直至程序执行时才装入内存，并链接到装入模块中，进行地址转换
                        - 可以解决静态链接和装入时动态链接都面临的存储空间和处理机时间浪费问题，不需要执行的模块就不会装入内存
                        - 广泛用于事务处理系统，如航空售票系统，银行管理系统等
                        - 操作系统自身的一些特殊处理例程，如错误处理例程，也无需事先全部装入内存

   - 简单分页存储管理技术
      - 简单存储
         - 相对于虚拟存储而言，指为了实现简单，执行之前，操作系统必须将待执行的程序全部装入内存
         - 然而，现代操作系统大都支持虚拟存储功能，允许进程装入部分程序即可开始执行，其余部分保留在外存，当执行所需的部分不在内存时，中断进程执行，使之阻塞等待，直到相应部分装入内存
      - 程序在内存中如何组织
         - 两种存储
            - 连续存储技术：需要内存中的一场连续的足够大的分区时，如果内存中没有足够大的连续空闲分区，但存在总量足够的独立小分区，即外零头。系统要么拒绝分配空间，要么采用紧凑技术拼接外零头
            - 非连续存储：允许进程的程序和数据分别装在内存的不同分区中，必须登记一个进程分到的所有分区的位置，大小，使用情况（如是否共享等）等信息，常用的非连续存储技术：分页存储技术，分段存储技术及其结合
         - 存储的解析
            - 连续存储管理
               - 要求系统配置专门的硬件实现快速地址转换和存储保护
                  1. 基地寄存器：存放当前执行进程所在分区的物理存储单元的起始地址
                  2. 界限寄存器：存放当前执行进程所在的分区最后一个物理存储单元的地址，限定进程的执行范围，保护其他进程不被非法访问
               - 地址映射与存储保护
                  - 基址寄存器和界限寄存器被多个进程共享，只有当前执进程才使用它们
                  - 装入时，把分区的首地址和结尾地址放入PCB头信息中，执行进程时，把首地址放入基址寄存器中，尾地址放入界限寄存器中
                  - 逻辑地址转换成物理地址--取基址寄存器中的值，加上逻辑地址值，生成一个物理地址
                  - 地址越界检查--取界限寄存器中的值，与第一步计算的结果进行比较，如果生成的物理地址超出了界限范围，产生一个中断，报告地址越界，否则，继续该指令的执行

            - 非连续存储管理
               - 连续存储存在外零头，浪费存储空间，”紧凑“需要系统额外开销，非连续存储允许将一个进程的程序和数据离散存储在多个独立的分区中，消除了外零头
               - 系统事先将物理内存划分成许多尺寸相等的页框（Page Frame），并将进程分割成许多大小相同的页面（Page），页面与页框大小相同
                  - 进程所拥有的页框可能不止一个，而且所拥有的页框地址可能不连续，所以需要一个页框表把所有页面进行记录
               - 页框表：
                  - 系统每个进程建立一张页面映射表，用于记载进程的各页面到物理内存中页框的映射信息，
                  - 进程的每个页面依次对应页表中的一个表项，其中包含相应页在内存中对应的物理页框号和页面存取控制权限等字段
               - 空闲页框表：
                  - 登记笼统中剩下的空闲页框情况
            - 总结概念
               - 分区：进程的逻辑地址空间是连续的，一维的，线性地址，进程的每一条指令和数据的地址相对于第一条语句的地址而定
               - 分页：进程被分割成许多页面。每个页面内的指令和数据是连续的，它们的地址相对于其所属页的第一条语句的地址，称为页内领衔量
               - 逻辑地址被分为两部分：页号和页内偏移量
               - 同一个进程的多个页面不必存放在连续的多个页框中，也可能是连续的
      - 细节解析
         - 地址变换过程
            - 硬件机制，实现逻辑地址到物理地址的转换
            - 分页系统中的地址变换过程：
               1. 根据逻辑地址，计算出页号和页内领衔量
               2. 用页号检索页表，查找指定页面对应的页框号
               3. 根据页框号和页内偏移量，计算出物理地址
         - 页表寄存器
            - 页表寄存器：实现快速地址映射，存储执行进程的页表起始地址
            - 页表寄存器设置在处理机硬件中
            - 当进程被创建时，其页表起始地址记载于进程PCB中
            - 当进程被调度执行时，页表的起始地址将从该进程的PCB中取出，并填入页表寄存器中
            - 进行地址变换时，处理机从页表寄存器中查找页表的地址
         - 大页表
            - 概述
               - 大逻辑地址空间，页表非常大，需要占用相当大的内存空间，比如，32位逻辑地址空间，假设页面大小为4kb(2^12)，则4GB(2^32)的逻辑地址空间将被划分为2^20个页面
               - 若采用一级页表，则其内将包含1兆（2^20）个页表项。若按字节寻址，一个页表项占4B，则一级页表需要占用4MB（2^22）内存空间
               - 然而不可能将4MB的页表保存在一个连续区中
            - 二级页表
               - 将一个大页表全部保存在内存中，
               - 先将其分割，并离散地存储在内存的多个页框中，
               - 为之建立二级页表，记录被分割的各个页面存储在哪些页框中，也称为外层页表
            - 多级页表
               - 对于某些机器，二级页表也可能不满足需求，所以就产生了多级页表，虽然解决了连续空间的问题，然而这仍然会占用较大的空间，所以会考虑增加额外的存储空间
         - 反置页表
            - 一般情况下，系统从进程的角度为每个进程建立一张页表，页表的表项按页号排序，这可能导致一个大进程的页表太大，占据大量的内存空间
            - 反置页表：从内存的角度建立页表，整个系统只有一张页表。页表的表项基于内存中的每个物理页框设置，页表项按页框号的顺序排序。其中还必须包含页框对应的页号及其隶属的进程的标识符等信息
            - 通常，反置页表需要包含成千上万个表项利用进程ID和页号检索其中某一个表项的速度很慢，可以根据进程ID和页号构建Hash表，Hash表的每一项指向反置页表中的某一项
            - 但是，可能会出现多个逻辑地址被映射到一个Hash表项的情况，需要通过链接指针将多个冲突的映射链接起来，但在极限情况下链表性能也差，所以采用了红黑树
         - 快速表
            - 分页系统：处理机每次存取指令或数据至少需要访问两次物理内存：第一次访问页表，第二将领存取指令或数据
            - 为了提高地址变换速度，为进程页表设置一个专用的高速缓冲存储器，称为快表（TLB Translation Lookaside Buffer），或联想存储器（Associative Memory）
               - 通过根据逻辑地址中的页号，查找快表中是否存在对应的页表项
                  - 若快表中存在该表项，称为命中（hit），取出其中的页框号，加上页内领衔量，计算出物理地址
                  - 若快表中不存在该页表项，称为命中失败，则再查找页表，找到逻辑地址中指定页号对应的页框号，同时，更新快表，将该表项插入快表中，并计算物理地址
         - 页面与页框大小
            - 分页系统中，页面=页框。页框大小由计算机的硬件逻辑定义，通常页框大小是  的幂次个字节，且常在 512B(2^9) ~ 4KB(2^12)之间，典型的页框大小为 1 KB

      - 对简单分页存储管理的评价
         1. 彻底消除了外零头，仅存在很少的内零头，提高了内存利用率
         2. 分页操作由系统自动进行，一个页面不能实现某种逻辑功能。用户看到的逻辑地址是一维的，无法调试执行其中的某个子程序或子函数
         3. 采用分页技术不易于实现存储共享，也不便于程序的动态链接

   - 简单分段存储管理技术
      - 概念
         - 基于模块化程序设计时，常常需要将一个大任务划分成若干相对独立的子任务，对应于子任务编写子程序，称为段（Segment）
         - 每个子程序可以独立地编辑，编译，链接和执行
         - 各个子程序由实现的功能决定，长度各不相同。执行时，根据实际需要，将若干子程序链接成一个大程序
         - 程序由若干逻辑段组成，每个段有自己的名字和长度。程序的逻辑地址是由段名（段号）和段内偏移量决定。每个段的逻辑地址从0开始编址
      - 实现
         - 系统采用动态划分技术，将物理内存动态地划分成许多尺寸不相等的分区
         - 当一个进程被装入物理内存时，系统将为该进程的每一段独立地分配一个分区。同一进程的多个段不必存放在连续的多个分区中
      - 数据结构
         - 段表
            - 每个进程建立一个，用于描述进程的分段情况，记载进程的各个段到物理内存中分区的映射情况，其中包含段号，段长，段基址以及对本段的存取控制权限等信息
         - 空闲分区表
            - 用于记载物理内存中空闲分区情况
      - 段表寄存器
         - 实现快速地址变换，用来存放当前执行进程的段表在物理内存中的起始地址
         - 当创建进程，将进程的程序和数据装入内存时，系统为之建立段表，并将段表的起始地址填入进程的PCB
         - 当进程被调度执行时，取出PCB中的段表首址，填入段表寄存器中
      - 分段系统的快表
         - 在分段系统中，为了访问内存中的一条指令或数据，需要两次访问内存
            1. 第一次，访问内存中的段表，获得对应段的起始地址。根据段的起始地址和段内领衔量，计算出物理地址
            2. 第二次，根据物理地址，访问对应存储单元的指令或数据
         - 为了提高处理机的效率，类似分布系统的快表，可以为分段系统增加一个快表，用于保存最近使用过的段表项
      - 对分段系统的评价
         - 有效消除了内零头，提高了存储利用率
         - 允许子程序独立编译和修改，而不需要重新编译或链接其它相关子程序
         - 容易实现存储共享
         - 具有较高的安全保障
         - 很容易满足程序段的动态增长需要
      - 分页与分段技术的比较
         - 都采用非连续存储，由地址映射实现地址变换
            - 不同主要表现在
               1. 页是信息的物理单位，大小固定。段是信息的逻辑单位，各段的长度不固定。每一段都具有一定逻辑含义
               2. 分页的地址空间是一维的，逻辑地址的划分由机器硬件实现，对用户透明。分段的地址空间是二维的或多维的，程序员知道段名和段内领衔量
               3. 分页活动源于系统管理物理内存的需要，在系统内部进行，由系统实施，用户看不见。分段活动源于用户进行模块化程序设计的需要，在系统外部进行，由用户实施，用户是知道的

   - 简单段页式存储管理
      - 概念
         - 采用分段方法组织用户程序，采用分页方法分配和管理内存，即用户程序可以模块化思想进行设计，一个用户序由若干段构成。
         - 系统将内存划分成固定大小的页框，并将程序的每一段分割成若干页以后装入内存执行时
         - 在段页式系统中，进程的每一段被进一步分割成页面。段内代码和数据地址不再连续，逻辑地址由三部分组成：段号，段内页号，页内偏移量
      - 段表寄存器：加速地址变换，用于存放执行进程段表的起始地址
         1. 首先，从段表寄存器从获得进程段表的起始地址，根据该地址，查找进程的段表
         2. 然后，根据逻辑地址指定的段号检索段表，找到对应段的页表起始地址
         3. 再根据逻辑地址中指定的页号检索该页表，找到对应页所在的页框号
         4. 最后，用页框号加上逻辑地址中指定的页内偏移量，形成物理地址
      - 快表
         - 第一次，访问段表，从中获得该段的页表首址
         - 第二次，访问页表，从中取出逻辑地址指定的页面所在的页框号，并将该页框号和页内偏移量相加，形成指令或数据的物理地址
         - 第三次，访问内存，根据前面计算的物理地址取出对应存储单元的指令或数据
         - 可以在地址变换机构中增设一个调整缓冲寄存器，其中保存最近使用过的页号及其所属的段号
             - 同理找得到就返回，找不到就先查段表，再查页表

   - 虚拟存储管理技术
      - 进程运行之前，权需要将一部分页面或段装入内存，便可启动运行，其余部分暂时保留在磁盘上
      - 进程运行时，如果它所需要访问的页面（段）已经装入内存，则可以继续执行下去
      - 如果其所需要访问的页面（段）中断，进程阻塞，此时系统将启动请求调页（段）功能，将进程所需的页（段）装入内存
      - 如果当前内存已满，无法装入新的页（段），则还需要利用页（段）置换功能，将内存中暂时不用的页（段）交换到磁盘上，以腾出足够的内存空间
      - 再将进程所需的页（段）装入内存，唤醒阻塞的进程，使之重新参与调度执行

      - 结构
         - 由于虚拟存储系统中，进程的程序代码和数据只有一部分在内存，另一部分保存在外存
         - 在页/段表项中增加一个”存在“字段，其值为0或1
         - 增加一个”修改“字段，表明对应页/段自进入内存以来是否被修改过。只有被修改过的页/段才需要保存到外存，
         - 若需要将未修改过的页/段换出内存，只需要将新装入的页/段直接覆盖其存储区域，而不必将其内容保存到外存

      - 虚拟存储分页技术
         - 建立在简单分硬骨头瞧管理系统之上，是目前常用的一种虚拟存储管理技术
         - 基于简单存储分页系统增加了某些功能，如产生了处理缺页中断，以及从内存中换出页面等
         - 进程执行时，首先通过根据逻辑地址中的页号，查找快表中是否存在对应的页表项。若快表中不存在该页表项，
         - 则再查找页表。检查对应的页面是否在内存中存在。若该页面不在内存，启动缺页中断处理例程。装入需要的页面
         - 并更新页表和快表。若该页面已经在内存中，将对应的页表项插入快表中，更新快表。若快表中存在该表项，则直接
         - 取出其中的页框号，加上页内偏移量，计算出物理地址
      - 虚拟存储分段技术
         - 建立在简单存储分段系统基础上，利用动态分区技术分配存储空间，并以段作为交换的单位
         - 进程执行之前，系统为之分配几个必要的内存分区，每一个分区中装入一段
         - 当里程执行过程中，出现缺段中断时，操作系统将为进程装入需要的程序段
      - 虚拟存储段页式技术
         - 虚拟存储段页式系统中，程序和数据通常以页面为单位被系统装入和移出内存
         - 因此，一般不需要在段表项中增加”存在“字段和”修改“字段，而将它们放在页表中
         - 段表中需要保留基于段的保护与存储共享等目的的存取控制信息，页表中设置基于页的控制信息

      - 虚拟内存的典型问题--抖动（thrashing）
         - 概念
            - 当进程要求装入新的页面或程序段时，如果当前没有足够的空闲空间，需要交换一些页面或段到外存。如果被交换出去的页面或段很快将被进程使用，则又需要将其换入内存
            - 如果系统花费大量的时间把程序和数据频繁地装入和移出内存而不是执行用户指令，那么称系统出现了抖动。出现拉动现象时，系统显得非常繁忙，但是吞吐量很低，甚至产出为零
            - 根本原因：选择的页面或段不恰当

   - 虚拟存储系统的软件策略
      - 驻留集管理
         - 进程的驻留集指，虚拟存储系统中，每个进程驻留在内存的页面集合，或进程分到的物理页框集合
         - 驻留集管理主要解决的问题是，系统应当为每个活跃进程分配多少个页框
         - 分配策略
            - 固定分配策略
               - 为每个进程分配固定数量的页杠，即每个活跃进程的驻留集尺寸在运行期间固定不变
            - 可变分配策略
               - 为每个活跃进程分配的页框数在进程的生命周期内是可变的，即，系统可以首先给进程分配一定数量的页框。进行运行期间，可以增加或减少页框
                  - 系统可以根据进程的缺页率调整进程的驻留集，当进程的缺页率很高时，驻留集太小，需要增加页框
                  - 当缺页率一段时间内都保持很低时，可以在不会明显增加进程缺页率的前提下，回收其一部分页框，减小进程的驻留集
         - 页面旋转策略
            - 解决的问题：系统应当在内存的什么位置为活跃进程分配页框？
            - 一般，对于一个分页系统或段页式系统，将进程的一个页面装入哪一个页框无关紧要
            - 对于分段系统，需要考虑将一个程序段装入哪一个合适的分区中，可采用的分配算法包括首次适应法，下次适应法，最佳适应法或最差适应法等p
         - 页面获取策略
            - 解决的问题：系统应当何时把一个页面装入内存？
            - 请求调页（Demand Paging）
               - 仅当进程执行过程中，通过检查页表发现相应页面不在内存时，才装入该页面
               - 当里程刚开始执行时，由于预告未装入进程的页面，故需要频繁地申请装入页面。执行一段时间以后，进程的缺页率将下降
               - 采用请求调页方式，一次装入请求的一个页面，磁盘I/O的启动频率较高，系统的开销较大
            - 预调页（Prepaging）
               - 当进程创建时，预告为进程装入多个页面，缺页中断时，系统为进程装入指定的页面以及与之相临的多个页面
               - 若局部性很差，预告装入的很多页面不会很快被引用，并会战胜大量的内存空间，反而降低系统的效率
         - 页面置换策略
            - 当发生缺页中断且无足够的内存空间时，需要置换已有的某些（个）页面，应该解决的基本问题
               1. 当系统欲把一个页面装入内存时，应当在什么范围内判断已经没有空闲页框供分配？
               2. 当指定的范围内没有空闲页框时，应当从指定的范围内选择哪个页面移出内存？
            - 局部置换策略
               - 系统在进程自身的驻留集中判断当前是否存在空闲页框，并在其中进行置换
            - 全局置换策略
               - 在整个内存空间内判断有无空闲页框并允许从其它进程的驻留集中选择一个页面换出内存
            - 固定分配策略 => 局部置换策略
            - 全局置换策略 => 可变分配策略
         - 最近最少使用置换算法
         - 先进先出置换算法
         - 时钟置换算法

   - 页面清除策略
      - 页面清除是指，将由页面置换算法选择的被修改的置换页面保存到外存，页面清除策略需要决定系统何时把一个被置换页面写回外存
      - 最直接的页面清除时机是，只有当一个页被选中作为置换页时，才被写回外存，称之为请求清除策略
      - 方式
         - 若被选中的置换页面自进入内存以来被修改过则需要首先将该页面内容写回外存保存起来，然后，装入进程需要的新页内容
         - 可见，采用请求清除策略时，写出一个被修改过的页面与读入一个新页的操作是成对出现的而且，写出操作先于读入操作
         - 所以，当正在执行的进程发生缺页中断时，需要阻塞等待一个页面的写出和另一个页面的读入，这可能降低处理机的使用效率
      - 一种有效的页面清除策略是结合页缓冲技术
         - 当发生缺页中断时，不必首先写出置换页，然后诗篇新页。而是，将被选中的置换页暂时保留在内存的一个缓冲区，在以后某个合适的时候将这些被置换页批量写出到外存
         - 减少I/O的次数，提高处理机的效率
         - 实现
            - 未修改页链表 和 修改页链表
            - 当选中一个被修改过的页作为置换页时，不需要立即，真正地将其写出到外存，而是首先将其插入到修改链表中缓冲存储。修改链表中的页可以周期性地指写出到外存，并移到未修改表中
            - 未修改表链接被选中的未修改置换页，当其中某页所占用的页框被新页占用时，新页的内容覆盖置换页的内容，置换页被真正从内存清除

   - 负载控制
      - 多道程序系统允许多个进程同时驻留内存，以提高系统吞吐量和资源利用率，然而由于资源竞争可能反而降低系统效率
      - 进程太多发生缺页中断的概率很大，相应地系统发生抖动可能性也会很大
      - 进程太少那么进程同时阻塞的可能性可能会很大，从而降低处理机的利用率
      - L=S准则：通过调整多道程序的度，使发生两次缺页之间的平均时间等于处理一次缺页所需要的平均时间。即，平均地，一次缺页处理完毕，再发生下一次缺页。此时，处理机的利用率将达到最大
      - 50%准则：当分页设备的的利用率保持在50%左右时，处理机的自用率将达到最大

* 设备管理
   - 大纲
      1. 设备管理的主要功能、模型
      2. I/O子系统的组成、结构
      3. 设备的控制、I/O控制
      4. 设备的类型
      5. 设备分配
      6. I/O缓冲技术
      7. 虚拟设备与SPOOLing系统
      8. 磁盘设备的管理

   - 详解
      - 设备分配：多道程序系统中的设备不允许用户直接使用，而是由操作系统统一调度和控制，设备分配程序按照一定策略，为申请设备的用户进程分配设备，记录设备使用情况
      - 设备映射：为了提高应用软件对运行平台的适应能力，方便实现应用软件I/O重定向，大多数现代操作系统均支持应用软件对设备的无关性，即通常所说的设备无关性或者设备独立性
            - 设备无关性：应用软件所引用的，用于实现I/O操作的设备与物理I/O系统中实际安装的设备没有固定联系
      - 设备驱动
         - 也称设备处理，指对物理设备进行控制，以实现真正的I/O操作
         - 设备驱动的主要任务是：接收上层软件发来的抽象服务请求，例如读/写命令，再把它转换为具体要求，通过一系列的I/O指令，控制设备完成请求的操作；同时，设备驱动程序
         - 还将设备发来的有关信号传送给上层软件，例如设备是否已损坏等
      - I/O缓冲区的管理
         - 为了缓和处理机与外部设备间速度不匹配的矛盾，提高处理机和外部设备间的并行性，现代操作系统大都在设备管理部分引入了缓冲技术
         - 通常，缓冲区是指内存中的若干区域，用于缓存进程与外部设备间的数据传输，又称I/O缓冲区
         - I/O缓冲区管理的任务是：组织I/O缓冲区，并为使用者提供获得和释放I/O缓冲区的手段
      - 硬件无关：设备硬件无关层主要实现：I/O缓冲区管理以及设备映射功能，该层与设备用法有关，与设备 硬件无关（一般用在I/O缓冲区和映射）
      - 硬件有关：从设备硬件无关层的角度看，设备硬件相关层为其提供了一个相对简洁的I/O功能接口；该接口屏蔽了设备硬件复杂的操作细节（一般用于驱动）
      - 模块模型
         ```
                       内核中断管理模块
         用户进程  <--------------------*
           |  ^                         |
           v  |                         | 设
         IOCS 资源等待队列，I/O等待队列 | 备
           |  |                         | 中
           v  v                         | 断
         设备驱动程序 启动过程|继续过程 |
           |  |                         |
           v  v                         |
         设备硬件 ----------------------*

         （严格的来说，应该是 I/O设备 连接 控制器，控制器连接 I/O通道
           总线上连接 CPU，内存，I/O通道）
         ```
      - 总线型I/O系统的结构：处理机，内存，各个I/O设备都连在一个系统总线上
      - 通道型I/O系统的结构：处理机，内存，各个连接到I/O设备的I/O通道（一个通道可以连到多个I/O设备上） 都连在一个系统总线上
      - 具有控制器的I/O系统
         - 传统的设备 = 机械部分 + 电子部分
         - 由于电子部分运转比机械部分快，为了降低成本则把电子部分分享出来作为一个独立的部件，这就是控制器
         - 分享之后的设备仅由机械部分组成，一个控制器可与多个设备相连，交替地或分时地控制与其相连的设备，例如，磁盘控制器可以控制多个磁盘驱动器
         - 结构：连接I/O控制器（控制器下连接了I/O设备）的I/O通道 和 处理机，内存在一条总线上
      - 外部设备可以看作设备寄存器，常见的设备控制器有：操作方式寄存器，命令寄存器，数据寄存器，状态寄存器等
      - I/O端口技术
         - 无论一个设备是否由多个控制器控制，或者一个控制器控制了多少个设备，每一个设备都能通过这些寄存器的地址唯一确定称为I/O端口技术
         - I/O地址编址方式
            1. 将设备寄存器与内存物理单元统一编址
            2. 独立于内存物理地址为设备寄存器编址
      - 设备控制
         - 承受着设备不断增多，可能中断号，DMA，内存地址，端口地址等有冲突，为了解决这个问题的产生的设备控制
         - 即插即用：取消了跳线和软件配置程序，当用户插入一个”即插即用“适朽卡或设备时，就可以自动进行检测，配置相应的接口参数，并安装相应的驱动程序
      - I/O控制方式
         1. 程序I/O：在早期操作系统没有中断装置，所以对于I/O设备控制采用程序I/O方式，即忙等待方式或循环测试方式
         2. 中断I/O：后期，设备处理完毕会向处理机发送一条中断信号，处理机响应中断信号后则处理相应的逻辑
         3. 中断I/O改进（DMA方式）：中断I/O比程序I/O方式高效，但以字节为传输单位，每完成一个字/字节的传输，设备均要向CPU请求一次中断
            - 对于块设备而言，这种方式太频繁，大量的中断所累积的开销很大，为了进一步减少处理机对I/O事务的干预，出现了DMA（Direct Memory Access）直接存储器访问方式
               - 数据传输的基本单位是：数据块
               - 数据直接从设备送入内存，或直接从内存送入设备
               - 仅在传送一个或多个数据块的开始和结束时才需要处理机的干预
               - 与中断方式相比，DM方式大大减少了数据I/O对处理机的占用，进一步提高了处理机的利用率，提高了处理机和I/O设备的并行操作能力
         4. I/O通道控制方式
            - 通道相当于一个功能单纯的处理机，专门用于处理I/O操作，通道有自己的运控部件和指令系统，但没有专门的内存，而是通过”周期窃用“方式与主机共享内存
            - 一条通道指令可以传送一组数据，一个通道程序可以传送多组数据。多组数据全部传送完毕后（即一个通道程序执行完毕），才向处理机发出一将领中断
            - 通道程序是在内存里的，可以是预先编写好，也可以是动态生成，通道交换的数据放在内存里的
            - 通道不仅可以传送数据，更重要的是它还完成对设备的控制。在通道的协助下，主机只需发出一个启动通道，执行通道程序的指令即可。主机仅与通道直接通信，不必
            - 考虑设备的具体控制以及如何完成数据传送等问题，从而大大减轻了主机的负担
      - 设备类型
         1. 外部设备用途不同分：输入/输出型设备 与 存储型设备
         2. 外设传输基本数据单位不同分：块型设备 与 字符型设备
         3. 资源管理方式不同分：独占型设备 与 共享型设备
      - 设备分配
         - 需要记录与他们相关的信息，包括：资源标识，物理连接情况，占有进程，等待进程等
         - 可以将其分为设备控制块，控制器控制块，通道控制块
         - 控制块中包含的信息在不同的系统中会有所不同
      - 系统设备表 SDT
         - 根据上述实现要求，系统通常将相同类型设备的 UCB 记录在一张表中，称作 UCB 表，将逻辑设备名，设备数，设备等待队列以及UCB表的起始地址登记在另一个表中该表通常称作系统设备表（SDT）
         - 包含：设备类别，设备总数，可用设备数，设备等待队列，UCB首址
         - 设备分配算法
            - 先来先服务：按先来先服务处理，设备总是分配给队首的进程
            - 优先级高者优先服务：根据进程优先级高低，将优先级高的排在等待队列前面，对于优先级相同的则按先来先服务的原则进行排队
      - 设备的分配
         1. 独占型设备的分配：当进程的一次设备申请成功，直到发出释放命令期间，一直独占设备
         2. 共享型设备的分配：不需要申请，当然也就不存在战用或释放设备的问题
            - 但是，I/O期间只能有一个进程使用设备，因此，进程使用共享型设备之前，有一个隐含的申请命令；使用完毕后，有一个隐含的释放命令，以实现一次基本I/O传输期间的排它性，保证操作的正常运行
            - 使用共享型设备的过程中，进程完全有可能进入阻塞等待状态
      - I/O缓冲区技术
         - 缓解处理机与设备间速度不匹配的矛盾，实现设备与处理机一定程序的并行操作，减少设备的中断频率，放宽对中断响应时间的限制
         - 提前读：指用户进程从I/O缓冲区中取走前一个数据以后，立即发出对下一个数据的输入请求，显然用户进程加工前一个数据的工作与操作系统输入下一个数据的工作可以同时进程
         - 延后写：是指用户进程请求输出数据时，操作系统将很快把用户进程请求输出的数据从用户进程的工作区中取走并将其暂时存放在I/O缓冲区中
            - 直到用户进程指定的输出设备空闲时，操作系统才把暂时存放在I/O缓冲区中的用户进程的输出数据写入用户进程指定的输出设备上
            - 显然，用户进程生成下一个输出数据的工作与操作系统输出前一个输出数据的工作可以同时进行
         - 缓冲区类型
            - 硬件缓冲区：配置在设备中，具有专门的用途对处理机透明，不需要处理机的直接管理，不会影响系统性能
            - 软件缓冲区：是内存空间的一部分，其目的是为了弥补硬件缓冲区的不足，因为并非所有外设都拥有，或者足够拥有硬件缓冲区
            - 操作系统中介绍的缓冲区都是指软件缓冲区
         - 组织形式
            - 单缓冲：仅在内存中为进程对某个设备的I/O访问分配一个缓冲区
            - 双缓冲：增加一个缓冲区可以交替使用，当数据从缓冲区复制到用户进程空间时，输入设备不必等待，可立即开始向另一个缓冲区输入数据
               - 另外，若用户进程阵发性I/O的数据超过一个缓冲区而不满两个缓冲区，双缓冲使进程不会在I/O数据期间被阻塞
            - 循环缓冲：当用户进程处理数据的速度较快，外部设备处理数据较慢，或者用户进程阵发性输入/输出的数据较多时，必须考虑增加缓冲区的数量以发送系统性能，这就是多缓冲区方式
               - 这个I/O缓冲区常常被组织成一个环形队列，故，称为循环缓冲，驭驭缓冲可以看作是循环缓冲的一个特例
            - 缓冲池：上述三种缓冲区的组织形式仅适用于某种特定的I/O进程和计算进程，属于专用缓冲
               - 缓冲池类型
                  - 块型设备缓冲池
                     - 缓冲区较大，其长度通常与外部设备物理块的长度相同
                  - 字符型设备缓冲池
                     - 用于字符型设备的缓冲池，缓冲区较小，其长度通常为8个字节，16个字节等
               - 解析
                  - 当系统中设备很多时，将会有许多这样的循环缓冲区，消耗大量的内存，利用率也不高，为了提高缓冲区利用率，可以采用公共缓冲池技术，这个池可以为多个设备和进程服务
                  - 缓冲池中的缓冲区通常组织成链表，需要缓冲区时，从鍡申请一个或多个缓冲区，使用完毕时，释放的缓冲区回到链表
                
      - 虚拟设备
         - 独占型设备速度一般较慢，进程常需要长时间等待I/O传输完成，影响进程的推进速度，进程在占用设备期间不一定一直使用此设备而其它进程只能阻塞，引入虚拟设备技术能解决独占设备利用率不高的问题
         - 虚拟设备技术类似缓冲区技术，可以认为是为设备提供了多个更大，甚至无限长度的缓冲区
         - 实现：在独占型设备与进程之间加入一个 共享型设备 作为过渡

      -. 磁盘设备的管理
         - 影响磁盘性能和数据安全性的主要因素
            - 磁盘性能参数：转速、寻道时间、磁盘缓存
            - 磁盘控制器：IDE SCSI磁盘控制器
            - RAID等磁盘容错技术（磁盘阵列）
            - 磁盘管理算法：磁盘调度算法，磁盘高速缓存、高性能的文件系统
         - 描述
            - 硬盘的转速比软盘快几十倍，并在开机后一直调整旋转，随时准备就绪；而软盘则需要I/O时才被旋转，否则停止旋转。软盘使用前必须等待转速从0加速，并稳定到额定转速，故效率较低

            - 磁盘由若干张圆形的盘片组成，每张盘片上都涂有磁层，用于记录数据
            - 各盘片的圆心固定在一个旋转轴上，该轴沿固定方向等速地转动，并带动磁盘组不停地旋转
            - 每长备片分为上，下两个盘面，每个盘面有若干磁道，同一盘面上的所有磁道是绕旋转轴的一组同心圆，所有磁道由外向内依次由0开始编号，称为磁道号
            - 磁盘组中各盘面上序号相同的磁道构成一个柱面，由外向内依次编号，若磁盘组有n个柱面，则编号0,1,2,...,n-1，称为柱面号
            - 若磁盘组共有s个盘片，则一共有2s个盘面，但通常最上面和最下面的两个盘面作为伺服面，用以进行控制磁头定位等操作，并不存放数据。因而实际可用盘面数为m=2(s-1)，由下至上依次编号为0,1,2,...m-1 称为盘面号
            - 整个盘面被划分为若干个大小相同的扇面，它把一个磁道等分为若干个区域，一个区域称为一个扇区。数据保存在各个扇区中，每个扇区内保存的数据量相同，为2的幂次，例如512字节，1024字节甚至2048字节
            - 扇区是磁盘进行I/O传输的基本单位，也是磁盘空间分配的基本单位。若扇区的数量为n，则每条磁道上的扇区被依次编号为0,1,2,...,n-1，称为扇区号
            - 磁盘的基本存储单元（扇区）的寻址方式为三维地址：柱面号，盘面号，扇区号
         - 磁头的工作方式
            - 固定头磁盘工作方式
               - 固定头磁盘的每一条磁道上都有一个读写磁头，所有的磁头都被安装在一刚性磁臂中，通过磁头访问磁道，可以并行读/写，磁盘的I/O速度很快
               - 优点是访问速度快，其缺点是成本较高，容量受磁头数量限制
            - 移动头磁盘工作方式
               - 移动磁头为每一个盘面配置一个磁头，所有盘面的磁头被装入磁臂中，磁盘I/O时，必须移动磁头（寻道）
               - 由于其具有结构简单，成本较低，容量不受磁头数量限制等优点，因而被广泛使用
         - 性能的时间
            - 磁盘接收到读指令后，磁头从当前位置移到目标磁道位置，所需的时间称为 “寻道时间”
            - 然后，旋转磁盘，定位数据所在的扇区，所需的时间称为 “旋转延迟”
            - 最后，从磁盘上读取数据，所需的时间称为 “数据传输时间”
            - 访问时间 = 寻道时间 + 旋转延迟 + 传输时间
            - 性能影响
               - 寻道时间：把磁头从当前位置移动到指定磁道所需要的时间，是影响磁盘数据传输率的重要参数，与磁头移过的磁道数量成正比
               - 旋转延迟：与磁盘转速直接相关，是指旋转磁盘，将指定盲区移动到磁头下面所需要的时间
               - 传输时间：是指把数据从硬盘读出或向磁盘写入数据所经历的时间
         - 磁盘调度算法
            - FCFS（First Come First Serve）先到先服务：按输入/输出请求的先后次序为各个进程服务
            - SSTF（Shortest Seek Time First）最短时间优先算法：优先为距离磁头当前所在位置最近的磁道服务
               - 会因为集中于某一个区域而造成其它磁道产饥饿
            - SCAN 扫描算法（电梯算法）：假定开始时磁头处于最外磁道（首先方向是向内），
               - 在磁头移动过程中，如果经过的磁道属于要要进行访问的，则为其服务，然后判断当前磁道
               - 以内的磁道是否还有访问请求，如果有，则磁头继续向内磁道方向移动；否则，判断当前磁道以外的磁道是否有访问请求，若有，则磁头掉转方向朝外移动（朝外逻辑相同先到外直到没有需要访问的磁道再向内）
               - 没有则停在这个磁道
               - 比较公平，若在某一段时间内某一磁道的访问请求不断，则磁头引臂将停留在该磁道上不动（称为磁臂粘着），磁盘被相应的进程垄断，所有其他磁道上的请求将在较长时间内得不到服务
            - N-SCAN，N步扫描算法
               - 将磁盘请求队列分成若干个长度为 N 的子队列（即N个为一组），磁盘调度程序按照FCFS算法依次处理这些子队列，而处理每一个子队列时，则按照SCAN算法
               - 当N值取得很大时，N步扫描算法的性能与SCAN算法的性能相当；当N取值为1时，N步扫描算法退化为FCFS算法
            - C-SCAN

         - 磁盘高速缓存
            - 指，操作系统利用内存实现的，专门针对磁盘I/O操作的缓冲区，
            - 与磁盘机本身所带的缓存以及磁盘控制器所带缓存相比，磁盘机和磁盘控制器上的缓存的特点
               - 容量小，利用此类缓存进行数据提前和延后写操作能与主机并行工作
            - 磁盘高速缓存特点
               - 容量较大
               - 常存储全局范围，经常访问的重要数据：文件系统的目录、文件分配表、索引块等；
               - 缺点：利用该缓存进行数据提前读和延后写操作需要主机的管理，增加了主机的负担
                  - 对于高档的服务器而言，大抵硬件缓存更能提高磁盘I/O性能，但是，若磁盘机和磁盘控制器上没有缓存，那么，就需要领先磁盘调整缓存的作用
            - 磁盘调整缓存写入的安全性
               1. 在系统空闲或需要淘汰被写的缓存空间时进行写，这种策略风险最大，效率高
               2. 周期性地进行写，风险较低，效率较高
               3. 立即写回，即只要调整缓存中的某盘块数据被修改，便立即将它们写回磁盘。这种高速缓存通常被称为“写穿透高速缓存），相当于只有读缓存而没有写缓存，其风险最低，效率也是最低的

         - Disk Cache 工作原理
            1. 读取
               - 当用户进程请求从磁盘读入一个扇区时，系统首先在 disk cache 中寻找该扇区的副本
               - 如果能够找到，那么系统将从 disk cache 中取出该扇区的副本，否则系统首先从磁盘中读入该扇区并在disk cache中为其建立一个副本，然后返回这个数据给进程
            2. 写入
               - 当用户进程请求向磁盘上写入一个扇区时，系统同样首先在disk cache 中寻找该扇区的副本，如果找到了，那么系统将根据用户进程的请求修改该扇区的副本
               - 否则，系统同样首先从磁盘上读入该扇区并在 disk cache 中为其建立一个副本，然后根据用户进程的请求修改该副本

         - 磁盘容错技术
            - 磁盘中的数据往往存储着重要的数据，如果存储这些数据的磁盘报废，后果严重，因此要求保证磁盘数据的可靠性
            - 磁盘容错技术通过在系统中设置冗余部件来提高系统可靠性。冗余部件包括增加冗余的磁盘驱动器，磁盘控制器等，使得当磁盘系统某部分出现缺陷或故障时，磁盘仍能正常运转，不至于造成数据的错误和丢失
            - SFT（System Fault Tolerance），大体分为三个级别：
               1. SFT-I 低级磁盘容错技术，主要防止磁盘表面介质缺陷所引起的数据丢失
               2. SFT-II 中级磁盘容错技术，主要防止磁盘驱动器和磁盘控制器故障所引起的数据丢失
               3. SFT-III 高级系统容错技术，常使用双服务器，以保证在其中一台服务器出现故障，甚至停止工作时，整个系统仍能照常动作
            - SFT详解
               1. 第一级容错技术
                  - 双目录和双份文件分配表
                     - 文件目录和文件分配表FAT是文件管理所需关键数据结构，可在不同的磁盘上或同一磁盘的不同区域中，分别建立维护两份目录和FAT
                     - 当其中一个目录或FAT损坏时，系统便自动启用另一个目录和FAT，同时在磁盘的其它区域再建立新的文件目录和FAT
                     - 每当系统重新启动时，都要对这两份目录和FAT进行检查，以保证它们的一致性
                  - 热修复重定向和写后读校验
                     - 热修复重定向是指，系统将一定的磁盘容量作为热修复重定向区，用于存放当发现磁盘块有缺陷时的待写数据，并对写入该区的所有数据进行登记，以便于以后对此数据进行访问
                     - 写后读校验是指，每次将数据写到磁盘后，立即从磁盘上读出该块数据，并进行对比，若写入的数据与读出的数据一致，则表示写入成功；否则，重写数据。若重写后两者仍不一致，则认为该磁盘块有缺陷，便将该块标识为坏块，相应数据写入热修复重定向区中

               2. 第二级容错技术
                  - 磁盘镜像
                     - 在同一磁盘控制器上，连接两个完全相同的磁盘驱动器，同一数据被先后写到两个驱动器上互为备份
                  - 磁盘双工
                     - 将两台完全相同的磁盘驱动器连接到两个磁盘控制器上，数据被同时写到两个磁盘上

               3. 第三级容错技术
                  - RAID（Redundant Array of Independent Inexpensive Disks） 技术，独立或廉价磁盘冗余阵列
                     - “独立”是目前通用的一个行业术语，强调RAID阵列抆重要性和可靠性
                     - “廉价”是较早使用的一个术语，重在强调RAID磁盘阵列中采用的相对较小的，价格较便宜的磁盘
                  - RAID 磁盘阵列技术能以较低的成本，提供大容量，快速，安全可靠性磁盘存储系统，从容错的角度讲，是属于第二级容错技术，但其内涵远远不止如此
                  - 一组可以并行工作的磁盘所构成的磁盘阵列，在磁盘子系统中执行的或者在主机系统中执行的磁盘阵列管理软件
                     - 磁盘阵列管理软件把逻辑上连续的一组数据交叉分布存储在磁盘阵列中的各个磁盘上

            - RAID的各阵列作用
               - RAID0
                  - 仅使用了条带化技术
                  - 不存储数据的校验信息
                  - 能提供大容量，快速的磁盘存储能力
                  - 具备最好的读/写性能和最低的成本
                  - 磁盘容量的利用率为 100%
                  - 但其安全性最低，其中任何一个磁盘损坏便会导致整个系统不可使用
               - RAID1
                  - 仅使用了磁盘镜像或磁盘双工技术
                  - 能提供最好的安全性，其中任何一个磁盘损坏都不会导致数据丢失
                  - 但磁盘容量的利用率只有 50%，成本较高
                  - 对磁盘的读/写性能没有提高
               - RAID2
                  - 仅使用了磁盘镜像或磁盘双工技术
               - RAID3
                  - 同时使用了磁盘条带化技术（细粒度，条带大小为一个字节或一个字）和奇偶校验容错技术）
                  - 假定磁盘阵列中有N个磁盘，则RAID3将数据条带化到其中N-1个磁盘上。使用一个磁盘专门存储N-1个磁盘的奇偶校验数据
                  - 因此，N个磁盘中任意损坏一个，都不会导致数据的据丢失
                  - RAID3的优点是有较快的速度和较高的安全性，磁盘空间的利用率为(N-1)/N，成本相对RAID1较低
               - RAID4
                  - 没有详解
               - RAID5
                  - 与RAID3类似，主要区别是：
                     1. RAID3使用一个磁盘专门存储奇偶校验数据，对于每一个写操作（可能仅是一个条带），均要写奇偶校验磁盘，不但奇偶校验磁盘的负担较重，容易损坏，而且多个独立的写操作不能并行进行
                     2. RAID5使用粗粒度的条带，将奇偶校验数据分布到每一个磁盘中，没有专门的奇偶校验盘，因而克服了RAID3的缺点，当然，RAID5比RAID3稍复杂


* 文件管理
   - 大纲
      1. 文件管理系统
      2. 文件的基本概念，操作
      3. 文件目录
      4. 文件的逻辑组织与访问
      5. 文件记录与数据块的关系
      6. 文件共享
      7. 文件存储空间与空闲空间的管理

   - 文件系统与数据库管理系统
      - 数据库管理系统依赖文件系统
         - 数据库管理系统负责：数据定义及操作
         - 文件系统只处理无结构，无格式的字节流
      - 数据库管理系统独立于文件系统
   - 文件
      - 文件是一种具有符号名，相关联元素的有序集合
      - 数据结构
         - 字段或域
            - 字段具有唯一的值
            - 字段的基本属性：长度，数据类型
            - 字段长度：固定，可变
            - 复合字段：由若干子字段组成
               - 加工资字段：基本工资，工龄工资，职称工资等
         - 记录
            - 一组相关字段的集合
               - 学生记录：学号，姓名，性别，班级，平均成绩，名次，获奖情况等
            - 记录长度：固定，可变
               - 可变长记录：字段长可变，字段数目可变
               - 可变长记录：长度字段
            - 记录：关键字，唯一 地标识一条记录

         - 文件类型
            1. 按文件逻辑结构分类
               - 无结构文件
                  - 可以看成是一个字节流，其文件元素为一个“字符”或“字节”，有时又称为字节流文件，或流文件
               - 有结构文件
                  - 有结构文件的文件元素是一条记录，文件由若干相关记录组成
                  - 根据记录的组织方式不同，可以分为堆文件，顺序文件，索引顺序文件，索引文件和直接（哈希）文件
            2. 按文件物理组织结构分类
               - 连续文件：把文件中的信息顺序，连续地存储到若干相邻的存储块中
               - 非连续文件：链接文件，索引文件
                  - 链接文件
                     - 文件逻辑上连续的信息可以存储到分散各处的存储块中，各盘块块通过其内的链接指针相连
                     - 一个文件的所有盘块形成一个链表，或用专门的存储块记载一个文件的所有盘块的起始地址
                  - 索引文件
                     - 文件中逻辑上连续的信息可以存储到分散各处存储块中
                     - 系统为每个文件建立一张索引表，一个索引表项记载一个存储块或一组连续存储块的起始地址

            3. 按文件的保护级别分类
               - 读/写文件：只允许文件主及授权用户进行读或写的文件
               - 不保护文件：所有用户都可以访问的文件，不受系统的任何保护
            4. 按文件的性质和用途分类
               - 系统文件：指操作系统文件或其它系统文件，一般只能通过操作系统调用为用户服务
               - 用户文件：由用户的程序或数据组成的文件
               - 库文件：由系统提供给用户调用的各种标准过程，函数和应用程序等，这类文件允许用户调用，但不允许用户修改，如Windows的应用程序编程接口API，C语言的标准I/O库函数及通信库函数等
            5. 按文件中的数据形式分类
               - 源文件
               - 目标文件
               - 可执行文件


         - 对文件的操作
            - 打开文件
               - 根据文件名查找目录文件，找到该文件目录信息，然后，将该目录信息装入主存，建立相应的文件控制块FCB，并将文件的当前作用信息填入FCB中
               - 最后，返回一个文件内部标识符，如果该文件具有某种存取控制，如只读，或可读/写，则文件打开时，这种存取控制也将作为参数同时返回
            - 关闭文件
               - 将该文件FCB中的有关信息写入外存目录信息中，撤销其FCB，释放文件占用的其它系统资源，切断用户与该文件的联系
            - 建立文件
               - 分配必要的外存空间，建立一个目录项，记录新文件的文件名，建立时间等信息
            - 删除文件
               - 判断该文件可否被删除，若可以被删除，则首先删除文件的目录项，否则，给出相应提示，回收该文件所占用的外存空间

         - 文件目录
            - 基本信息：文件名，文件类型，文件组织等
            - 地址信息：卷（存储文件的设备），起始地址（起始物理地址），文件长度（以字节，字或块为单位）等
            - 访问控制信息：文件所有者 ，市况信息（用户名和口令等），合法操作等
            - 使用信息：创建时间，创建者身份，当前状态，最近修改时间，最近访问时间
            - 目录结构
               1. 单级目录结构
                  - 所有用户的全部文件目录保存在一张目录表中，每个文件的目录项占用一个表项
                     ```
                     目录项1 --> File1
                     目录项2 --> File2
                     目录项3 --> File3
                     ...
                     目录项4 --> File4
                     ```
                  - 重名问题，存放文件数量受限，当目录文件很大时，检索时间长，不便于实现文件共享
               2. 两级目录结构
                  - 主文件目录，用户文件目录
                     ```
                     主目录        User1目录
                     User1 ------> File1
                     User2 -----*  File2
                     User3      |  ...
                     ...        | 
                                | 
                                *--> User2目录
                                     File1
                                     File2
                                     ...
                     ```
                  - 不便用户文件的逻辑分类；进一步解决重名，共享，检索效率等问题
               3. 层次目录结构：树型目录结构，无循环图
                  - 树型目录
                  - 无循环图
                     - 根树型目录一样，但是子节点可以指向另一个子节点，以此形成目录的共享功能
         - 文件类型
            1. 堆文件：数据始终往后面追加，更新数据也是要加在最后
            2. 顺序文件：以某个关键字作为排序顺序
            3. 索引顺序文件
               - 将主文件（顺序文件）的所有记录按照某种标准分组，例如，首字母相同的记录为一组，为主文件建立一张索引表
               - 索引表记载每一组第一条记录关键字值和指向该记录的指针，索引表和主文件（顺序文件）一起形成索引顺序文件
               - 多级索引
                  - 若主文件非常大，只建立一级索引，则访问效率还是很低
                  - 为了提高访问效率，可以为顺序文件建立多级索引，即为索引文件再建立一张索引表，从而形成两级索引，依此类推
                  - 根据实际需要还可以建立更多级索引
                  - 访问信息时，总是从最高级索引表开始，逐级向低级索引表进行访问最后访问到主文件中的某记录

            4. 索引文件
               - 概述
                  - 文件中记录的访问并非总是按关键字进行，很多应用对记录的访问都是随机的
                  - 例如，交互式查询系统往往需要根据用户给定的条件，查询文件中的某条或某几条记录，而非顺序访问文件的每一条记录
                  - 主文件的记录不必按关键字排序
                  - 为文件建立一张索引表，主文件中的每一条记录在索引表中都有一个对应的表项，其中记载了相应记录的索引值及指向记录的指针，并按索引值排序
               - 完备索引：为主文件的每条记录建一个索引项
               - 部分索引：仅为感兴趣的记录建立索引

            5. 直接（哈希）文件
               - 利用Hash函数，根据记录的关键字计算记录的存储位置，并按关键字访问记录，能提高记录的访问效率，
               - 常用于访问速率要求高，一次存取一条记录且记录为定长的文件。如文件目录，价格表，名单等文件记录的存取

         - 文件的物理组织（存储空间的管理）
            - 预分配与动态分配
               - 预分配：一次性地为新文件分配足够的存储空间
               - 动态分配：先为文件分配一部分存储空间，以后再根据需要增加存储空间
            - 分区大小
               - 概述
                  - 外存空间被分成若干大小相同的数据，类似于内存空间的分页管理技术
                  - 分区 = 数据块，有利于提高外存空间的利用率，I/O性能较低
                  - 可变大小的分区，分区 = 若干连续数据块
               - 对于预分配方法，若采用小分区，预先分配给文件足够数量的小分区，可能使文件分配表很大，但由于文件空间不再增加，文件分配表将保持固定大小，不会改变
               - 若采用可变大小的连续分区模式，无须设置文件分配表，只需要记住文件存储空间的第一个数据块的地址和分区大小，就能定位一个文件
             - 基于可变分区的分配算法
                - 首次适应法
                - 下次适应法
                - 最佳适应法
             - 文件存储空间的分配技术
                - 连续分配：
                   - 采用可变大小的连续分区，预分配技术，把逻辑文件中的数据顺序地存储到物理上邻接的各个数据块中，这样形成的物理文件可以进行顺序存取，优点：简单，容易实现
                   - 文件分配表中为每个文件建立一个表项，其中记载文件的第一个数据块地址及文件长度，对顺序文件，连续读/写多个数据块内容时，性能较好
                   - 能很快检索文件中的一个数据块
                   - 构建图
                   ```
                   0->1->2->3
                                11->12->13

                   # 文件分配表
                   文件名    起始块号    文件长度
                   FILE1     0           4
                   FILE2     11          3
                   ...       ...         ...
                   ```
                - 非连续分配：链接分配和索引分配
                   - 链接分配：一个数据块指针指向下一个数据块
                   - 数据可靠性不高且浪费空间：因为如果一个数据块坏掉了那么整个文件都废了，而且每个数据块的指针所占空间总和也是一个不小的空间
                   1. 链接分配
                      - 为了提高文件检索速度及减少块内指针占用的存储空间，有的操作系统将文件分区设置为若干个（数目相同或不同）连续的数据块，称之为簇
                      - 这样，为文件分配存储空间时，以可变大小分区为单位，文件的存储空间不再由若干离散的，小的数据块构成，而是由数目相对较少的，局部连续的文件分区组成
                      - 每个文件的各个文件分区通过指针链接在一起
                      - 构建图
                      ```
                      # 存储数据块大致图
                          3<------*
                             5<-* |
                          7     | |
                          ^---- 8-*
                                |
                          *-----*-*
                          |       |
                          v       |
                          11   20<*

                      # 文件分配表
                      文件名   索引块号
                      FILE1    8
                      ...      ...

                      # 8里面记录的索引号信息顺序：3,5,7,11,20 表示数据块的顺序

                      # 如果8数据块容量不足以容纳文件的索引块号，则指向的某一个索引块号的内容不作为指向数据而作为指向索引块号，以此建立多级索引
                      # 这样的分配方式会造成索引信息太多
                      ```
                   2. 链接分配（通过紧凑优化之后的情况）
                      - 构建图
                      # 存储数据块大致图
                      ```
                      0->1->2->3->4 5->6
                                       |
                      *----------------*
                      v
                      7->8->9->10

                      # 文件分配表
                      文件名    起始块号    文件长度
                      FILE1     0           5
                      FILE2     5           6
                      ...       ...         ...
                      ```
                   3. 可变分区的索引分配
                      - 构建图
                      ```                                                
                      3,4,5,7,8,9,10 是连续的
                      28,29,30 是连续的
                      # 存储数据块大致图
                                                 -----------------------*
                                                 v                      |
                                                 3        4        5    |
                       7        8        9      10                      |
                                                                         
                                                16<---------*           |
                                                            |  *--24 ---*
                                                            |  |  |      
                                                            *--*  |      
                                                v-----------------*     
                                                28       29       30

                               
                      # 文件分配表
                      文件名    索引块号
                      FILE1     24

                      # 24里面记录的索引号信息顺序
                        起始块号    分区长度
                        3           7
                        16          1
                        28          3
                      ```
         - 空闲空间的管理
            - 空闲分区表
               - 各个空闲分区记录到一个表中，一个分区对应一个表项：空闲分区号，分区起始块号，分区长度
                  - 比较适合于连续空闲分区的情况
                  - 分配空间时，按空闲分区表顺序查找第一个适合的空闲分区，进行分配（首次适应算法），也可以采用下次适应算法
                  - 然后，将该分区分配给文件，同时修改空闲分区表，删除相应表项
                  - 当删除文件释放出空闲时，系统回收其存储空间，合并相信空闲分区
                  ```
                  空闲分区号    分区起始块号    分区长
                  1             0               1
                  2             5               4
                  3             18              2
                  ...           ...             ...
                  ```
            - 空闲分区链表
               - 用专门的空闲分区表登记空闲分区信息会浪费一定的存储空间，而且不适合登记分散且数目很多的空闲分区，乑利于基于存储块的链接文件和索引文件的存储空间分配
               - 可以通过指针将各个空闲分区连接起来，并记载各空闲分区大小，称为空闲分区链表
               ```
               分区起始块号-分区长 -> 分区起始块号-分区长 -> ...
               ```
               - 使用一段时间后会使会使空间分区链太多小分区，使文件分配到的存储空间过分离散影响查询
            - 索引
               - 将空闲分区看作文件，按文件存储空间分区方法为空闲分区建立索引
               - 基于可变分区建立索引比基于存储块建立索引的效率高
               - 索引表中为每一个空闲分区建立一个索引项，根据索引项查找空闲分区，将会提高文件存储效率
               - 利用索引方法管理空闲空间，适合于各种文件分配法
               ```
               存储情况
               0         5
               6 7 8 9      
                            
                            
               23 24
               29

               空闲分区索引表
               分区号  分区长度  索引指针
               1       1         指向0
               2       4         指向5
               3       2         指向23
               4       1         指向29
               ```
            - 位示图
               - 概念1
                  - 利用二进制位0,1表示存储空间中存储块的使用状态。空闲分区:0，已分配分区:1（或者相反）
                  - 由所有存储块对应的位构成一个向量称为位示图，如图
                  - 可以容易地找到一个或一组连续的空闲分区，分配空闲空间时，从位示图中查找标志位为0的位，并按照某种算法换算成对应的空闲存储块号
                  - 及物理位置，并修改对应位为1
                  - 当删除文件释放存储空间时，将释放的所有数据块逐一换算成对应的图位置，并将其对应的二进制位的值修改为0
                  - 一个位示图需要占用的存储空间大小为：磁盘容量(字节数)/(8 * 数据块大小)
                  - 如果块占用的大小很小，那么会占用较大的空间来存储位未曾图
               - 概念2
                  - 因此，大多数使用位示图的文件系统都需要另设一个辅助数据结构，用于汇总位示图的子区域内容
                  - 可以将位示图按逻辑结构划分为若干子区域，一个子区域表示一个连续的空闲分区
                  - 泄总表中记载连续空闲分区的个数和连续空闲分区的长度，若需要为文件分配连续空间，则首先查找泄总表，快速找到合适的子区域，再将其对应的空闲分区分配出去
               - 演示图
               ```
               011100011010...
               ```

         - 逻辑文件与物理数据块之间的转换
            - 无结构字节流文件：由若干字节组成，其内不含任何数据结构，其中每一个字节对应一个非负整数索引号
               - 文件指针指向文件中某个字节的位置
               - 而文件在存储介质上是以数据块为存储单位，一个数据块包含若干字节
               - 因此，无结构字节流系统必须提供一个字节流与数据块之间的转换接口，简称“流-块转换器”
            - 有结构文件：由若干记录构成，对应的物理数据块也是由记录构成
               - 因此，必须通过“记录-块转换器”将数据块转换成记录，或将记录转换为数据块

         - 将记录组织成数据块
            - 对于固定长数据块，根据记录长度固定还是可变，以及一条记录是否可以分开存储在不同数据块中，常有三种记录组块方法
               - 固定组块法
                  - 数据块由若干条固定长度的记录组成，各种各样记录必须完整地存储在一个数据块中
                  - 中可能会存在一些不能容纳一条完整记录的空间，称为内部碎片
               - 可变长跨组块法
                  - 允许记录被存储在不同数据块，用指针链接一条跨块存储记录所在的两个数据块
                  - 增加了文件修改的难度，且I/O效率效低
               - 可变长非跨块组块法
                  - 如果不允许记录跨块存储，则可以有效解决此问题，可变长非跨块组块法的数据块由变长记录组成，不允许一条记录跨越两个数据块存储


         - 文件共享的控制
            - 文件共享的有效控制涉及两个方面
               - 同时存取
               - 存取权限
            1. 链接目录项实现文件共享
               - 文件目录项中设置一个链接指针，用于指向共享文件的目录项
               - 访问文件时，根据链接指针内容找到共享文件的目录项并作系列操作
               - 每当有进程共享文件时，共享文件目录项中“共享计数”加1；当进程不再共享该文件，执行撤销链接指针时，“共享计数”减1
               - 只有当共享文件进程数为1时，才能删除共享文件
            2. 基本文件目录实现文件共享
               - 系统设置一张基本文件目录（BFD），其中保存每个文件的目录项，目录项中包含文件的唯一标识符，以及文件的有关说明信息，如文件的物理地址，访问控制和管理等信息
               - 用户的符号文件目录项（SFD）中包含文件名和文件标识符等信息
               - 为所有用户调协一张主文件目录（MFD），其中记载用户名及用户符号文件目录（文件）标识符，该标识符值也由系统自动赋予
            3. 利用索引节点实现文件共享
               - unix操作系统的文件目录项中只包含文件名和指向索引节点的指针，文件的物理地址及其它说明信息保存在索引节点中
               - 可以通过共享文件索引节点来共享文件，即当用户需要共享文件时，在自己的文件目录中新建一个目录项，为共享文件命名（也可用原名），并将索引节点指针指向共享文件的索引节点
            4. 利用URL实现文件共享
               - 统一资源定位器，是Internet上用来链接超文本文件的一种方法
               - 它可以链接同一台计算机中的本地文件，也可以链接Internet中任何主机上的远程文件
               - 一个完整的URL包括访问文件的方法（协议），文件所在的主机域名，目录路径名和文件名几部分

         - 安全性管理
            - 系统级管理
            - 用户级管理
            - 目录级管理
            - 文件级管理


M52女孩( co gaiM52)

